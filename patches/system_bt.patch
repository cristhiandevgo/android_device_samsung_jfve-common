From d927eb2b7be31398f72c06e44e43aa54aa51c663 Mon Sep 17 00:00:00 2001
From: ripee <ripee.dev@gmail.com>
Date: Thu, 28 Feb 2019 20:56:40 +0100
Subject: [PATCH] Revert "eSCO: Format changes to original vendor patch (4/5)"

This reverts commit fe695a557a92053d4c44428ba08c0b8e945d4711.

Revert "eSCO: Additional fix to get eSCO working for HFP and HSP (3/5)"

This reverts commit 400ac497f45181d3c64f6a19687992de9b69b094.

Revert "eSCO: Remove BTM_WBS_INCLUDED from the stack (2/5)"

This reverts commit 3e634d6c1e83f053005c9abdbd89e662ad81c4d4.

Revert "eSCO: BT 4.1 Enhanced SCO command (1/5)"

This reverts commit 57f6508cf7b22788fa2e7a739cec241b785718fb.
---
 bta/ag/bta_ag_act.cc               |   14 +
 bta/ag/bta_ag_cfg.cc               |    8 +-
 bta/ag/bta_ag_ci.cc                |   88 ++
 bta/ag/bta_ag_cmd.cc               |   20 +-
 bta/ag/bta_ag_int.h                |   62 +-
 bta/ag/bta_ag_main.cc              |  204 ++++-
 bta/ag/bta_ag_sco.cc               |  716 +++++++++++++---
 bta/dm/bta_dm_act.cc               |    4 +-
 bta/hf_client/bta_hf_client_sco.cc |   78 +-
 bta/include/bta_ag_api.h           |    3 +
 bta/include/bta_ag_ci.h            |   70 ++
 bta/include/bta_ag_co.h            |  116 +++
 bta/include/bta_dm_co.h            |   35 +-
 bta/sys/bta_sys_main.cc            |    4 +-
 btif/Android.bp                    |    1 +
 btif/BUILD.gn                      |    1 -
 btif/co/bta_ag_co.cc               |  151 ++++
 btif/co/bta_dm_co.cc               |  135 +++
 btif/src/btif_hf.cc                |   30 +-
 btif/src/btif_rc.cc                |    4 +
 btif/src/btif_sock_sco.cc          |   20 +-
 btif/src/btif_util.cc              |    2 +
 device/Android.bp                  |    1 -
 device/BUILD.gn                    |    1 -
 device/include/controller.h        |    2 -
 device/include/esco_parameters.h   |   14 +-
 device/src/controller.cc           |   12 -
 device/src/esco_parameters.cc      |    4 +-
 hci/Android.bp                     |    1 +
 hci/BUILD.gn                       |    1 +
 hci/include/bt_vendor_lib.h        |    2 -
 hci/include/hci_audio.h            |   40 +
 hci/src/hci_audio.cc               |   38 +
 internal_include/bt_target.h       |   21 +-
 stack/btm/btm_devctl.cc            |   32 +-
 stack/btm/btm_int.h                |    4 +-
 stack/btm/btm_int_types.h          |   41 +-
 stack/btm/btm_sco.cc               |  485 ++++++-----
 stack/btu/btu_hcif.cc              |    5 +-
 stack/hcic/hcicmds.cc              |   16 +-
 stack/include/btm_api.h            |    8 +-
 stack/include/btm_api_types.h      |   76 +-
 stack/include/hcidefs.h            | 1245 +++++++++++++++++++++++++++-
 stack/include/hcimsgs.h            |   18 +-
 stack/include/sdpdefs.h            |    2 +
 45 files changed, 3350 insertions(+), 485 deletions(-)
 create mode 100644 bta/ag/bta_ag_ci.cc
 create mode 100644 bta/include/bta_ag_ci.h
 create mode 100644 bta/include/bta_ag_co.h
 create mode 100644 btif/co/bta_ag_co.cc
 create mode 100644 hci/include/hci_audio.h
 create mode 100644 hci/src/hci_audio.cc

diff --git a/system/bt/bta/ag/bta_ag_act.cc b/system/bt/bta/ag/bta_ag_act.cc
index eb989eb08..6bff6d50e 100644
--- a/system/bt/bta/ag/bta_ag_act.cc
+++ b/system/bt/bta/ag/bta_ag_act.cc
@@ -334,8 +334,10 @@ void bta_ag_rfc_fail(tBTA_AG_SCB* p_scb, UNUSED_ATTR const tBTA_AG_DATA& data) {
   p_scb->conn_handle = 0;
   p_scb->conn_service = 0;
   p_scb->peer_features = 0;
+#if (BTM_WBS_INCLUDED == TRUE)
   p_scb->peer_codecs = BTA_AG_CODEC_CVSD;
   p_scb->sco_codec = BTA_AG_CODEC_CVSD;
+#endif
   p_scb->role = 0;
   p_scb->svc_conn = false;
   p_scb->hsp_version = HSP_VERSION_1_2;
@@ -368,12 +370,14 @@ void bta_ag_rfc_close(tBTA_AG_SCB* p_scb,
   /* reinitialize stuff */
   p_scb->conn_service = 0;
   p_scb->peer_features = 0;
+#if (BTM_WBS_INCLUDED == TRUE)
   p_scb->peer_codecs = BTA_AG_CODEC_CVSD;
   p_scb->sco_codec = BTA_AG_CODEC_CVSD;
   /* Clear these flags upon SLC teardown */
   p_scb->codec_updated = false;
   p_scb->codec_fallback = false;
   p_scb->codec_msbc_settings = BTA_AG_SCO_MSBC_SETTINGS_T2;
+#endif
   p_scb->role = 0;
   p_scb->post_sco = BTA_AG_POST_SCO_NONE;
   p_scb->svc_conn = false;
@@ -389,7 +393,9 @@ void bta_ag_rfc_close(tBTA_AG_SCB* p_scb,
 
   /* stop timers */
   alarm_cancel(p_scb->ring_timer);
+#if (BTM_WBS_INCLUDED == TRUE)
   alarm_cancel(p_scb->codec_negotiation_timer);
+#endif
 
   close.hdr.handle = bta_ag_scb_to_idx(p_scb);
   close.hdr.app_id = p_scb->app_id;
@@ -778,7 +784,10 @@ void bta_ag_svc_conn_open(tBTA_AG_SCB* p_scb,
     evt.hdr.app_id = p_scb->app_id;
     evt.peer_feat = p_scb->peer_features;
     evt.bd_addr = p_scb->peer_addr;
+    bdcpy(evt.bd_addr, p_scb->peer_addr);
+#if (BTM_WBS_INCLUDED == TRUE)
     evt.peer_codec = p_scb->peer_codecs;
+#endif
 
     if ((p_scb->call_ind != BTA_AG_CALL_INACTIVE) ||
         (p_scb->callsetup_ind != BTA_AG_CALLSETUP_NONE)) {
@@ -805,6 +814,10 @@ void bta_ag_setcodec(tBTA_AG_SCB* p_scb, const tBTA_AG_DATA& data) {
   tBTA_AG_PEER_CODEC codec_type = data.api_setcodec.codec;
   tBTA_AG_VAL val = {};
   val.hdr.handle = bta_ag_scb_to_idx(p_scb);
+void bta_ag_setcodec(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data) {
+#if (BTM_WBS_INCLUDED == TRUE)
+  tBTA_AG_PEER_CODEC codec_type = p_data->api_setcodec.codec;
+  tBTA_AG_VAL val;
 
   /* Check if the requested codec type is valid */
   if ((codec_type != BTA_AG_CODEC_NONE) && (codec_type != BTA_AG_CODEC_CVSD) &&
@@ -832,6 +845,7 @@ void bta_ag_setcodec(tBTA_AG_SCB* p_scb, const tBTA_AG_DATA& data) {
   }
 
   (*bta_ag_cb.p_cback)(BTA_AG_WBS_EVT, (tBTA_AG*)&val);
+#endif
 }
 
 static void bta_ag_collision_timer_cback(void* data) {
diff --git a/system/bt/bta/ag/bta_ag_cfg.cc b/system/bt/bta/ag/bta_ag_cfg.cc
index abb71b421..bb143e4b3 100644
--- a/system/bt/bta/ag/bta_ag_cfg.cc
+++ b/system/bt/bta/ag/bta_ag_cfg.cc
@@ -48,10 +48,10 @@
 
 #ifndef BTA_AG_SCO_PKT_TYPES
 /* S1 packet type setting from HFP 1.5 spec */
-#define BTA_AG_SCO_PKT_TYPES /* BTM_SCO_LINK_ALL_PKT_MASK */     \
-  (BTM_SCO_LINK_ONLY_MASK | ESCO_PKT_TYPES_MASK_EV3 |            \
-   ESCO_PKT_TYPES_MASK_NO_3_EV3 | ESCO_PKT_TYPES_MASK_NO_2_EV5 | \
-   ESCO_PKT_TYPES_MASK_NO_3_EV5)
+#define BTA_AG_SCO_PKT_TYPES /* BTM_SCO_LINK_ALL_PKT_MASK */           \
+  (BTM_SCO_LINK_ONLY_MASK | BTM_SCO_PKT_TYPES_MASK_EV3 |               \
+   BTM_SCO_PKT_TYPES_MASK_NO_3_EV3 | BTM_SCO_PKT_TYPES_MASK_NO_2_EV5 | \
+   BTM_SCO_PKT_TYPES_MASK_NO_3_EV5)
 #endif
 
 #ifndef BTA_AG_BIND_INFO
diff --git a/system/bt/bta/ag/bta_ag_ci.cc b/system/bt/bta/ag/bta_ag_ci.cc
new file mode 100644
index 000000000..1fde9d84a
--- /dev/null
+++ b/system/bt/bta/ag/bta_ag_ci.cc
@@ -0,0 +1,88 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2003-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  This is the implementation file for audio gateway call-in functions.
+ *
+ ******************************************************************************/
+
+#include <string.h>
+
+#include "bt_common.h"
+#include "bta_ag_api.h"
+#include "bta_ag_ci.h"
+#include "bta_ag_int.h"
+#include "bta_api.h"
+
+/******************************************************************************
+ *
+ * Function         bta_ag_ci_rx_write
+ *
+ * Description      This function is called to send data to the AG when the AG
+ *                  is configured for AT command pass-through.  The function
+ *                  copies data to an event buffer and sends it.
+ *
+ * Returns          void
+ *
+ *****************************************************************************/
+void bta_ag_ci_rx_write(uint16_t handle, char* p_data, uint16_t len) {
+  uint16_t len_remaining = len;
+  char* p_data_area;
+
+  if (len > (RFCOMM_DATA_BUF_SIZE - sizeof(tBTA_AG_CI_RX_WRITE) - 1))
+    len = RFCOMM_DATA_BUF_SIZE - sizeof(tBTA_AG_CI_RX_WRITE) - 1;
+
+  while (len_remaining) {
+    if (len_remaining < len) len = len_remaining;
+
+    tBTA_AG_CI_RX_WRITE* p_buf =
+        (tBTA_AG_CI_RX_WRITE*)osi_malloc(sizeof(tBTA_AG_CI_RX_WRITE) + len + 1);
+    p_buf->hdr.event = BTA_AG_CI_RX_WRITE_EVT;
+    p_buf->hdr.layer_specific = handle;
+
+    p_data_area = (char*)(p_buf + 1); /* Point to data area after header */
+    strncpy(p_data_area, p_data, len);
+    p_data_area[len] = 0;
+
+    bta_sys_sendmsg(p_buf);
+
+    len_remaining -= len;
+    p_data += len;
+  }
+}
+
+/******************************************************************************
+ *
+ * Function         bta_ag_ci_slc_ready
+ *
+ * Description      This function is called to notify AG that SLC is up at
+ *                  the application. This funcion is only used when the app
+ *                  is running in pass-through mode.
+ *
+ * Returns          void
+ *
+ *****************************************************************************/
+void bta_ag_ci_slc_ready(uint16_t handle) {
+  tBTA_AG_DATA* p_buf = (tBTA_AG_DATA*)osi_malloc(sizeof(tBTA_AG_DATA));
+
+  p_buf->hdr.event = BTA_AG_CI_SLC_READY_EVT;
+  p_buf->hdr.layer_specific = handle;
+
+  bta_sys_sendmsg(p_buf);
+}
diff --git a/system/bt/bta/ag/bta_ag_cmd.cc b/system/bt/bta/ag/bta_ag_cmd.cc
index 248991570..de788c09d 100644
--- a/system/bt/bta/ag/bta_ag_cmd.cc
+++ b/system/bt/bta/ag/bta_ag_cmd.cc
@@ -441,6 +441,7 @@ static uint8_t bta_ag_parse_chld(UNUSED_ATTR tBTA_AG_SCB* p_scb, char* p_s) {
   return (retval);
 }
 
+#if (BTM_WBS_INCLUDED == TRUE)
 /*******************************************************************************
  *
  * Function         bta_ag_parse_bac
@@ -492,6 +493,7 @@ static tBTA_AG_PEER_CODEC bta_ag_parse_bac(tBTA_AG_SCB* p_scb, char* p_s,
 
   return (retval);
 }
+#endif
 
 /*******************************************************************************
  *
@@ -844,13 +846,17 @@ void bta_ag_at_hfp_cback(tBTA_AG_SCB* p_scb, uint16_t cmd, uint8_t arg_type,
   uint32_t i, ind_id;
   uint32_t bia_masked_out;
   if (p_arg == nullptr) {
+#if (BTM_WBS_INCLUDED == TRUE)
+  tBTA_AG_PEER_CODEC codec_type, codec_sent;
+#endif
+  if (p_arg == NULL) {
     APPL_TRACE_ERROR("%s: p_arg is null, send error and return", __func__);
     bta_ag_send_error(p_scb, BTA_AG_ERR_INV_CHAR_IN_TSTR);
     return;
   }
 
-  APPL_TRACE_DEBUG("%s: AT command %d, arg_type %d, int_arg %d, arg %s",
-                   __func__, cmd, arg_type, int_arg, p_arg);
+  APPL_TRACE_DEBUG("HFP AT cmd:%d arg_type:%d arg:%d arg:%s", cmd, arg_type,
+                   int_arg, p_arg);
 
   val.hdr.handle = bta_ag_scb_to_idx(p_scb);
   val.hdr.app_id = p_scb->app_id;
@@ -1205,6 +1211,7 @@ void bta_ag_at_hfp_cback(tBTA_AG_SCB* p_scb, uint16_t cmd, uint8_t arg_type,
       }
       break;
 
+#if (BTM_WBS_INCLUDED == TRUE)
     case BTA_AG_AT_BAC_EVT:
       bta_ag_send_ok(p_scb);
       p_scb->received_at_bac = true;
@@ -1241,8 +1248,7 @@ void bta_ag_at_hfp_cback(tBTA_AG_SCB* p_scb, uint16_t cmd, uint8_t arg_type,
       }
       break;
 
-    case BTA_AG_AT_BCS_EVT: {
-      tBTA_AG_PEER_CODEC codec_type, codec_sent;
+    case BTA_AG_AT_BCS_EVT:
       bta_ag_send_ok(p_scb);
       alarm_cancel(p_scb->codec_negotiation_timer);
 
@@ -1277,10 +1283,14 @@ void bta_ag_at_hfp_cback(tBTA_AG_SCB* p_scb, uint16_t cmd, uint8_t arg_type,
         bta_ag_send_error(p_scb, BTA_AG_ERR_OP_NOT_ALLOWED);
         break;
       }
+
+    case BTA_AG_LOCAL_EVT_BCC:
       bta_ag_send_ok(p_scb);
       bta_ag_sco_open(p_scb, tBTA_AG_DATA::kEmpty);
       break;
     }
+#endif
+
     default:
       bta_ag_send_error(p_scb, BTA_AG_ERR_OP_NOT_SUPPORTED);
       break;
@@ -1729,6 +1739,7 @@ void bta_ag_result(tBTA_AG_SCB* p_scb, const tBTA_AG_DATA& data) {
   }
 }
 
+#if (BTM_WBS_INCLUDED == TRUE)
 /*******************************************************************************
  *
  * Function         bta_ag_send_bcs
@@ -1766,6 +1777,7 @@ void bta_ag_send_bcs(tBTA_AG_SCB* p_scb) {
   APPL_TRACE_DEBUG("send +BCS codec is %d", codec_uuid);
   bta_ag_send_result(p_scb, BTA_AG_LOCAL_RES_BCS, nullptr, codec_uuid);
 }
+#endif
 
 /*******************************************************************************
  *
diff --git a/system/bt/bta/ag/bta_ag_int.h b/system/bt/bta/ag/bta_ag_int.h
index 63934506a..574733881 100644
--- a/system/bt/bta/ag/bta_ag_int.h
+++ b/system/bt/bta/ag/bta_ag_int.h
@@ -80,6 +80,8 @@ enum {
   BTA_AG_RING_TIMEOUT_EVT,
   BTA_AG_SVC_TIMEOUT_EVT,
   BTA_AG_COLLISION_EVT,
+  BTA_AG_CI_SCO_DATA_EVT,
+  BTA_AG_CI_SLC_READY_EVT,
   BTA_AG_MAX_EVT,
 };
 
@@ -97,9 +99,11 @@ enum {
 
 /* sco states */
 enum {
-  BTA_AG_SCO_SHUTDOWN_ST,   /* no sco listening, all sco connections closed */
-  BTA_AG_SCO_LISTEN_ST,     /* sco listening */
-  BTA_AG_SCO_CODEC_ST,      /* sco codec negotiation */
+  BTA_AG_SCO_SHUTDOWN_ST, /* no sco listening, all sco connections closed */
+  BTA_AG_SCO_LISTEN_ST,   /* sco listening */
+#if (BTM_WBS_INCLUDED == TRUE)
+  BTA_AG_SCO_CODEC_ST, /* sco codec negotiation */
+#endif
   BTA_AG_SCO_OPENING_ST,    /* sco connection opening */
   BTA_AG_SCO_OPEN_CL_ST,    /* opening sco connection being closed */
   BTA_AG_SCO_OPEN_XFER_ST,  /* opening sco connection being transferred */
@@ -155,7 +159,9 @@ union tBTA_AG_DATA {
   tBTA_AG_API_REGISTER api_register;
   tBTA_AG_API_OPEN api_open;
   tBTA_AG_API_RESULT api_result;
+#if (BTM_WBS_INCLUDED == TRUE)
   tBTA_AG_API_SETCODEC api_setcodec;
+#endif
   tBTA_AG_DISC_RESULT disc_result;
   tBTA_AG_RFC rfc;
   static const tBTA_AG_DATA kEmpty;
@@ -184,10 +190,12 @@ typedef struct {
   uint8_t scn;
 } tBTA_AG_PROFILE;
 
+#if (BTM_WBS_INCLUDED == TRUE)
 typedef enum {
   BTA_AG_SCO_MSBC_SETTINGS_T2 = 0, /* preferred/default when codec is mSBC */
   BTA_AG_SCO_MSBC_SETTINGS_T1,
 } tBTA_AG_SCO_MSBC_SETTINGS;
+#endif
 
 /* type for each service control block */
 struct tBTA_AG_SCB {
@@ -231,6 +239,7 @@ struct tBTA_AG_SCB {
   uint32_t bia_masked_out;  /* indicators HF does not want us to send */
   alarm_t* collision_timer;
   alarm_t* ring_timer;
+#if (BTM_WBS_INCLUDED == TRUE)
   alarm_t* codec_negotiation_timer;
   bool received_at_bac; /* indicate AT+BAC is received at least once */
   tBTA_AG_PEER_CODEC peer_codecs; /* codecs for eSCO supported by the peer */
@@ -241,6 +250,7 @@ struct tBTA_AG_SCB {
   bool codec_fallback; /* If sco nego fails for mSBC, fallback to CVSD */
   tBTA_AG_SCO_MSBC_SETTINGS
       codec_msbc_settings; /* settings to be used for the impending eSCO */
+#endif
 
   tBTA_AG_HF_IND
       peer_hf_indicators[BTA_AG_MAX_NUM_PEER_HF_IND]; /* Peer supported
@@ -253,11 +263,12 @@ struct tBTA_AG_SCB {
 /* type for sco data */
 typedef struct {
   tBTM_ESCO_CONN_REQ_EVT_DATA conn_data; /* SCO data for pending conn request */
-  tBTA_AG_SCB* p_curr_scb;  /* SCB associated with SCO connection */
-  tBTA_AG_SCB* p_xfer_scb;  /* SCB associated with SCO transfer */
-  uint16_t cur_idx;         /* SCO handle */
-  uint8_t state;            /* SCO state variable */
-  bool is_local;            /* SCO connection initiated locally or remotely */
+  tBTA_AG_SCB* p_curr_scb; /* SCB associated with SCO connection */
+  tBTA_AG_SCB* p_xfer_scb; /* SCB associated with SCO transfer */
+  uint16_t cur_idx;        /* SCO handle */
+  uint8_t state;           /* SCO state variable */
+  bool param_updated;      /* if params were updated to non-default */
+  tBTM_ESCO_PARAMS params; /* ESCO parameters */
 } tBTA_AG_SCO_CB;
 
 /* type for AG control block */
@@ -385,11 +396,46 @@ extern void bta_ag_handle_collision(tBTA_AG_SCB* p_scb,
                                     const tBTA_AG_DATA& data);
 
 /* Internal utility functions */
+extern void bta_ag_register(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_deregister(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_start_dereg(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_start_close(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_start_open(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_disc_int_res(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_disc_acp_res(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_disc_fail(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_open_fail(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_rfc_fail(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_rfc_close(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_rfc_open(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_rfc_acp_open(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_rfc_data(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_sco_listen(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_sco_open(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_sco_close(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+#if (BTM_WBS_INCLUDED == TRUE)
 extern void bta_ag_sco_codec_nego(tBTA_AG_SCB* p_scb, bool result);
 extern void bta_ag_codec_negotiate(tBTA_AG_SCB* p_scb);
 extern void bta_ag_send_bcs(tBTA_AG_SCB* p_scb);
 extern void bta_ag_set_sco_allowed(bool value);
 extern const RawAddress& bta_ag_get_active_device();
 extern void bta_clear_active_device();
+#endif
+extern void bta_ag_sco_shutdown(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_sco_conn_open(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_sco_conn_close(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_post_sco_open(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_post_sco_close(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_svc_conn_open(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_result(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_setcodec(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+#if (BTM_WBS_INCLUDED == TRUE)
+extern void bta_ag_send_bcs(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+#endif
+extern void bta_ag_send_ring(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_ci_sco_data(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_set_esco_param(bool set_reset, tBTM_ESCO_PARAMS* param);
+extern void bta_ag_ci_rx_data(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
+extern void bta_ag_rcvd_slc_ready(tBTA_AG_SCB* p_scb, tBTA_AG_DATA* p_data);
 
 #endif /* BTA_AG_INT_H */
diff --git a/system/bt/bta/ag/bta_ag_main.cc b/system/bt/bta/ag/bta_ag_main.cc
index 996aa258b..b4f4a8247 100644
--- a/system/bt/bta/ag/bta_ag_main.cc
+++ b/system/bt/bta/ag/bta_ag_main.cc
@@ -69,6 +69,9 @@ enum {
   BTA_AG_SETCODEC,
   BTA_AG_SEND_RING,
   BTA_AG_HANDLE_COLLISION,
+  BTA_AG_CI_SCO_DATA,
+  BTA_AG_CI_RX_DATA,
+  BTA_AG_RCVD_SLC_READY,
   BTA_AG_NUM_ACTIONS
 };
 
@@ -167,6 +170,25 @@ const tBTA_AG_ACTION bta_ag_action[] = {
 static_assert(sizeof(bta_ag_action) / sizeof(tBTA_AG_ACTION) ==
                   BTA_AG_NUM_ACTIONS,
               "bta_ag_action must handle all actions");
+    bta_ag_register,       bta_ag_deregister,
+    bta_ag_start_open,     bta_ag_rfc_do_open,
+    bta_ag_rfc_do_close,   bta_ag_start_dereg,
+    bta_ag_start_close,    bta_ag_rfc_open,
+    bta_ag_open_fail,      bta_ag_rfc_acp_open,
+    bta_ag_rfc_close,      bta_ag_rfc_fail,
+    bta_ag_rfc_data,       bta_ag_disc_int_res,
+    bta_ag_disc_fail,      bta_ag_disc_acp_res,
+    bta_ag_free_db,        bta_ag_sco_conn_open,
+    bta_ag_sco_conn_close, bta_ag_sco_listen,
+    bta_ag_sco_open,       bta_ag_sco_close,
+    bta_ag_sco_shutdown,   bta_ag_post_sco_open,
+    bta_ag_post_sco_close, bta_ag_svc_conn_open,
+    bta_ag_result,         bta_ag_setcodec,
+    bta_ag_send_ring,      bta_ag_ci_sco_data,
+    bta_ag_ci_rx_data,     bta_ag_ci_sco_open_continue,
+    bta_ag_rcvd_slc_ready};
+    bta_ag_setcodec,       bta_ag_send_ring,     bta_ag_ci_sco_data,
+    bta_ag_ci_rx_data,     bta_ag_rcvd_slc_ready};
 
 /* state table information */
 #define BTA_AG_ACTIONS 2    /* number of actions */
@@ -197,6 +219,8 @@ const uint8_t bta_ag_st_init[][BTA_AG_NUM_COLS] = {
     /* RING_TOUT_EVT */ {BTA_AG_IGNORE, BTA_AG_IGNORE, BTA_AG_INIT_ST},
     /* SVC_TOUT_EVT */ {BTA_AG_IGNORE, BTA_AG_IGNORE, BTA_AG_INIT_ST},
     /* COLLISION_EVT */ {BTA_AG_IGNORE, BTA_AG_IGNORE, BTA_AG_INIT_ST}};
+    /* CI_SCO_DATA_EVT */ {BTA_AG_IGNORE, BTA_AG_IGNORE, BTA_AG_INIT_ST},
+    /* CI_SLC_READY_EVT */ {BTA_AG_IGNORE, BTA_AG_IGNORE, BTA_AG_INIT_ST}};
 
 /* state table for opening state */
 const uint8_t bta_ag_st_opening[][BTA_AG_NUM_COLS] = {
@@ -226,6 +250,8 @@ const uint8_t bta_ag_st_opening[][BTA_AG_NUM_COLS] = {
     /* SVC_TOUT_EVT */ {BTA_AG_IGNORE, BTA_AG_IGNORE, BTA_AG_OPENING_ST},
     /* COLLISION_EVT */
     {BTA_AG_HANDLE_COLLISION, BTA_AG_IGNORE, BTA_AG_INIT_ST}};
+    /* CI_SCO_DATA_EVT */ {BTA_AG_IGNORE, BTA_AG_IGNORE, BTA_AG_OPENING_ST},
+    /* CI_SLC_READY_EVT */ {BTA_AG_IGNORE, BTA_AG_IGNORE, BTA_AG_OPENING_ST}};
 
 /* state table for open state */
 const uint8_t bta_ag_st_open[][BTA_AG_NUM_COLS] = {
@@ -254,6 +280,9 @@ const uint8_t bta_ag_st_open[][BTA_AG_NUM_COLS] = {
     /* RING_TOUT_EVT */ {BTA_AG_SEND_RING, BTA_AG_IGNORE, BTA_AG_OPEN_ST},
     /* SVC_TOUT_EVT */ {BTA_AG_START_CLOSE, BTA_AG_IGNORE, BTA_AG_CLOSING_ST},
     /* COLLISION_EVT */ {BTA_AG_IGNORE, BTA_AG_IGNORE, BTA_AG_OPEN_ST}};
+    /* CI_SCO_DATA_EVT */ {BTA_AG_CI_SCO_DATA, BTA_AG_IGNORE, BTA_AG_OPEN_ST},
+    /* CI_SLC_READY_EVT */ {BTA_AG_RCVD_SLC_READY, BTA_AG_IGNORE,
+                            BTA_AG_OPEN_ST}};
 
 /* state table for closing state */
 const uint8_t bta_ag_st_closing[][BTA_AG_NUM_COLS] = {
@@ -292,6 +321,8 @@ static_assert(sizeof(bta_ag_st_open) / BTA_AG_NUM_COLS == BTA_AG_NUM_EVENTS,
               "bta_ag_st_open must handle all AG events");
 static_assert(sizeof(bta_ag_st_closing) / BTA_AG_NUM_COLS == BTA_AG_NUM_EVENTS,
               "bta_ag_st_closing must handle all AG events");
+    /* CI_SCO_DATA_EVT */ {BTA_AG_IGNORE, BTA_AG_IGNORE, BTA_AG_CLOSING_ST},
+    /* CI_SLC_READY_EVT */ {BTA_AG_IGNORE, BTA_AG_IGNORE, BTA_AG_CLOSING_ST}};
 
 /* type for state table */
 typedef const uint8_t (*tBTA_AG_ST_TBL)[BTA_AG_NUM_COLS];
@@ -328,6 +359,7 @@ static tBTA_AG_SCB* bta_ag_scb_alloc(void) {
       p_scb->in_use = true;
       p_scb->sco_idx = BTM_INVALID_SCO_INDEX;
       p_scb->received_at_bac = false;
+#if (BTM_WBS_INCLUDED == TRUE)
       p_scb->codec_updated = false;
       p_scb->codec_fallback = false;
       p_scb->peer_codecs = BTA_AG_CODEC_CVSD;
@@ -335,13 +367,16 @@ static tBTA_AG_SCB* bta_ag_scb_alloc(void) {
       p_scb->peer_version = HFP_HSP_VERSION_UNKNOWN;
       p_scb->hsp_version = HSP_VERSION_1_2;
       p_scb->peer_sdp_features = 0;
+#endif
       /* set up timers */
       p_scb->ring_timer = alarm_new("bta_ag.scb_ring_timer");
       p_scb->collision_timer = alarm_new("bta_ag.scb_collision_timer");
+#if (BTM_WBS_INCLUDED == TRUE)
       p_scb->codec_negotiation_timer =
           alarm_new("bta_ag.scb_codec_negotiation_timer");
       /* set eSCO mSBC setting to T2 as the preferred */
       p_scb->codec_msbc_settings = BTA_AG_SCO_MSBC_SETTINGS_T2;
+#endif
       APPL_TRACE_DEBUG("bta_ag_scb_alloc %d", bta_ag_scb_to_idx(p_scb));
       break;
     }
@@ -351,6 +386,8 @@ static tBTA_AG_SCB* bta_ag_scb_alloc(void) {
     /* out of scbs */
     p_scb = nullptr;
     APPL_TRACE_WARNING("%s: Out of scbs", __func__);
+    p_scb = NULL;
+    APPL_TRACE_WARNING("Out of ag scbs");
   }
   return p_scb;
 }
@@ -373,7 +410,9 @@ void bta_ag_scb_dealloc(tBTA_AG_SCB* p_scb) {
 
   /* stop and free timers */
   alarm_free(p_scb->ring_timer);
+#if (BTM_WBS_INCLUDED == TRUE)
   alarm_free(p_scb->codec_negotiation_timer);
+#endif
   alarm_free(p_scb->collision_timer);
 
   /* initialize control block */
@@ -590,6 +629,12 @@ void bta_ag_api_enable(tBTA_AG_CBACK* p_cback) {
     alarm_free(scb.codec_negotiation_timer);
     alarm_free(scb.collision_timer);
     scb = {};
+  for (size_t i = 0; i < BTA_AG_NUM_SCB; i++) {
+    alarm_free(bta_ag_cb.scb[i].ring_timer);
+#if (BTM_WBS_INCLUDED == TRUE)
+    alarm_free(bta_ag_cb.scb[i].codec_negotiation_timer);
+#endif
+    alarm_free(bta_ag_cb.scb[i].collision_timer);
   }
 
   /* store callback function */
@@ -735,16 +780,32 @@ void bta_ag_sm_execute(tBTA_AG_SCB* p_scb, uint16_t event,
   uint16_t previous_event = event;
   uint8_t previous_state = p_scb->state;
 
+#if (BTA_AG_DEBUG == TRUE)
+  uint16_t in_event = event;
+  uint8_t in_state = p_scb->state;
+
   APPL_TRACE_EVENT(
       "%s: handle=0x%04x, bd_addr=%s, state=%s(0x%02x), "
       "event=%s(0x%04x), result=%s(0x%02x)",
       __func__, bta_ag_scb_to_idx(p_scb), p_scb->peer_addr.ToString().c_str(),
       bta_ag_state_str(p_scb->state), p_scb->state, bta_ag_evt_str(event),
       event, bta_ag_res_str(data.api_result.result), data.api_result.result);
+  /* Ignore displaying of AT results when not connected (Ignored in state
+   * machine) */
+  if (in_event != BTA_AG_API_RESULT_EVT || p_scb->state == BTA_AG_OPEN_ST) {
+    APPL_TRACE_EVENT("AG evt (hdl 0x%04x): State %d (%s), Event 0x%04x (%s)",
+                     bta_ag_scb_to_idx(p_scb), p_scb->state,
+                     bta_ag_state_str(p_scb->state), event,
+                     bta_ag_evt_str(event, p_data->api_result.result));
+  }
+#else
+  APPL_TRACE_EVENT("AG evt (hdl 0x%04x): State %d, Event 0x%04x",
+                   bta_ag_scb_to_idx(p_scb), p_scb->state, event);
+#endif
 
   event &= 0x00FF;
   if (event >= (BTA_AG_MAX_EVT & 0x00FF)) {
-    APPL_TRACE_ERROR("%s: event out of range, ignored", __func__);
+    APPL_TRACE_ERROR("AG evt out of range, ignoring...");
     return;
   }
 
@@ -772,6 +833,11 @@ void bta_ag_sm_execute(tBTA_AG_SCB* p_scb, uint16_t event,
         bta_ag_state_str(p_scb->state), p_scb->state,
         bta_ag_evt_str(previous_event), previous_event,
         bta_ag_res_str(data.api_result.result), data.api_result.result);
+#if (BTA_AG_DEBUG == TRUE)
+  if (p_scb->state != in_state) {
+    APPL_TRACE_EVENT("BTA AG State Change: [%s] -> [%s] after Event [%s]",
+                     bta_ag_state_str(in_state), bta_ag_state_str(p_scb->state),
+                     bta_ag_evt_str(in_event, p_data->api_result.result));
   }
 }
 
@@ -797,6 +863,24 @@ bool bta_ag_hdl_event(BT_HDR* p_msg) {
     case BTA_AG_SVC_TIMEOUT_EVT:
       bta_ag_sm_execute_by_handle(p_msg->layer_specific, p_msg->event,
                                   tBTA_AG_DATA::kEmpty);
+    /* handle enable event */
+    case BTA_AG_API_ENABLE_EVT:
+      bta_ag_api_enable((tBTA_AG_DATA*)p_msg);
+      break;
+
+    /* handle disable event */
+    case BTA_AG_API_DISABLE_EVT:
+      bta_ag_api_disable((tBTA_AG_DATA*)p_msg);
+      break;
+
+    /* handle register event */
+    case BTA_AG_API_REGISTER_EVT:
+      bta_ag_api_register((tBTA_AG_DATA*)p_msg);
+      break;
+
+    /* handle result event */
+    case BTA_AG_API_RESULT_EVT:
+      bta_ag_api_result((tBTA_AG_DATA*)p_msg);
       break;
     default:
       LOG(FATAL) << __func__ << ": bad event " << p_msg->event
@@ -805,3 +889,121 @@ bool bta_ag_hdl_event(BT_HDR* p_msg) {
   }
   return true;
 }
+
+#if (BTA_AG_DEBUG == TRUE)
+static char* bta_ag_evt_str(uint16_t event, tBTA_AG_RES result) {
+  switch (event) {
+    case BTA_AG_API_REGISTER_EVT:
+      return "Register Request";
+    case BTA_AG_API_DEREGISTER_EVT:
+      return "Deregister Request";
+    case BTA_AG_API_OPEN_EVT:
+      return "Open SLC Request";
+    case BTA_AG_API_CLOSE_EVT:
+      return "Close SLC Request";
+    case BTA_AG_API_AUDIO_OPEN_EVT:
+      return "Open Audio Request";
+    case BTA_AG_API_AUDIO_CLOSE_EVT:
+      return "Close Audio Request";
+    case BTA_AG_API_RESULT_EVT:
+      switch (result) {
+        case BTA_AG_SPK_RES:
+          return ("AT Result  BTA_AG_SPK_RES");
+        case BTA_AG_MIC_RES:
+          return ("AT Result  BTA_AG_MIC_RES");
+        case BTA_AG_INBAND_RING_RES:
+          return ("AT Result  BTA_AG_INBAND_RING_RES");
+        case BTA_AG_CIND_RES:
+          return ("AT Result  BTA_AG_CIND_RES");
+        case BTA_AG_BINP_RES:
+          return ("AT Result  BTA_AG_BINP_RES");
+        case BTA_AG_IND_RES:
+          return ("AT Result  BTA_AG_IND_RES");
+        case BTA_AG_BVRA_RES:
+          return ("AT Result  BTA_AG_BVRA_RES");
+        case BTA_AG_CNUM_RES:
+          return ("AT Result  BTA_AG_CNUM_RES");
+        case BTA_AG_BTRH_RES:
+          return ("AT Result  BTA_AG_BTRH_RES");
+        case BTA_AG_CLCC_RES:
+          return ("AT Result  BTA_AG_CLCC_RES");
+        case BTA_AG_COPS_RES:
+          return ("AT Result  BTA_AG_COPS_RES");
+        case BTA_AG_IN_CALL_RES:
+          return ("AT Result  BTA_AG_IN_CALL_RES");
+        case BTA_AG_IN_CALL_CONN_RES:
+          return ("AT Result  BTA_AG_IN_CALL_CONN_RES");
+        case BTA_AG_CALL_WAIT_RES:
+          return ("AT Result  BTA_AG_CALL_WAIT_RES");
+        case BTA_AG_OUT_CALL_ORIG_RES:
+          return ("AT Result  BTA_AG_OUT_CALL_ORIG_RES");
+        case BTA_AG_OUT_CALL_ALERT_RES:
+          return ("AT Result  BTA_AG_OUT_CALL_ALERT_RES");
+        case BTA_AG_OUT_CALL_CONN_RES:
+          return ("AT Result  BTA_AG_OUT_CALL_CONN_RES");
+        case BTA_AG_CALL_CANCEL_RES:
+          return ("AT Result  BTA_AG_CALL_CANCEL_RES");
+        case BTA_AG_END_CALL_RES:
+          return ("AT Result  BTA_AG_END_CALL_RES");
+        case BTA_AG_UNAT_RES:
+          return ("AT Result  BTA_AG_UNAT_RES");
+        default:
+          return ("Unknown AG Result");
+      }
+    case BTA_AG_API_SETCODEC_EVT:
+      return "Set Codec Request";
+    case BTA_AG_RFC_OPEN_EVT:
+      return "RFC Opened";
+    case BTA_AG_RFC_CLOSE_EVT:
+      return "RFC Closed";
+    case BTA_AG_RFC_SRV_CLOSE_EVT:
+      return "RFC SRV Closed";
+    case BTA_AG_RFC_DATA_EVT:
+      return "RFC Data";
+    case BTA_AG_SCO_OPEN_EVT:
+      return "Audio Opened";
+    case BTA_AG_SCO_CLOSE_EVT:
+      return "Audio Closed";
+    case BTA_AG_DISC_ACP_RES_EVT:
+      return "Discovery ACP Result";
+    case BTA_AG_DISC_INT_RES_EVT:
+      return "Discovery INT Result";
+    case BTA_AG_DISC_OK_EVT:
+      return "Discovery OK";
+    case BTA_AG_DISC_FAIL_EVT:
+      return "Discovery Failed";
+    case BTA_AG_CI_RX_WRITE_EVT:
+      return "CI RX Write";
+    case BTA_AG_RING_TIMEOUT_EVT:
+      return "Ring Timeout";
+    case BTA_AG_SVC_TIMEOUT_EVT:
+      return "Service Timeout";
+    case BTA_AG_API_ENABLE_EVT:
+      return "Enable AG";
+    case BTA_AG_API_DISABLE_EVT:
+      return "Disable AG";
+    case BTA_AG_CI_SCO_DATA_EVT:
+      return "SCO data Callin";
+    case BTA_AG_CI_SLC_READY_EVT:
+      return "SLC Ready Callin";
+    default:
+      return "Unknown AG Event";
+  }
+}
+
+static char* bta_ag_state_str(uint8_t state) {
+  switch (state) {
+    case BTA_AG_INIT_ST:
+      return "Initial";
+    case BTA_AG_OPENING_ST:
+      return "Opening";
+    case BTA_AG_OPEN_ST:
+      return "Open";
+    case BTA_AG_CLOSING_ST:
+      return "Closing";
+    default:
+      return "Unknown AG State";
+  }
+}
+
+#endif
diff --git a/system/bt/bta/ag/bta_ag_sco.cc b/system/bt/bta/ag/bta_ag_sco.cc
index 94825ea4c..65487bacc 100644
--- a/system/bt/bta/ag/bta_ag_sco.cc
+++ b/system/bt/bta/ag/bta_ag_sco.cc
@@ -24,13 +24,17 @@
 
 #include <cstddef>
 
-#include "bt_common.h"
 #include "bta_ag_api.h"
 #include "bta_ag_int.h"
 #include "bta_api.h"
+#include "bta_ag_co.h"
+#include "bta_api.h"
+#if (BTM_SCO_HCI_INCLUDED == TRUE)
+#include "bta_dm_co.h"
+#endif
+#include "bt_common.h"
+#include "bta_ag_int.h"
 #include "btm_api.h"
-#include "device/include/controller.h"
-#include "device/include/esco_parameters.h"
 #include "osi/include/osi.h"
 #include "utl.h"
 
@@ -41,14 +45,26 @@
 
 static bool sco_allowed = true;
 static RawAddress active_device_addr = {};
+extern fixed_queue_t* btu_bta_alarm_queue;
+
+#if (BTA_AG_SCO_DEBUG == TRUE)
+static char* bta_ag_sco_evt_str(uint8_t event);
+static char* bta_ag_sco_state_str(uint8_t state);
+#endif
+
+#define BTA_AG_NO_EDR_ESCO                                             \
+  (BTM_SCO_PKT_TYPES_MASK_NO_2_EV3 | BTM_SCO_PKT_TYPES_MASK_NO_3_EV3 | \
+   BTM_SCO_PKT_TYPES_MASK_NO_2_EV5 | BTM_SCO_PKT_TYPES_MASK_NO_3_EV5)
 
 /* sco events */
 enum {
-  BTA_AG_SCO_LISTEN_E,       /* listen request */
-  BTA_AG_SCO_OPEN_E,         /* open request */
-  BTA_AG_SCO_XFER_E,         /* transfer request */
+  BTA_AG_SCO_LISTEN_E, /* listen request */
+  BTA_AG_SCO_OPEN_E,   /* open request */
+  BTA_AG_SCO_XFER_E,   /* transfer request */
+#if (BTM_WBS_INCLUDED == TRUE)
   BTA_AG_SCO_CN_DONE_E, /* codec negotiation done */
   BTA_AG_SCO_REOPEN_E,  /* Retry with other codec when failed */
+#endif
   BTA_AG_SCO_CLOSE_E,      /* close request */
   BTA_AG_SCO_SHUTDOWN_E,   /* shutdown request */
   BTA_AG_SCO_CONN_OPEN_E,  /* sco open */
@@ -105,6 +121,63 @@ bool bta_ag_sco_is_active_device(const RawAddress& bd_addr) {
 }
 
 static void bta_ag_create_pending_sco(tBTA_AG_SCB* p_scb, bool is_local);
+#if (BTM_WBS_INCLUDED == TRUE)
+#define BTA_AG_NUM_CODECS 3
+#define BTA_AG_ESCO_SETTING_IDX_CVSD 0 /* eSCO setting for CVSD */
+#define BTA_AG_ESCO_SETTING_IDX_T1 1   /* eSCO setting for mSBC T1 */
+#define BTA_AG_ESCO_SETTING_IDX_T2 2   /* eSCO setting for mSBC T2 */
+
+static const tBTM_ESCO_PARAMS bta_ag_esco_params[BTA_AG_NUM_CODECS] = {
+    /* CVSD */
+    {
+        BTM_64KBITS_RATE,       /* TX Bandwidth (64 kbits/sec)              */
+        BTM_64KBITS_RATE,       /* RX Bandwidth (64 kbits/sec)              */
+        0x000c,                 /* 12 ms (HS/HF can use EV3, 2-EV3, 3-EV3)  */
+        BTM_VOICE_SETTING_CVSD, /* Inp Linear, Air CVSD, 2s Comp, 16bit     */
+        (BTM_SCO_PKT_TYPES_MASK_HV1 + /* Packet Types */
+         BTM_SCO_PKT_TYPES_MASK_HV2 + BTM_SCO_PKT_TYPES_MASK_HV3 +
+         BTM_SCO_PKT_TYPES_MASK_EV3 + BTM_SCO_PKT_TYPES_MASK_EV4 +
+         BTM_SCO_PKT_TYPES_MASK_EV5 + BTM_SCO_PKT_TYPES_MASK_NO_2_EV5 +
+         BTM_SCO_PKT_TYPES_MASK_NO_3_EV5),
+        BTM_ESCO_RETRANS_QUALITY /* Retransmission effort                    */
+    },
+    /* mSBC  T1 */
+    {
+        BTM_64KBITS_RATE,        /* TX Bandwidth (64 kbits/sec), 8000        */
+        BTM_64KBITS_RATE,        /* RX Bandwidth (64 kbits/sec), 8000        */
+        8,                       /* 8 ms                                     */
+        BTM_VOICE_SETTING_TRANS, /* Inp Linear, Transparent, 2s Comp, 16bit  */
+        (BTM_SCO_PKT_TYPES_MASK_EV3 | /* Packet Types : EV3 + NO_2_EV3 */
+         BTM_SCO_PKT_TYPES_MASK_NO_3_EV3 | BTM_SCO_PKT_TYPES_MASK_NO_2_EV5 |
+         BTM_SCO_PKT_TYPES_MASK_NO_3_EV5 | BTM_SCO_PKT_TYPES_MASK_NO_2_EV3),
+        BTM_ESCO_RETRANS_QUALITY /* Retransmission effort */
+    },
+    /* mSBC T2*/
+    {
+        BTM_64KBITS_RATE,        /* TX Bandwidth (64 kbits/sec), 8000        */
+        BTM_64KBITS_RATE,        /* RX Bandwidth (64 kbits/sec), 8000        */
+        13,                      /* 13 ms                                    */
+        BTM_VOICE_SETTING_TRANS, /* Inp Linear, Transparent, 2s Comp, 16bit  */
+        (BTM_SCO_PKT_TYPES_MASK_EV3 | /* Packet Types : EV3 + 2-EV3 */
+         BTM_SCO_PKT_TYPES_MASK_NO_3_EV3 | BTM_SCO_PKT_TYPES_MASK_NO_2_EV5 |
+         BTM_SCO_PKT_TYPES_MASK_NO_3_EV5),
+        BTM_ESCO_RETRANS_QUALITY /* Retransmission effort */
+    }};
+#else
+/* WBS not included, CVSD by default */
+static const tBTM_ESCO_PARAMS bta_ag_esco_params = {
+    BTM_64KBITS_RATE,             /* TX Bandwidth (64 kbits/sec)              */
+    BTM_64KBITS_RATE,             /* RX Bandwidth (64 kbits/sec)              */
+    0x000a,                       /* 10 ms (HS/HF can use EV3, 2-EV3, 3-EV3)  */
+    0x0060,                       /* Inp Linear, Air CVSD, 2s Comp, 16bit     */
+    (BTM_SCO_PKT_TYPES_MASK_HV1 + /* Packet Types                             */
+     BTM_SCO_PKT_TYPES_MASK_HV2 + BTM_SCO_PKT_TYPES_MASK_HV3 +
+     BTM_SCO_PKT_TYPES_MASK_EV3 + BTM_SCO_PKT_TYPES_MASK_EV4 +
+     BTM_SCO_PKT_TYPES_MASK_EV5 + BTM_SCO_PKT_TYPES_MASK_NO_2_EV5 +
+     BTM_SCO_PKT_TYPES_MASK_NO_3_EV5),
+    BTM_ESCO_RETRANS_POWER /* Retransmission effort                      */
+};
+#endif
 
 /*******************************************************************************
  *
@@ -183,19 +256,24 @@ static void bta_ag_sco_disc_cback(uint16_t sco_idx) {
   }
 
   if (handle != 0) {
+#if (BTM_SCO_HCI_INCLUDED == TRUE)
+    tBTM_STATUS status = BTM_ConfigScoPath(BTM_SCO_ROUTE_PCM, NULL, NULL, true);
+    APPL_TRACE_DEBUG("bta_ag_sco_disc_cback sco close config status = %d",
+                     status);
+    /* SCO clean up here */
+    bta_dm_sco_co_close();
+#endif
 
+#if (BTM_WBS_INCLUDED == TRUE)
     /* Restore settings */
     if (bta_ag_cb.sco.p_curr_scb->inuse_codec == BTA_AG_CODEC_MSBC) {
-      /* Bypass vendor specific and voice settings if enhanced eSCO supported */
-      if (!(controller_get_interface()
-                ->supports_enhanced_setup_synchronous_connection())) {
-        BTM_WriteVoiceSettings(BTM_VOICE_SETTING_CVSD);
-      }
+      /* set_sco_codec(BTM_SCO_CODEC_NONE); we should get a close */
+      BTM_WriteVoiceSettings(BTM_VOICE_SETTING_CVSD);
 
-      /* If SCO open was initiated by AG and failed for mSBC T2, try mSBC T1
-       * 'Safe setting' first. If T1 also fails, try CVSD */
+      /* If SCO open was initiated by AG and failed for mSBC, then attempt
+      mSBC with T1 settings i.e. 'Safe Settings'. If this fails, then switch to
+      CVSD */
       if (bta_ag_sco_is_opening(bta_ag_cb.sco.p_curr_scb)) {
-        bta_ag_cb.sco.p_curr_scb->state = BTA_AG_SCO_CODEC_ST;
         if (bta_ag_cb.sco.p_curr_scb->codec_msbc_settings ==
             BTA_AG_SCO_MSBC_SETTINGS_T2) {
           APPL_TRACE_WARNING(
@@ -206,6 +284,11 @@ static void bta_ag_sco_disc_cback(uint16_t sco_idx) {
         } else {
           APPL_TRACE_WARNING(
               "%s: eSCO/SCO failed to open, falling back to CVSD", __func__);
+          APPL_TRACE_DEBUG("Fallback to mSBC T1 settings");
+          bta_ag_cb.sco.p_curr_scb->codec_msbc_settings =
+              BTA_AG_SCO_MSBC_SETTINGS_T1;
+        } else {
+          APPL_TRACE_DEBUG("Fallback to CVSD settings");
           bta_ag_cb.sco.p_curr_scb->codec_fallback = true;
         }
       }
@@ -215,6 +298,7 @@ static void bta_ag_sco_disc_cback(uint16_t sco_idx) {
     }
 
     bta_ag_cb.sco.p_curr_scb->inuse_codec = BTA_AG_CODEC_NONE;
+#endif
 
     do_in_bta_thread(FROM_HERE,
                      base::Bind(&bta_ag_sm_execute_by_handle, handle,
@@ -231,6 +315,22 @@ static void bta_ag_sco_disc_cback(uint16_t sco_idx) {
     }
   }
 }
+#if (BTM_SCO_HCI_INCLUDED == TRUE)
+/*******************************************************************************
+ *
+ * Function         bta_ag_sco_read_cback
+ *
+ * Description      Callback function is the callback function for incoming
+ *                  SCO data over HCI.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void bta_ag_sco_read_cback(uint16_t sco_inx, BT_HDR* p_data,
+                                  tBTM_SCO_DATA_FLAG status) {
+  if (status != BTM_SCO_DATA_CORRECT) {
+    APPL_TRACE_DEBUG("bta_ag_sco_read_cback: status(%d)", status);
+  }
 
 /*******************************************************************************
  *
@@ -240,26 +340,33 @@ static void bta_ag_sco_disc_cback(uint16_t sco_idx) {
  *                  If only_active is true, then SCO is only removed if
  *                  connected
  *
- * Returns          bool   - true if SCO removal was started
+ * Returns          bool   - true if Sco removal was started
  *
  ******************************************************************************/
 static bool bta_ag_remove_sco(tBTA_AG_SCB* p_scb, bool only_active) {
+  bool removed_started = false;
+  tBTM_STATUS status;
+
   if (p_scb->sco_idx != BTM_INVALID_SCO_INDEX) {
     if (!only_active || p_scb->sco_idx == bta_ag_cb.sco.cur_idx) {
-      tBTM_STATUS status = BTM_RemoveSco(p_scb->sco_idx);
-      APPL_TRACE_DEBUG("%s: SCO index 0x%04x, status %d", __func__,
-                       p_scb->sco_idx, status);
+      status = BTM_RemoveSco(p_scb->sco_idx);
+
+      APPL_TRACE_DEBUG("ag remove sco: inx 0x%04x, status:0x%x", p_scb->sco_idx,
+                       status);
+
       if (status == BTM_CMD_STARTED) {
-        /* SCO is connected; set current control block */
+        /* Sco is connected; set current control block */
         bta_ag_cb.sco.p_curr_scb = p_scb;
-        return true;
-      } else if ((status == BTM_SUCCESS) || (status == BTM_UNKNOWN_ADDR)) {
-        /* If no connection reset the SCO handle */
+
+        removed_started = true;
+      }
+      /* If no connection reset the sco handle */
+      else if ((status == BTM_SUCCESS) || (status == BTM_UNKNOWN_ADDR)) {
         p_scb->sco_idx = BTM_INVALID_SCO_INDEX;
       }
     }
   }
-  return false;
+  return removed_started;
 }
 
 /*******************************************************************************
@@ -285,15 +392,16 @@ static void bta_ag_esco_connreq_cback(tBTM_ESCO_EVT event,
 
       /* If no other SCO active, allow this one */
       if (!bta_ag_cb.sco.p_curr_scb) {
-        APPL_TRACE_EVENT("%s: Accept Conn Request (sco_inx 0x%04x)", __func__,
-                         sco_inx);
+        APPL_TRACE_EVENT(
+            "bta_ag_esco_connreq_cback: Accept Conn Request (sco_inx 0x%04x)",
+            sco_inx);
         bta_ag_sco_conn_rsp(p_scb, &p_data->conn_evt);
 
         bta_ag_cb.sco.state = BTA_AG_SCO_OPENING_ST;
         bta_ag_cb.sco.p_curr_scb = p_scb;
         bta_ag_cb.sco.cur_idx = p_scb->sco_idx;
-      } else {
-        /* Begin a transfer: Close current SCO before responding */
+      } else /* Begin a transfer: Close current SCO before responding */
+      {
         APPL_TRACE_DEBUG("bta_ag_esco_connreq_cback: Begin XFER");
         bta_ag_cb.sco.p_xfer_scb = p_scb;
         bta_ag_cb.sco.conn_data = p_data->conn_evt;
@@ -304,6 +412,10 @@ static void bta_ag_esco_connreq_cback(tBTM_ESCO_EVT event,
               "%s: Nothing to remove,so accept Conn Request(sco_inx 0x%04x)",
               __func__, sco_inx);
           bta_ag_cb.sco.p_xfer_scb = nullptr;
+              "bta_ag_esco_connreq_cback: Nothing to remove so accept Conn "
+              "Request (sco_inx 0x%04x)",
+              sco_inx);
+          bta_ag_cb.sco.p_xfer_scb = NULL;
           bta_ag_cb.sco.state = BTA_AG_SCO_LISTEN_ST;
 
           bta_ag_sco_conn_rsp(p_scb, &p_data->conn_evt);
@@ -315,15 +427,21 @@ static void bta_ag_esco_connreq_cback(tBTM_ESCO_EVT event,
                    << (remote_bda ? *remote_bda : RawAddress::kEmpty)
                    << ", active_bda=" << active_device_addr << ", current_bda="
                    << (p_scb ? p_scb->peer_addr : RawAddress::kEmpty);
+    }
+    /* If error occurred send reject response immediately */
+    else {
+      APPL_TRACE_WARNING(
+          "no scb for bta_ag_esco_connreq_cback or no resources");
       BTM_EScoConnRsp(p_data->conn_evt.sco_inx, HCI_ERR_HOST_REJECT_RESOURCES,
                       (enh_esco_params_t*)nullptr);
+                      NULL);
     }
-  } else if (event == BTM_ESCO_CHG_EVT) {
-    /* Received a change in the esco link */
+  }
+  /* Received a change in the esco link */
+  else if (event == BTM_ESCO_CHG_EVT) {
     APPL_TRACE_EVENT(
-        "%s: eSCO change event (inx %d): rtrans %d, "
-        "rxlen %d, txlen %d, txint %d",
-        __func__, p_data->chg_evt.sco_inx, p_data->chg_evt.retrans_window,
+        "eSCO change event (inx %d): rtrans %d, rxlen %d, txlen %d, txint %d",
+        p_data->chg_evt.sco_inx, p_data->chg_evt.retrans_window,
         p_data->chg_evt.rx_pkt_len, p_data->chg_evt.tx_pkt_len,
         p_data->chg_evt.tx_interval);
   }
@@ -351,9 +469,8 @@ static void bta_ag_cback_sco(tBTA_AG_SCB* p_scb, uint8_t event) {
  *
  * Function         bta_ag_create_sco
  *
- * Description      Create a SCO connection for a given control block
- *                  p_scb : Pointer to the target AG control block
- *                  is_orig : Whether to initiate or listen for SCO connection
+ * Description
+ *
  *
  * Returns          void
  *
@@ -386,47 +503,108 @@ static void bta_ag_create_sco(tBTA_AG_SCB* p_scb, bool is_orig) {
   }
 
   if ((p_scb->sco_codec == BTA_AG_CODEC_MSBC) && !p_scb->codec_fallback)
-    esco_codec = BTA_AG_CODEC_MSBC;
+  tBTM_STATUS status;
+  uint8_t* p_bd_addr = NULL;
+  tBTM_ESCO_PARAMS params;
+#if (BTM_WBS_INCLUDED == TRUE)
+  tBTA_AG_PEER_CODEC esco_codec = BTM_SCO_CODEC_CVSD;
+  int codec_index = 0;
+#endif
+#if (BTM_SCO_HCI_INCLUDED == TRUE)
+  tBTM_SCO_ROUTE_TYPE sco_route;
+  tBTA_CODEC_INFO codec_info = {BTA_SCO_CODEC_PCM};
+  uint32_t pcm_sample_rate;
+#endif
+
+  /* Make sure this sco handle is not already in use */
+  if (p_scb->sco_idx != BTM_INVALID_SCO_INDEX) {
+    APPL_TRACE_WARNING("bta_ag_create_sco: Index 0x%04x Already In Use!",
+                       p_scb->sco_idx);
+    return;
+  }
+
+#if (BTM_WBS_INCLUDED == TRUE)
+  if ((p_scb->sco_codec == BTM_SCO_CODEC_MSBC) && !p_scb->codec_fallback &&
+      !p_scb->retry_with_sco_only)
+    esco_codec = BTM_SCO_CODEC_MSBC;
 
   if (p_scb->codec_fallback) {
     p_scb->codec_fallback = false;
+
     /* Force AG to send +BCS for the next audio connection. */
     p_scb->codec_updated = true;
     /* Reset mSBC settings to T2 for the next audio connection */
     p_scb->codec_msbc_settings = BTA_AG_SCO_MSBC_SETTINGS_T2;
   }
 
-  esco_codec_t codec_index = ESCO_CODEC_CVSD;
-  /* If WBS included, use CVSD by default, index is 0 for CVSD by
-   * initialization. If eSCO codec is mSBC, index is T2 or T1 */
-  if (esco_codec == BTA_AG_CODEC_MSBC) {
+  /* If WBS included, use CVSD by default, index is 0 for CVSD by initialization
+   */
+  /* If eSCO codec is mSBC, index is T2 or T1 */
+  if (esco_codec == BTM_SCO_CODEC_MSBC) {
     if (p_scb->codec_msbc_settings == BTA_AG_SCO_MSBC_SETTINGS_T2) {
-      codec_index = ESCO_CODEC_MSBC_T2;
+      codec_index = BTA_AG_ESCO_SETTING_IDX_T2;
     } else {
-      codec_index = ESCO_CODEC_MSBC_T1;
+      codec_index = BTA_AG_ESCO_SETTING_IDX_T1;
     }
   }
 
-  /* Initialize eSCO parameters */
-  enh_esco_params_t params = esco_parameters_for_codec(codec_index);
-  /* For CVSD */
-  if (esco_codec == BTM_SCO_CODEC_CVSD) {
-    /* Use the applicable packet types
-      (3-EV3 not allowed due to errata 2363) */
-    params.packet_types =
-        p_bta_ag_cfg->sco_pkt_types | ESCO_PKT_TYPES_MASK_NO_3_EV3;
-    if ((!(p_scb->features & BTA_AG_FEAT_ESCO)) ||
-        (!(p_scb->peer_features & BTA_AG_PEER_FEAT_ESCO))) {
-      params.max_latency_ms = 10;
-      params.retransmission_effort = ESCO_RETRANSMISSION_POWER;
+  params = bta_ag_esco_params[codec_index];
+#else
+  /* When WBS is not included, use CVSD by default */
+  params = bta_ag_esco_params;
+#endif
+
+  if (bta_ag_cb.sco.param_updated) /* If we do not use the default parameters */
+    params = bta_ag_cb.sco.params;
+
+  if (!bta_ag_cb.sco.param_updated) {
+#if (BTM_WBS_INCLUDED == TRUE)
+    if (esco_codec == BTM_SCO_CODEC_CVSD) /* For CVSD */
+#endif
+    {
+      /* Use the application packet types (5 slot EV packets not allowed) */
+      params.packet_types = p_bta_ag_cfg->sco_pkt_types |
+                            BTM_SCO_PKT_TYPES_MASK_NO_2_EV5 |
+                            BTM_SCO_PKT_TYPES_MASK_NO_3_EV5;
     }
   }
 
-  /* If initiating, setup parameters to start SCO/eSCO connection */
+  /* if initiating set current scb and peer bd addr */
   if (is_orig) {
     bta_ag_cb.sco.is_local = true;
     /* Set eSCO Mode */
     BTM_SetEScoMode(&params);
+    /* Attempt to use eSCO if remote host supports HFP >= 1.5 */
+    /* Need to find out from SIG if HSP can use eSCO; for now use SCO */
+    if (p_scb->conn_service == BTA_AG_HFP &&
+        p_scb->peer_version >= HFP_VERSION_1_5 && !p_scb->retry_with_sco_only) {
+      BTM_SetEScoMode(BTM_LINK_TYPE_ESCO, &params);
+      /* If ESCO or EDR ESCO, retry with SCO only in case of failure */
+      if ((params.packet_types & BTM_ESCO_LINK_ONLY_MASK) ||
+          !((params.packet_types &
+             ~(BTM_ESCO_LINK_ONLY_MASK | BTM_SCO_LINK_ONLY_MASK)) ^
+            BTA_AG_NO_EDR_ESCO)) {
+#if (BTM_WBS_INCLUDED == TRUE)
+        if (esco_codec != BTA_AG_CODEC_MSBC) {
+          p_scb->retry_with_sco_only = true;
+          APPL_TRACE_API("Setting retry_with_sco_only to true");
+        } else /* Do not use SCO when using mSBC */
+        {
+          p_scb->retry_with_sco_only = false;
+          APPL_TRACE_API("Setting retry_with_sco_only to false");
+        }
+#else
+        p_scb->retry_with_sco_only = true;
+        APPL_TRACE_API("Setting retry_with_sco_only to true");
+#endif
+      }
+    } else {
+      if (p_scb->retry_with_sco_only) APPL_TRACE_API("retrying with SCO only");
+      p_scb->retry_with_sco_only = false;
+
+      BTM_SetEScoMode(BTM_LINK_TYPE_SCO, &params);
+    }
+
     bta_ag_cb.sco.p_curr_scb = p_scb;
     /* save the current codec as sco_codec can be updated while SCO is open. */
     p_scb->inuse_codec = esco_codec;
@@ -444,12 +622,39 @@ static void bta_ag_create_sco(tBTA_AG_SCB* p_scb, bool is_orig) {
         &p_scb->peer_addr, false, params.packet_types, &p_scb->sco_idx,
         bta_ag_sco_conn_cback, bta_ag_sco_disc_cback);
     if (status == BTM_CMD_STARTED) {
+#if (BTM_WBS_INCLUDED == TRUE)
+    /* Allow any platform specific pre-SCO set up to take place */
+    bta_ag_co_audio_state(bta_ag_scb_to_idx(p_scb), p_scb->app_id,
+                          SCO_STATE_SETUP, esco_codec);
+
+    /* This setting may not be necessary */
+    /* To be verified with stable 2049 boards */
+    if (esco_codec == BTA_AG_CODEC_MSBC)
+      BTM_WriteVoiceSettings(BTM_VOICE_SETTING_TRANS);
+    else
+      BTM_WriteVoiceSettings(BTM_VOICE_SETTING_CVSD);
+    /* save the current codec because sco_codec can be updated while SCO is
+     * open. */
+    p_scb->inuse_codec = esco_codec;
+#else
+    /* Allow any platform specific pre-SCO set up to take place */
+    bta_ag_co_audio_state(bta_ag_scb_to_idx(p_scb), p_scb->app_id,
+                          SCO_STATE_SETUP);
+#endif
+  } else {
+    p_scb->retry_with_sco_only = false;
+    p_bd_addr = p_scb->peer_addr;
+
+    tBTM_STATUS status =
+        BTM_CreateSco(p_bd_addr, is_orig, params.packet_types, &p_scb->sco_idx,
+                      bta_ag_sco_conn_cback, bta_ag_sco_disc_cback);
+    if (status == BTM_CMD_STARTED)
       BTM_RegForEScoEvts(p_scb->sco_idx, bta_ag_esco_connreq_cback);
     }
 
-    APPL_TRACE_API("%s: orig %d, inx 0x%04x, status 0x%x, pkt types 0x%04x",
-                   __func__, is_orig, p_scb->sco_idx, status,
-                   params.packet_types);
+    APPL_TRACE_API(
+        "ag create sco: orig %d, inx 0x%04x, status 0x%x, pkt types 0x%04x",
+        is_orig, p_scb->sco_idx, status, params.packet_types);
   }
   APPL_TRACE_DEBUG(
       "%s: AFTER codec_updated=%d, codec_fallback=%d, "
@@ -479,19 +684,16 @@ static void bta_ag_create_pending_sco(tBTA_AG_SCB* p_scb, bool is_local) {
 
   /* Local device requested SCO connection to peer */
   if (is_local) {
-    if (esco_codec == BTA_AG_CODEC_MSBC) {
-      if (p_scb->codec_msbc_settings == BTA_AG_SCO_MSBC_SETTINGS_T2) {
-        params = esco_parameters_for_codec(ESCO_CODEC_MSBC_T2);
-      } else
-        params = esco_parameters_for_codec(ESCO_CODEC_MSBC_T1);
-    } else {
-      params = esco_parameters_for_codec(ESCO_CODEC_CVSD);
-      if ((!(p_scb->features & BTA_AG_FEAT_ESCO)) ||
-          (!(p_scb->peer_features & BTA_AG_PEER_FEAT_ESCO))) {
-        params.max_latency_ms = 10;
-        params.retransmission_effort = ESCO_RETRANSMISSION_POWER;
-      }
-    }
+    if (bta_ag_cb.sco.set_audio_status == BTA_AG_SUCCESS) {
+      if (esco_codec == BTA_AG_CODEC_MSBC) {
+
+#if (BTM_SCO_HCI_INCLUDED == TRUE)
+#if (BTM_WBS_INCLUDED == TRUE)
+    if (esco_codec == BTA_AG_CODEC_MSBC)
+      pcm_sample_rate = BTA_DM_SCO_SAMP_RATE_16K;
+    else
+#endif
+      pcm_sample_rate = BTA_DM_SCO_SAMP_RATE_8K;
 
     /* Bypass voice settings if enhanced SCO setup command is supported */
     if (!(controller_get_interface()
@@ -508,22 +710,72 @@ static void bta_ag_create_pending_sco(tBTA_AG_SCB* p_scb, bool is_local) {
                       bta_ag_sco_disc_cback) == BTM_CMD_STARTED) {
       /* Initiating the connection, set the current sco handle */
       bta_ag_cb.sco.cur_idx = p_scb->sco_idx;
+#if (BTM_WBS_INCLUDED == TRUE)
+      /* Bypass vendor specific and voice settings if enhanced eSCO supported */
+      if (!(controller_get_interface()
+                ->supports_enhanced_setup_synchronous_connection())) {
+        if (esco_codec == BTA_AG_CODEC_MSBC)
+          BTM_WriteVoiceSettings(BTM_VOICE_SETTING_TRANS);
+        else
+          BTM_WriteVoiceSettings(BTM_VOICE_SETTING_CVSD);
+      }
+    sco_route = bta_dm_sco_co_init(pcm_sample_rate, pcm_sample_rate,
+                                   &codec_info, p_scb->app_id);
+#endif
+
+#if (BTM_SCO_HCI_INCLUDED == TRUE)
+    /* initialize SCO setup, no voice setting for AG, data rate <==> sample rate
+     */
+    BTM_ConfigScoPath(sco_route, bta_ag_sco_read_cback, NULL, true);
+#endif
+    bta_ag_cb.sco.cur_idx = p_scb->sco_idx;
+  } else
+    p_scb->retry_with_sco_only = false;
+
+      tBTM_STATUS status = BTM_CreateSco(
+          p_scb->peer_addr, TRUE, params.packet_types, &p_scb->sco_idx,
+          bta_ag_sco_conn_cback, bta_ag_sco_disc_cback);
+      if (status == BTM_CMD_STARTED) {
+        /* Initiating the connection, set the current sco handle */
+        bta_ag_cb.sco.cur_idx = p_scb->sco_idx;
+      }
+    } else {
+      /* Pre-SCO Vendor setup failed Go back to Listening state */
+      bta_ag_cb.sco.state = BTA_AG_SCO_LISTEN_ST;
+      bta_ag_create_sco(p_scb, false);
     }
     APPL_TRACE_DEBUG("%s: initiated SCO connection", __func__);
   } else {
-    /* Local device accepted SCO connection from peer */
     params = esco_parameters_for_codec(ESCO_CODEC_CVSD);
     if ((!(p_scb->features & BTA_AG_FEAT_ESCO)) ||
-        (!(p_scb->peer_features & BTA_AG_PEER_FEAT_ESCO))) {
-      params.max_latency_ms = 10;
-      params.retransmission_effort = ESCO_RETRANSMISSION_POWER;
+        (!(p_scb->peer_features & BTA_AG_PEER_FEAT_ESCO)))
+  p_bd_addr = p_scb->peer_addr;
+
+  status =
+      BTM_CreateSco(p_bd_addr, is_orig, params.packet_types, &p_scb->sco_idx,
+                    bta_ag_sco_conn_cback, bta_ag_sco_disc_cback);
+  if (status == BTM_CMD_STARTED) {
+    if (!is_orig) {
+      BTM_RegForEScoEvts(p_scb->sco_idx, bta_ag_esco_connreq_cback);
+    } else /* Initiating the connection, set the current sco handle */
+    {
+      bta_ag_cb.sco.cur_idx = p_scb->sco_idx;
     }
 
     BTM_EScoConnRsp(p_scb->sco_idx, HCI_SUCCESS, &params);
     APPL_TRACE_DEBUG("%s: listening for SCO connection", __func__);
+    if (bta_ag_cb.sco.set_audio_status == BTA_AG_SUCCESS)
+      BTM_EScoConnRsp(p_scb->sco_idx, HCI_SUCCESS, &params);
+    else
+      BTM_EScoConnRsp(p_scb->sco_idx, HCI_ERR_HOST_REJECT_RESOURCES, &params);
   }
+
+  APPL_TRACE_API(
+      "ag create sco: orig %d, inx 0x%04x, status 0x%x, pkt types 0x%04x",
+      is_orig, p_scb->sco_idx, status, params.packet_types);
 }
 
+#if (BTM_WBS_INCLUDED == TRUE)
 /*******************************************************************************
  *
  * Function         bta_ag_codec_negotiation_timer_cback
@@ -535,7 +787,6 @@ static void bta_ag_create_pending_sco(tBTA_AG_SCB* p_scb, bool is_local) {
  *
  ******************************************************************************/
 static void bta_ag_codec_negotiation_timer_cback(void* data) {
-  APPL_TRACE_DEBUG("%s", __func__);
   tBTA_AG_SCB* p_scb = (tBTA_AG_SCB*)data;
 
   /* Announce that codec negotiation failed. */
@@ -556,7 +807,6 @@ static void bta_ag_codec_negotiation_timer_cback(void* data) {
  *
  ******************************************************************************/
 void bta_ag_codec_negotiate(tBTA_AG_SCB* p_scb) {
-  APPL_TRACE_DEBUG("%s", __func__);
   bta_ag_cb.sco.p_curr_scb = p_scb;
 
   // Workaround for misbehaving HFs such as Sony XAV AX100 car kit and Sony
@@ -568,8 +818,10 @@ void bta_ag_codec_negotiate(tBTA_AG_SCB* p_scb) {
   }
 
   if ((p_scb->codec_updated || p_scb->codec_fallback) &&
+  if ((p_scb->codec_updated || p_scb->codec_fallback ||
+       bta_ag_attempt_msbc_safe_settings(p_scb)) &&
       (p_scb->peer_features & BTA_AG_PEER_FEAT_CODEC)) {
-    /* Change the power mode to Active until SCO open is completed. */
+    /* Change the power mode to Active until sco open is completed. */
     bta_sys_busy(BTA_ID_AG, p_scb->app_id, p_scb->peer_addr);
 
     /* Send +BCS to the peer */
@@ -587,6 +839,7 @@ void bta_ag_codec_negotiate(tBTA_AG_SCB* p_scb) {
     bta_ag_sco_codec_nego(p_scb, true);
   }
 }
+#endif /* (BTM_WBS_INCLUDED == TRUE) */
 
 /*******************************************************************************
  *
@@ -606,6 +859,40 @@ static void bta_ag_sco_event(tBTA_AG_SCB* p_scb, uint8_t event) {
                    p_scb->peer_addr.ToString().c_str(),
                    bta_ag_sco_state_str(p_sco->state), p_sco->state,
                    bta_ag_sco_evt_str(event), event);
+#if (BTM_WBS_INCLUDED == TRUE)
+  tBTA_AG_SCB* p_cn_scb = NULL; /* For codec negotiation */
+#endif
+#if (BTM_SCO_HCI_INCLUDED == TRUE)
+  BT_HDR* p_buf;
+#endif
+#if (BTA_AG_SCO_DEBUG == TRUE)
+  uint8_t in_state = p_sco->state;
+
+  APPL_TRACE_EVENT("BTA ag sco evt (hdl 0x%04x): State %d (%s), Event %d (%s)",
+                   p_scb->sco_idx, p_sco->state,
+                   bta_ag_sco_state_str(p_sco->state), event,
+                   bta_ag_sco_evt_str(event));
+#else
+  APPL_TRACE_EVENT("BTA ag sco evt (hdl 0x%04x): State %d, Event %d",
+                   p_scb->sco_idx, p_sco->state, event);
+#endif
+
+#if (BTM_SCO_HCI_INCLUDED == TRUE)
+  if (event == BTA_AG_SCO_CI_DATA_E) {
+    while (true) {
+      bta_dm_sco_co_out_data(&p_buf);
+      if (p_buf) {
+        if (p_sco->state == BTA_AG_SCO_OPEN_ST)
+          BTM_WriteScoData(p_sco->p_curr_scb->sco_idx, p_buf);
+        else
+          osi_free(p_buf);
+      } else
+        break;
+    }
+
+    return;
+  }
+#endif
 
   switch (p_sco->state) {
     case BTA_AG_SCO_SHUTDOWN_ST:
@@ -620,6 +907,8 @@ static void bta_ag_sco_event(tBTA_AG_SCB* p_scb, uint8_t event) {
           APPL_TRACE_WARNING(
               "%s: BTA_AG_SCO_SHUTDOWN_ST: Ignoring event %s[%d]", __func__,
               bta_ag_sco_evt_str(event), event);
+          APPL_TRACE_WARNING("BTA_AG_SCO_SHUTDOWN_ST: Ignoring event %d",
+                             event);
           break;
       }
       break;
@@ -635,9 +924,15 @@ static void bta_ag_sco_event(tBTA_AG_SCB* p_scb, uint8_t event) {
           /* remove listening connection */
           bta_ag_remove_sco(p_scb, false);
 
+#if (BTM_WBS_INCLUDED == TRUE)
           /* start codec negotiation */
           p_sco->state = BTA_AG_SCO_CODEC_ST;
-          bta_ag_codec_negotiate(p_scb);
+          p_cn_scb = p_scb;
+#else
+          /* create sco connection to peer */
+          bta_ag_create_sco(p_scb, true);
+          p_sco->state = BTA_AG_SCO_OPENING_ST;
+#endif
           break;
 
         case BTA_AG_SCO_SHUTDOWN_E:
@@ -654,10 +949,11 @@ static void bta_ag_sco_event(tBTA_AG_SCB* p_scb, uint8_t event) {
 
         case BTA_AG_SCO_CLOSE_E:
           /* remove listening connection */
-          /* Ignore the event. Keep listening SCO for the active SLC
+          /* Ignore the event. We need to keep listening SCO for the active SLC
            */
           APPL_TRACE_WARNING("%s: BTA_AG_SCO_LISTEN_ST: Ignoring event %s[%d]",
                              __func__, bta_ag_sco_evt_str(event), event);
+          APPL_TRACE_WARNING("BTA_AG_SCO_LISTEN_ST: Ignoring event %d", event);
           break;
 
         case BTA_AG_SCO_CONN_CLOSE_E:
@@ -669,10 +965,12 @@ static void bta_ag_sco_event(tBTA_AG_SCB* p_scb, uint8_t event) {
         default:
           APPL_TRACE_WARNING("%s: BTA_AG_SCO_LISTEN_ST: Ignoring event %s[%d]",
                              __func__, bta_ag_sco_evt_str(event), event);
+          APPL_TRACE_WARNING("BTA_AG_SCO_LISTEN_ST: Ignoring event %d", event);
           break;
       }
       break;
 
+#if (BTM_WBS_INCLUDED == TRUE)
     case BTA_AG_SCO_CODEC_ST:
       switch (event) {
         case BTA_AG_SCO_LISTEN_E:
@@ -718,9 +1016,11 @@ static void bta_ag_sco_event(tBTA_AG_SCB* p_scb, uint8_t event) {
         default:
           APPL_TRACE_WARNING("%s: BTA_AG_SCO_CODEC_ST: Ignoring event %s[%d]",
                              __func__, bta_ag_sco_evt_str(event), event);
+          APPL_TRACE_WARNING("BTA_AG_SCO_CODEC_ST: Ignoring event %d", event);
           break;
       }
       break;
+#endif
 
     case BTA_AG_SCO_OPENING_ST:
       switch (event) {
@@ -732,11 +1032,13 @@ static void bta_ag_sco_event(tBTA_AG_SCB* p_scb, uint8_t event) {
           }
           break;
 
+#if (BTM_WBS_INCLUDED == TRUE)
         case BTA_AG_SCO_REOPEN_E:
           /* start codec negotiation */
           p_sco->state = BTA_AG_SCO_CODEC_ST;
-          bta_ag_codec_negotiate(p_scb);
+          p_cn_scb = p_scb;
           break;
+#endif
 
         case BTA_AG_SCO_XFER_E:
           /* save xfer scb */
@@ -771,6 +1073,7 @@ static void bta_ag_sco_event(tBTA_AG_SCB* p_scb, uint8_t event) {
         default:
           APPL_TRACE_WARNING("%s: BTA_AG_SCO_OPENING_ST: Ignoring event %s[%d]",
                              __func__, bta_ag_sco_evt_str(event), event);
+          APPL_TRACE_WARNING("BTA_AG_SCO_OPENING_ST: Ignoring event %d", event);
           break;
       }
       break;
@@ -814,6 +1117,7 @@ static void bta_ag_sco_event(tBTA_AG_SCB* p_scb, uint8_t event) {
         default:
           APPL_TRACE_WARNING("%s: BTA_AG_SCO_OPEN_CL_ST: Ignoring event %s[%d]",
                              __func__, bta_ag_sco_evt_str(event), event);
+          APPL_TRACE_WARNING("BTA_AG_SCO_OPEN_CL_ST: Ignoring event %d", event);
           break;
       }
       break;
@@ -851,6 +1155,8 @@ static void bta_ag_sco_event(tBTA_AG_SCB* p_scb, uint8_t event) {
           APPL_TRACE_WARNING(
               "%s: BTA_AG_SCO_OPEN_XFER_ST: Ignoring event %s[%d]", __func__,
               bta_ag_sco_evt_str(event), event);
+          APPL_TRACE_WARNING("BTA_AG_SCO_OPEN_XFER_ST: Ignoring event %d",
+                             event);
           break;
       }
       break;
@@ -901,6 +1207,7 @@ static void bta_ag_sco_event(tBTA_AG_SCB* p_scb, uint8_t event) {
         default:
           APPL_TRACE_WARNING("%s: BTA_AG_SCO_OPEN_ST: Ignoring event %s[%d]",
                              __func__, bta_ag_sco_evt_str(event), event);
+          APPL_TRACE_WARNING("BTA_AG_SCO_OPEN_ST: Ignoring event %d", event);
           break;
       }
       break;
@@ -945,6 +1252,7 @@ static void bta_ag_sco_event(tBTA_AG_SCB* p_scb, uint8_t event) {
         default:
           APPL_TRACE_WARNING("%s: BTA_AG_SCO_CLOSING_ST: Ignoring event %s[%d]",
                              __func__, bta_ag_sco_evt_str(event), event);
+          APPL_TRACE_WARNING("BTA_AG_SCO_CLOSING_ST: Ignoring event %d", event);
           break;
       }
       break;
@@ -960,9 +1268,15 @@ static void bta_ag_sco_event(tBTA_AG_SCB* p_scb, uint8_t event) {
           break;
 
         case BTA_AG_SCO_CONN_CLOSE_E:
+#if (BTM_WBS_INCLUDED == TRUE)
           /* start codec negotiation */
           p_sco->state = BTA_AG_SCO_CODEC_ST;
-          bta_ag_codec_negotiate(p_scb);
+          p_cn_scb = p_scb;
+#else
+          /* open sco connection */
+          bta_ag_create_sco(p_scb, true);
+          p_sco->state = BTA_AG_SCO_OPENING_ST;
+#endif
           break;
 
         case BTA_AG_SCO_LISTEN_E:
@@ -976,6 +1290,8 @@ static void bta_ag_sco_event(tBTA_AG_SCB* p_scb, uint8_t event) {
           APPL_TRACE_WARNING(
               "%s: BTA_AG_SCO_CLOSE_OP_ST: Ignoring event %s[%d]", __func__,
               bta_ag_sco_evt_str(event), event);
+          APPL_TRACE_WARNING("BTA_AG_SCO_CLOSE_OP_ST: Ignoring event %d",
+                             event);
           break;
       }
       break;
@@ -1002,25 +1318,35 @@ static void bta_ag_sco_event(tBTA_AG_SCB* p_scb, uint8_t event) {
           p_sco->state = BTA_AG_SCO_SHUTTING_ST;
           break;
 
-        case BTA_AG_SCO_CONN_CLOSE_E: {
+        case BTA_AG_SCO_CONN_CLOSE_E:
           /* closed sco; place old sco in listen mode,
              take current sco out of listen, and
              create originating sco for current */
           bta_ag_create_sco(p_scb, false);
           bta_ag_remove_sco(p_sco->p_xfer_scb, false);
 
+#if (BTM_WBS_INCLUDED == TRUE)
           /* start codec negotiation */
           p_sco->state = BTA_AG_SCO_CODEC_ST;
           tBTA_AG_SCB* p_cn_scb = p_sco->p_xfer_scb;
           p_sco->p_xfer_scb = nullptr;
           bta_ag_codec_negotiate(p_cn_scb);
+          p_cn_scb = p_sco->p_xfer_scb;
+          p_sco->p_xfer_scb = NULL;
+#else
+          /* create sco connection to peer */
+          bta_ag_create_sco(p_sco->p_xfer_scb, true);
+          p_sco->p_xfer_scb = NULL;
+          p_sco->state = BTA_AG_SCO_OPENING_ST;
+#endif
           break;
-        }
 
         default:
           APPL_TRACE_WARNING(
               "%s: BTA_AG_SCO_CLOSE_XFER_ST: Ignoring event %s[%d]", __func__,
               bta_ag_sco_evt_str(event), event);
+          APPL_TRACE_WARNING("BTA_AG_SCO_CLOSE_XFER_ST: Ignoring event %d",
+                             event);
           break;
       }
       break;
@@ -1079,6 +1405,8 @@ static void bta_ag_sco_event(tBTA_AG_SCB* p_scb, uint8_t event) {
           APPL_TRACE_WARNING(
               "%s: BTA_AG_SCO_SHUTTING_ST: Ignoring event %s[%d]", __func__,
               bta_ag_sco_evt_str(event), event);
+          APPL_TRACE_WARNING("BTA_AG_SCO_SHUTTING_ST: Ignoring event %d",
+                             event);
           break;
       }
       break;
@@ -1094,6 +1422,13 @@ static void bta_ag_sco_event(tBTA_AG_SCB* p_scb, uint8_t event) {
         bta_ag_sco_state_str(p_sco->state), p_sco->state,
         bta_ag_sco_evt_str(event), event);
   }
+#endif
+
+#if (BTM_WBS_INCLUDED == TRUE)
+  if (p_cn_scb) {
+    bta_ag_codec_negotiate(p_cn_scb);
+  }
+#endif
 }
 
 /*******************************************************************************
@@ -1187,16 +1522,29 @@ void bta_ag_sco_close(tBTA_AG_SCB* p_scb,
    * state. */
   if ((p_scb->sco_idx != BTM_INVALID_SCO_INDEX) ||
       (bta_ag_cb.sco.state == BTA_AG_SCO_CODEC_ST)) {
+void bta_ag_sco_close(tBTA_AG_SCB* p_scb, UNUSED_ATTR tBTA_AG_DATA* p_data) {
+/* if scb is in use */
+#if (BTM_WBS_INCLUDED == TRUE)
+  /* sco_idx is not allocated in SCO_CODEC_ST, we still need to move to
+   * listening state. */
+  if ((p_scb->sco_idx != BTM_INVALID_SCO_INDEX) ||
+      (bta_ag_cb.sco.state == BTA_AG_SCO_CODEC_ST))
+#else
+  if (p_scb->sco_idx != BTM_INVALID_SCO_INDEX)
+#endif
+  {
     APPL_TRACE_DEBUG("bta_ag_sco_close: sco_inx = %d", p_scb->sco_idx);
     bta_ag_sco_event(p_scb, BTA_AG_SCO_CLOSE_E);
   }
 }
 
+#if (BTM_WBS_INCLUDED == TRUE)
+
 /*******************************************************************************
  *
  * Function         bta_ag_sco_codec_nego
  *
- * Description      Handles result of eSCO codec negotiation
+ * Description
  *
  *
  * Returns          void
@@ -1207,15 +1555,19 @@ void bta_ag_sco_codec_nego(tBTA_AG_SCB* p_scb, bool result) {
     /* Subsequent SCO connection will skip codec negotiation */
     APPL_TRACE_DEBUG("%s: Succeeded for index 0x%04x, device %s", __func__,
                      p_scb->sco_idx, p_scb->peer_addr.ToString().c_str());
+  if (result == true) {
+    /* Subsequent sco connection will skip codec negotiation */
     p_scb->codec_updated = false;
+
     bta_ag_sco_event(p_scb, BTA_AG_SCO_CN_DONE_E);
   } else {
     /* codec negotiation failed */
     APPL_TRACE_ERROR("%s: Failed for index 0x%04x, device %s", __func__,
                      p_scb->sco_idx, p_scb->peer_addr.ToString().c_str());
+  } else /* codec negotiation failed */
     bta_ag_sco_event(p_scb, BTA_AG_SCO_CLOSE_E);
-  }
 }
+#endif
 
 /*******************************************************************************
  *
@@ -1248,11 +1600,27 @@ void bta_ag_sco_conn_open(tBTA_AG_SCB* p_scb,
 
   bta_sys_sco_open(BTA_ID_AG, p_scb->app_id, p_scb->peer_addr);
 
+#if (BTM_WBS_INCLUDED == TRUE)
+  bta_ag_co_audio_state(bta_ag_scb_to_idx(p_scb), p_scb->app_id, SCO_STATE_ON,
+                        p_scb->inuse_codec);
+#else
+  bta_ag_co_audio_state(bta_ag_scb_to_idx(p_scb), p_scb->app_id, SCO_STATE_ON);
+#endif
+
+#if (BTM_SCO_HCI_INCLUDED == TRUE)
+  /* open SCO codec if SCO is routed through transport */
+  bta_dm_sco_co_open(bta_ag_scb_to_idx(p_scb), BTA_SCO_OUT_PKT_SIZE,
+                     BTA_AG_CI_SCO_DATA_EVT);
+#endif
+
   /* call app callback */
   bta_ag_cback_sco(p_scb, BTA_AG_AUDIO_OPEN_EVT);
 
+  p_scb->retry_with_sco_only = false;
+#if (BTM_WBS_INCLUDED == TRUE)
   /* reset to mSBC T2 settings as the preferred */
   p_scb->codec_msbc_settings = BTA_AG_SCO_MSBC_SETTINGS_T2;
+#endif
 }
 
 /*******************************************************************************
@@ -1267,10 +1635,14 @@ void bta_ag_sco_conn_open(tBTA_AG_SCB* p_scb,
  ******************************************************************************/
 void bta_ag_sco_conn_close(tBTA_AG_SCB* p_scb,
                            UNUSED_ATTR const tBTA_AG_DATA& data) {
+                           UNUSED_ATTR tBTA_AG_DATA* p_data) {
+  uint16_t handle = bta_ag_scb_to_idx(p_scb);
+
   /* clear current scb */
   bta_ag_cb.sco.p_curr_scb = nullptr;
   p_scb->sco_idx = BTM_INVALID_SCO_INDEX;
 
+#if (BTM_WBS_INCLUDED == TRUE)
   /* codec_fallback is set when AG is initiator and connection failed for mSBC.
    * OR if codec is msbc and T2 settings failed, then retry Safe T1 settings */
   if (p_scb->svc_conn &&
@@ -1279,7 +1651,28 @@ void bta_ag_sco_conn_close(tBTA_AG_SCB* p_scb,
         p_scb->codec_msbc_settings == BTA_AG_SCO_MSBC_SETTINGS_T1))) {
     bta_ag_sco_event(p_scb, BTA_AG_SCO_REOPEN_E);
   } else {
+  } else if (p_scb->retry_with_sco_only && p_scb->svc_conn) {
+    /* retry_with_sco_only is set when AG is initiator and connection failed for
+     * eSCO */
+    bta_ag_create_sco(p_scb, true);
+  }
+#else
+  /* retry_with_sco_only, will be set only when AG is initiator
+  ** and AG is first trying to establish an eSCO connection */
+  if (p_scb->retry_with_sco_only && p_scb->svc_conn) {
+    bta_ag_create_sco(p_scb, true);
+  }
+#endif
+  else {
+    sco_state_t sco_state =
+        bta_ag_cb.sco.p_xfer_scb ? SCO_STATE_OFF_TRANSFER : SCO_STATE_OFF;
+#if (BTM_WBS_INCLUDED == TRUE)
+    /* Indicate if the closing of audio is because of transfer */
+    bta_ag_co_audio_state(handle, p_scb->app_id, sco_state, p_scb->inuse_codec);
+#else
     /* Indicate if the closing of audio is because of transfer */
+    bta_ag_co_audio_state(handle, p_scb->app_id, sco_state);
+#endif
     bta_ag_sco_event(p_scb, BTA_AG_SCO_CONN_CLOSE_E);
 
     bta_sys_sco_close(BTA_ID_AG, p_scb->app_id, p_scb->peer_addr);
@@ -1294,7 +1687,9 @@ void bta_ag_sco_conn_close(tBTA_AG_SCB* p_scb,
 
     /* call app callback */
     bta_ag_cback_sco(p_scb, BTA_AG_AUDIO_CLOSE_EVT);
+#if (BTM_WBS_INCLUDED == TRUE)
     p_scb->codec_msbc_settings = BTA_AG_SCO_MSBC_SETTINGS_T2;
+#endif
   }
 }
 
@@ -1310,25 +1705,71 @@ void bta_ag_sco_conn_close(tBTA_AG_SCB* p_scb,
  ******************************************************************************/
 void bta_ag_sco_conn_rsp(tBTA_AG_SCB* p_scb,
                          tBTM_ESCO_CONN_REQ_EVT_DATA* p_data) {
-  bta_ag_cb.sco.is_local = false;
-
-  APPL_TRACE_DEBUG("%s: eSCO %d, state %d", __func__,
-                   controller_get_interface()
-                       ->supports_enhanced_setup_synchronous_connection(),
-                   bta_ag_cb.sco.state);
+  tBTM_ESCO_PARAMS resp;
+  uint8_t hci_status = HCI_SUCCESS;
+#if (BTM_SCO_HCI_INCLUDED == TRUE)
+  tBTA_CODEC_INFO codec_info = {BTA_SCO_CODEC_PCM};
+  uint32_t pcm_sample_rate;
+#endif
 
   if (bta_ag_cb.sco.state == BTA_AG_SCO_LISTEN_ST ||
       bta_ag_cb.sco.state == BTA_AG_SCO_CLOSE_XFER_ST ||
       bta_ag_cb.sco.state == BTA_AG_SCO_OPEN_XFER_ST) {
+    /* If script overrided sco parameter by BTA_CMD_SET_ESCO_PARAM */
+    if (bta_ag_cb.sco.param_updated) {
+      resp = bta_ag_cb.sco.params;
+    } else {
+      resp.rx_bw = BTM_64KBITS_RATE;
+      resp.tx_bw = BTM_64KBITS_RATE;
+      resp.max_latency = 12;
+      resp.voice_contfmt = 0x60;
+      resp.retrans_effort = BTM_ESCO_RETRANS_QUALITY;
+
+      if (p_data->link_type == BTM_LINK_TYPE_SCO) {
+        resp.packet_types =
+            (BTM_SCO_LINK_ONLY_MASK | BTM_SCO_PKT_TYPES_MASK_NO_2_EV3 |
+             BTM_SCO_PKT_TYPES_MASK_NO_3_EV3 | BTM_SCO_PKT_TYPES_MASK_NO_2_EV5 |
+             BTM_SCO_PKT_TYPES_MASK_NO_3_EV5);
+      } else /* Allow controller to use all types available except 5-slot EDR */
+      {
+        resp.packet_types =
+            (BTM_SCO_LINK_ALL_PKT_MASK | BTM_SCO_PKT_TYPES_MASK_NO_2_EV5 |
+             BTM_SCO_PKT_TYPES_MASK_NO_3_EV5);
+      }
+    }
+
     /* tell sys to stop av if any */
     bta_sys_sco_use(BTA_ID_AG, p_scb->app_id, p_scb->peer_addr);
+
+#if (BTM_WBS_INCLUDED == FALSE)
+    /* Allow any platform specific pre-SCO set up to take place */
+    bta_ag_co_audio_state(bta_ag_scb_to_idx(p_scb), p_scb->app_id,
+                          SCO_STATE_SETUP);
+#else
     /* When HS initiated SCO, it cannot be WBS. */
-  }
+    /* Allow any platform specific pre-SCO set up to take place */
+    bta_ag_co_audio_state(bta_ag_scb_to_idx(p_scb), p_scb->app_id,
+                          SCO_STATE_SETUP, BTA_AG_CODEC_CVSD);
+#endif
+
+#if (BTM_SCO_HCI_INCLUDED == TRUE)
+    pcm_sample_rate = BTA_DM_SCO_SAMP_RATE_8K;
+
+    /* initialize SCO setup, no voice setting for AG, data rate <==> sample rate
+     */
+    BTM_ConfigScoPath(bta_dm_sco_co_init(pcm_sample_rate, pcm_sample_rate,
+                                         &codec_info, p_scb->app_id),
+                      bta_ag_sco_read_cback, NULL, true);
+#endif
+  } else
+    hci_status = HCI_ERR_HOST_REJECT_DEVICE;
 
+#if (BTM_WBS_INCLUDED == TRUE)
   /* If SCO open was initiated from HS, it must be CVSD */
   p_scb->inuse_codec = BTA_AG_CODEC_NONE;
-  /* Send pending commands to create SCO connection to peer */
-  bta_ag_create_pending_sco(p_scb, bta_ag_cb.sco.is_local);
+#endif
+
+  BTM_EScoConnRsp(p_data->sco_inx, hci_status, &resp);
 }
 
 void bta_ag_set_sco_allowed(bool value) {
@@ -1337,13 +1778,98 @@ void bta_ag_set_sco_allowed(bool value) {
 }
 
 const RawAddress& bta_ag_get_active_device() { return active_device_addr; }
+/*******************************************************************************
+ *
+ * Function         bta_ag_set_esco_param
+ *
+ * Description      Update esco parameters from script wrapper.
+ *
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+void bta_ag_set_esco_param(bool set_reset, tBTM_ESCO_PARAMS* param) {
+  if (set_reset == false) /* reset the parameters to default */
+  {
+    bta_ag_cb.sco.param_updated = false;
+    APPL_TRACE_DEBUG(
+        "bta_ag_set_esco_param : Resetting ESCO parameters to default");
+  } else {
+    bta_ag_cb.sco.param_updated = true;
+    bta_ag_cb.sco.params = *param;
+    APPL_TRACE_DEBUG("bta_ag_set_esco_param : Setting ESCO parameters");
+  }
+}
+
+/*******************************************************************************
+ *  Debugging functions
+ ******************************************************************************/
 
 void bta_clear_active_device() { active_device_addr = RawAddress::kEmpty; }
+#if (BTA_AG_SCO_DEBUG == TRUE)
+static char* bta_ag_sco_evt_str(uint8_t event) {
+  switch (event) {
+    case BTA_AG_SCO_LISTEN_E:
+      return "Listen Request";
+    case BTA_AG_SCO_OPEN_E:
+      return "Open Request";
+    case BTA_AG_SCO_XFER_E:
+      return "Transfer Request";
+#if (BTM_WBS_INCLUDED == TRUE)
+    case BTA_AG_SCO_CN_DONE_E:
+      return "Codec Negotiation Done";
+    case BTA_AG_SCO_REOPEN_E:
+      return "Reopen Request";
+#endif
+    case BTA_AG_SCO_CLOSE_E:
+      return "Close Request";
+    case BTA_AG_SCO_SHUTDOWN_E:
+      return "Shutdown Request";
+    case BTA_AG_SCO_CONN_OPEN_E:
+      return "Opened";
+    case BTA_AG_SCO_CONN_CLOSE_E:
+      return "Closed";
+    case BTA_AG_SCO_CI_DATA_E:
+      return "Sco Data";
+    default:
+      return "Unknown SCO Event";
+  }
+}
 
 void bta_ag_api_set_active_device(const RawAddress& new_active_device) {
   if (new_active_device.IsEmpty()) {
     APPL_TRACE_ERROR("%s: empty device", __func__);
     return;
+static char* bta_ag_sco_state_str(uint8_t state) {
+  switch (state) {
+    case BTA_AG_SCO_SHUTDOWN_ST:
+      return "Shutdown";
+    case BTA_AG_SCO_LISTEN_ST:
+      return "Listening";
+#if (BTM_WBS_INCLUDED == TRUE)
+    case BTA_AG_SCO_CODEC_ST:
+      return "Codec Negotiation";
+#endif
+    case BTA_AG_SCO_OPENING_ST:
+      return "Opening";
+    case BTA_AG_SCO_OPEN_CL_ST:
+      return "Open while closing";
+    case BTA_AG_SCO_OPEN_XFER_ST:
+      return "Opening while Transferring";
+    case BTA_AG_SCO_OPEN_ST:
+      return "Open";
+    case BTA_AG_SCO_CLOSING_ST:
+      return "Closing";
+    case BTA_AG_SCO_CLOSE_OP_ST:
+      return "Close while Opening";
+    case BTA_AG_SCO_CLOSE_XFER_ST:
+      return "Close while Transferring";
+    case BTA_AG_SCO_SHUTTING_ST:
+      return "Shutting Down";
+    default:
+      return "Unknown SCO State";
   }
   active_device_addr = new_active_device;
 }
+
+#endif
diff --git a/system/bt/bta/dm/bta_dm_act.cc b/system/bt/bta/dm/bta_dm_act.cc
index 5abda87bd..33c105a98 100644
--- a/system/bt/bta/dm/bta_dm_act.cc
+++ b/system/bt/bta/dm/bta_dm_act.cc
@@ -3666,11 +3666,11 @@ bool bta_dm_check_if_only_hd_connected(const RawAddress& peer_addr) {
         bta_dm_conn_srvcs.conn_srvc[j].peer_bdaddr == peer_addr) {
       APPL_TRACE_DEBUG("%s: Another profile (id=%d) is connected", __func__,
                        bta_dm_conn_srvcs.conn_srvc[j].id);
-      return false;
+      return FALSE;
     }
   }
 
-  return true;
+  return TRUE;
 }
 
 /*******************************************************************************
diff --git a/system/bt/bta/hf_client/bta_hf_client_sco.cc b/system/bt/bta/hf_client/bta_hf_client_sco.cc
index e03de4f95..5a098a744 100644
--- a/system/bt/bta/hf_client/bta_hf_client_sco.cc
+++ b/system/bt/bta/hf_client/bta_hf_client_sco.cc
@@ -20,14 +20,50 @@
 
 #include "bt_trace.h"
 #include "bt_utils.h"
-#include "bta_ag_api.h"
 #include "bta_hf_client_int.h"
-#include "device/include/esco_parameters.h"
 #include "osi/include/osi.h"
 
-#define BTA_HF_CLIENT_NO_EDR_ESCO                                \
-  (ESCO_PKT_TYPES_MASK_NO_2_EV3 | ESCO_PKT_TYPES_MASK_NO_3_EV3 | \
-   ESCO_PKT_TYPES_MASK_NO_2_EV5 | ESCO_PKT_TYPES_MASK_NO_3_EV5)
+#define BTA_HF_CLIENT_NO_EDR_ESCO                                      \
+  (BTM_SCO_PKT_TYPES_MASK_NO_2_EV3 | BTM_SCO_PKT_TYPES_MASK_NO_3_EV3 | \
+   BTM_SCO_PKT_TYPES_MASK_NO_2_EV5 | BTM_SCO_PKT_TYPES_MASK_NO_3_EV5)
+
+static const tBTM_ESCO_PARAMS bta_hf_client_esco_params[] = {
+    /* SCO CVSD */
+    {
+        .rx_bw = BTM_64KBITS_RATE,
+        .tx_bw = BTM_64KBITS_RATE,
+        .max_latency = 10,
+        .voice_contfmt = BTM_VOICE_SETTING_CVSD,
+        .packet_types =
+            (BTM_SCO_LINK_ONLY_MASK | BTM_SCO_PKT_TYPES_MASK_NO_2_EV3 |
+             BTM_SCO_PKT_TYPES_MASK_NO_3_EV3 | BTM_SCO_PKT_TYPES_MASK_NO_2_EV5 |
+             BTM_SCO_PKT_TYPES_MASK_NO_3_EV5),
+        .retrans_effort = BTM_ESCO_RETRANS_POWER,
+    },
+    /* ESCO CVSD */
+    {
+        .rx_bw = BTM_64KBITS_RATE,
+        .tx_bw = BTM_64KBITS_RATE,
+        .max_latency = 10,
+        .voice_contfmt = BTM_VOICE_SETTING_CVSD,
+        /* Allow controller to use all types available except 5-slot EDR */
+        .packet_types =
+            (BTM_SCO_LINK_ALL_PKT_MASK | BTM_SCO_PKT_TYPES_MASK_NO_2_EV5 |
+             BTM_SCO_PKT_TYPES_MASK_NO_3_EV5),
+        .retrans_effort = BTM_ESCO_RETRANS_POWER,
+    },
+    /* ESCO mSBC */
+    {
+        .rx_bw = BTM_64KBITS_RATE,
+        .tx_bw = BTM_64KBITS_RATE,
+        .max_latency = 13,
+        .voice_contfmt = BTM_VOICE_SETTING_TRANS,
+        /* Packet Types : EV3 + 2-EV3               */
+        .packet_types =
+            (BTM_SCO_PKT_TYPES_MASK_EV3 | BTM_SCO_PKT_TYPES_MASK_NO_3_EV3 |
+             BTM_SCO_PKT_TYPES_MASK_NO_2_EV5 | BTM_SCO_PKT_TYPES_MASK_NO_3_EV5),
+        .retrans_effort = BTM_ESCO_RETRANS_QUALITY,
+    }};
 
 enum {
   BTA_HF_CLIENT_SCO_LISTEN_E,
@@ -102,14 +138,14 @@ void bta_hf_client_cback_sco(tBTA_HF_CLIENT_CB* client_cb, uint8_t event) {
  ******************************************************************************/
 static void bta_hf_client_sco_conn_rsp(tBTA_HF_CLIENT_CB* client_cb,
                                        tBTM_ESCO_CONN_REQ_EVT_DATA* p_data) {
-  enh_esco_params_t resp;
+  tBTM_ESCO_PARAMS resp;
   uint8_t hci_status = HCI_SUCCESS;
 
   APPL_TRACE_DEBUG("%s", __func__);
 
   if (client_cb->sco_state == BTA_HF_CLIENT_SCO_LISTEN_ST) {
     if (p_data->link_type == BTM_LINK_TYPE_SCO) {
-      resp = esco_parameters_for_codec(ESCO_CODEC_CVSD);
+      resp = bta_hf_client_esco_params[0];
     } else {
       if (client_cb->negotiated_codec == BTA_AG_CODEC_MSBC) {
         resp = esco_parameters_for_codec(ESCO_CODEC_MSBC_T1);
@@ -117,6 +153,7 @@ static void bta_hf_client_sco_conn_rsp(tBTA_HF_CLIENT_CB* client_cb,
         // default codec
         resp = esco_parameters_for_codec(ESCO_CODEC_CVSD);
       }
+      resp = bta_hf_client_esco_params[client_cb->negotiated_codec];
     }
 
     /* tell sys to stop av if any */
@@ -223,6 +260,8 @@ static void bta_hf_client_sco_disc_cback(uint16_t sco_idx) {
 static void bta_hf_client_sco_create(tBTA_HF_CLIENT_CB* client_cb,
                                      bool is_orig) {
   tBTM_STATUS status;
+  uint8_t* p_bd_addr = NULL;
+  tBTM_ESCO_PARAMS params;
 
   APPL_TRACE_DEBUG("%s: %d", __func__, is_orig);
 
@@ -234,10 +273,35 @@ static void bta_hf_client_sco_create(tBTA_HF_CLIENT_CB* client_cb,
   }
 
   enh_esco_params_t params = esco_parameters_for_codec(ESCO_CODEC_CVSD);
+  params = esco_parameters_for_codec(ESCO_CODEC_MSBC_T1);
 
   /* if initiating set current scb and peer bd addr */
   if (is_orig) {
     BTM_SetEScoMode(&params);
+  params = bta_hf_client_esco_params[1];
+
+  /* if initiating set current scb and peer bd addr */
+  if (is_orig) {
+    /* Attempt to use eSCO if remote host supports HFP >= 1.5 */
+    if (client_cb->peer_version >= HFP_VERSION_1_5 &&
+        !client_cb->retry_with_sco_only) {
+      BTM_SetEScoMode(BTM_LINK_TYPE_ESCO, &params);
+      /* If ESCO or EDR ESCO, retry with SCO only in case of failure */
+      if ((params.packet_types & BTM_ESCO_LINK_ONLY_MASK) ||
+          !((params.packet_types &
+             ~(BTM_ESCO_LINK_ONLY_MASK | BTM_SCO_LINK_ONLY_MASK)) ^
+            BTA_HF_CLIENT_NO_EDR_ESCO)) {
+        client_cb->retry_with_sco_only = true;
+        APPL_TRACE_API("Setting retry_with_sco_only to true");
+      }
+    } else {
+      if (client_cb->retry_with_sco_only)
+        APPL_TRACE_API("retrying with SCO only");
+      client_cb->retry_with_sco_only = false;
+
+      BTM_SetEScoMode(BTM_LINK_TYPE_SCO, &params);
+    }
+
     /* tell sys to stop av if any */
     bta_sys_sco_use(BTA_ID_HS, 1, client_cb->peer_addr);
   }
diff --git a/system/bt/bta/include/bta_ag_api.h b/system/bt/bta/include/bta_ag_api.h
index b968ae66b..178d81377 100644
--- a/system/bt/bta/include/bta_ag_api.h
+++ b/system/bt/bta/include/bta_ag_api.h
@@ -174,6 +174,7 @@ typedef uint16_t tBTA_AG_PEER_FEAT;
 
 /* HFP peer supported codec masks */
 // TODO(google) This should use common definitions
+// in hci/include/hci_audio.h
 #define BTA_AG_CODEC_NONE BTM_SCO_CODEC_NONE
 #define BTA_AG_CODEC_CVSD BTM_SCO_CODEC_CVSD /* CVSD */
 #define BTA_AG_CODEC_MSBC BTM_SCO_CODEC_MSBC /* mSBC */
@@ -301,7 +302,9 @@ struct tBTA_AG_RES_DATA {
 #define BTA_AG_MIC_EVT 8         /* Microphone volume changed */
 #define BTA_AG_AT_CKPD_EVT 9     /* CKPD from the HS */
 #define BTA_AG_DISABLE_EVT 30    /* AG disabled */
+#if (BTM_WBS_INCLUDED == TRUE)
 #define BTA_AG_WBS_EVT 31 /* SCO codec info */
+#endif
 /* Values below are for HFP only */
 #define BTA_AG_AT_A_EVT 10    /* Answer a call */
 #define BTA_AG_AT_D_EVT 11    /* Place a call using number or memory dial */
diff --git a/system/bt/bta/include/bta_ag_ci.h b/system/bt/bta/include/bta_ag_ci.h
new file mode 100644
index 000000000..01e387030
--- /dev/null
+++ b/system/bt/bta/include/bta_ag_ci.h
@@ -0,0 +1,70 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2003-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  This is the interface file for audio gateway call-in functions.
+ *
+ ******************************************************************************/
+#ifndef BTA_AG_CI_H
+#define BTA_AG_CI_H
+
+#include "bta_ag_api.h"
+
+/*****************************************************************************
+ *  Function Declarations
+ ****************************************************************************/
+/*******************************************************************************
+ *
+ * Function         bta_ag_ci_rx_write
+ *
+ * Description      This function is called to send data to the AG when the AG
+ *                  is configured for AT command pass-through.  The function
+ *                  copies data to an event buffer and sends it.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+extern void bta_ag_ci_rx_write(uint16_t handle, char* p_data, uint16_t len);
+
+/******************************************************************************
+ *
+ * Function         bta_ag_ci_slc_ready
+ *
+ * Description      This function is called to notify AG that SLC is up at
+ *                  the application. This funcion is only used when the app
+ *                  is running in pass-through mode.
+ *
+ * Returns          void
+ *
+ *****************************************************************************/
+extern void bta_ag_ci_slc_ready(uint16_t handle);
+
+/******************************************************************************
+ *
+ * Function         bta_ag_ci_wbs_command
+ *
+ * Description      This function is called to notify AG that a WBS command is
+ *                  received
+ *
+ * Returns          void
+ *
+ *****************************************************************************/
+extern void bta_ag_ci_wbs_command(uint16_t handle, char* p_data, uint16_t len);
+
+#endif /* BTA_AG_CI_H */
diff --git a/system/bt/bta/include/bta_ag_co.h b/system/bt/bta/include/bta_ag_co.h
new file mode 100644
index 000000000..60f6322c8
--- /dev/null
+++ b/system/bt/bta/include/bta_ag_co.h
@@ -0,0 +1,116 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2003-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  This is the interface file for audio gateway call-out functions.
+ *
+ ******************************************************************************/
+#ifndef BTA_AG_CO_H
+#define BTA_AG_CO_H
+
+#include "bta_ag_api.h"
+#include "hci/include/hci_audio.h"
+
+/*******************************************************************************
+ *
+ * Function         bta_ag_co_init
+ *
+ * Description      This callout function is executed by AG when it is
+ *                  started by calling BTA_AgEnable().  This function can be
+ *                  used by the phone to initialize audio paths or for other
+ *                  initialization purposes.
+ *
+ *
+ * Returns          Void.
+ *
+ ******************************************************************************/
+extern void bta_ag_co_init(void);
+
+/*******************************************************************************
+ *
+ * Function         bta_ag_co_audio_state
+ *
+ * Description      This function is called by the AG before the audio
+ *                  connection
+ *                  is brought up, after it comes up, and after it goes down.
+ *
+ * Parameters       handle - handle of the AG instance
+ *                  state - Audio state
+ *                  codec - if WBS support is compiled in, codec to going to be
+ *                          used is provided and when in SCO_STATE_SETUP,
+ *                          BTM_I2SPCMConfig() must be called with the correct
+ *                          platform parameters. In the other states, codec type
+ *                          should not be ignored
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+#if (BTM_WBS_INCLUDED == TRUE)
+extern void bta_ag_co_audio_state(uint16_t handle, uint8_t app_id,
+                                  uint8_t state, tBTA_AG_PEER_CODEC codec);
+
+#else
+extern void bta_ag_co_audio_state(uint16_t handle, uint8_t app_id,
+                                  uint8_t state);
+#endif
+
+/*******************************************************************************
+ *
+ * Function         bta_ag_co_data_open
+ *
+ * Description      This function is executed by AG when a service level
+ *                  connection
+ *                  is opened.  The phone can use this function to set
+ *                  up data paths or perform any required initialization or
+ *                  set up particular to the connected service.
+ *
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+extern void bta_ag_co_data_open(uint16_t handle, tBTA_SERVICE_ID service);
+
+/*******************************************************************************
+ *
+ * Function         bta_ag_co_data_close
+ *
+ * Description      This function is called by AG when a service level
+ *                  connection is closed
+ *
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+extern void bta_ag_co_data_close(uint16_t handle);
+
+/*******************************************************************************
+ *
+ * Function         bta_ag_co_tx_write
+ *
+ * Description      This function is called by the AG to send data to the
+ *                  phone when the AG is configured for AT command pass-through.
+ *                  The implementation of this function must copy the data to
+ *                  the phone's memory.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+extern void bta_ag_co_tx_write(uint16_t handle, uint8_t* p_data, uint16_t len);
+
+#endif /* BTA_AG_CO_H */
diff --git a/system/bt/bta/include/bta_dm_co.h b/system/bt/bta/include/bta_dm_co.h
index ddb9d2234..0426c1115 100644
--- a/system/bt/bta/include/bta_dm_co.h
+++ b/system/bt/bta/include/bta_dm_co.h
@@ -25,12 +25,26 @@
 #define BTA_DM_CO_H
 
 #include "bta_sys.h"
-#include "btm_api.h"
 
 #ifndef BTA_SCO_OUT_PKT_SIZE
 #define BTA_SCO_OUT_PKT_SIZE BTM_SCO_DATA_SIZE_MAX
 #endif
 
+#define BTA_SCO_CODEC_PCM 0 /* used for regular SCO */
+#define BTA_SCO_CODEC_SBC 1 /* used for WBS */
+typedef uint8_t tBTA_SCO_CODEC_TYPE;
+
+#define BTA_DM_SCO_SAMP_RATE_8K 8000
+#define BTA_DM_SCO_SAMP_RATE_16K 16000
+
+/* SCO codec information */
+typedef struct { tBTA_SCO_CODEC_TYPE codec_type; } tBTA_CODEC_INFO;
+
+#define BTA_DM_SCO_ROUTE_PCM BTM_SCO_ROUTE_PCM
+#define BTA_DM_SCO_ROUTE_HCI BTM_SCO_ROUTE_HCI
+
+typedef tBTM_SCO_ROUTE_TYPE tBTA_DM_SCO_ROUTE_TYPE;
+
 /*****************************************************************************
  *  Function Declarations
  ****************************************************************************/
@@ -121,6 +135,25 @@ extern void bta_dm_co_loc_oob(bool valid, BT_OCTET16 c, BT_OCTET16 r);
  ******************************************************************************/
 extern void bta_dm_co_rmt_oob(const RawAddress& bd_addr);
 
+/*****************************************************************************
+ *  SCO over HCI Function Declarations
+ ****************************************************************************/
+/*******************************************************************************
+ *
+ * Function         bta_dm_sco_co_init
+ *
+ * Description      This function can be used by the phone to initialize audio
+ *                  codec or for other initialization purposes before SCO
+ *                  connection is opened.
+ *
+ *
+ * Returns          Void.
+ *
+ ******************************************************************************/
+extern tBTA_DM_SCO_ROUTE_TYPE bta_dm_sco_co_init(uint32_t rx_bw, uint32_t tx_bw,
+                                                 tBTA_CODEC_INFO* p_codec_info,
+                                                 uint8_t app_id);
+
 /*******************************************************************************
  *
  * Function         bta_dm_sco_co_open
diff --git a/system/bt/bta/sys/bta_sys_main.cc b/system/bt/bta/sys/bta_sys_main.cc
index dda3977bc..9843ed7a3 100644
--- a/system/bt/bta/sys/bta_sys_main.cc
+++ b/system/bt/bta/sys/bta_sys_main.cc
@@ -455,7 +455,7 @@ void bta_sys_event(BT_HDR* p_msg) {
   uint8_t id;
   bool freebuf = true;
 
-  APPL_TRACE_EVENT("%s: Event 0x%x", __func__, p_msg->event);
+  APPL_TRACE_EVENT("BTA got event 0x%x", p_msg->event);
 
   /* get subsystem id from event */
   id = (uint8_t)(p_msg->event >> 8);
@@ -464,7 +464,7 @@ void bta_sys_event(BT_HDR* p_msg) {
   if ((id < BTA_ID_MAX) && (bta_sys_cb.reg[id] != NULL)) {
     freebuf = (*bta_sys_cb.reg[id]->evt_hdlr)(p_msg);
   } else {
-    APPL_TRACE_WARNING("%s: Received unregistered event id %d", __func__, id);
+    APPL_TRACE_WARNING("BTA got unregistered event id %d", id);
   }
 
   if (freebuf) {
diff --git a/system/bt/btif/Android.bp b/system/bt/btif/Android.bp
index 4b2dc3005..ce9a5d43c 100644
--- a/system/bt/btif/Android.bp
+++ b/system/bt/btif/Android.bp
@@ -8,6 +8,7 @@ btifCommonIncludes = [
     "system/bt/btcore/include",
     "system/bt/device/include",
     "system/bt/internal_include",
+    "system/bt/include",
     "system/bt/stack/include",
     "system/bt/stack/l2cap",
     "system/bt/stack/a2dp",
diff --git a/system/bt/btif/BUILD.gn b/system/bt/btif/BUILD.gn
index de50a97e3..d9f1ba1c6 100644
--- a/system/bt/btif/BUILD.gn
+++ b/system/bt/btif/BUILD.gn
@@ -82,7 +82,6 @@ static_library("btif") {
     "//bta/include",
     "//bta/sys",
     "//btcore/include",
-    "//device/include",
     "//embdrv/sbc/encoder/include",
     "//embdrv/sbc/decoder/include",
     "//hci/include",
diff --git a/system/bt/btif/co/bta_ag_co.cc b/system/bt/btif/co/bta_ag_co.cc
new file mode 100644
index 000000000..075c49297
--- /dev/null
+++ b/system/bt/btif/co/bta_ag_co.cc
@@ -0,0 +1,151 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2009-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "bt_btif_bta_ag"
+
+#include "bta/include/bta_ag_co.h"
+#include "bta/include/bta_ag_api.h"
+#include "hci/include/hci_audio.h"
+#include "osi/include/osi.h"
+
+/*******************************************************************************
+ *
+ * Function         bta_ag_co_init
+ *
+ * Description      This callout function is executed by AG when it is
+ *                  started by calling BTA_AgEnable().  This function can be
+ *                  used by the phone to initialize audio paths or for other
+ *                  initialization purposes.
+ *
+ *
+ * Returns          Void.
+ *
+ ******************************************************************************/
+void bta_ag_co_init(void) { BTM_WriteVoiceSettings(AG_VOICE_SETTINGS); }
+
+/*******************************************************************************
+ *
+ * Function         bta_ag_co_audio_state
+ *
+ * Description      This function is called by the AG before the audio
+ *                  connection is brought up, after it comes up, and
+ *                  after it goes down.
+ *
+ * Parameters       handle - handle of the AG instance
+ *                  state - Audio state
+ *                  codec - if WBS support is compiled in, codec to going to be
+ *                      used is provided and when in SCO_STATE_SETUP,
+ *                      BTM_I2SPCMConfig() must be called with the correct
+ *                      platform parameters.
+ *                      In the other states, codec type should not be ignored.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+#if (BTM_WBS_INCLUDED == TRUE)
+void bta_ag_co_audio_state(uint16_t handle, uint8_t app_id, uint8_t state,
+                           tBTA_AG_PEER_CODEC codec)
+#else
+void bta_ag_co_audio_state(uint16_t handle, uint8_t app_id, uint8_t state)
+#endif
+{
+  BTIF_TRACE_DEBUG("bta_ag_co_audio_state: handle %d, state %d", handle, state);
+  switch (state) {
+    case SCO_STATE_OFF:
+#if (BTM_WBS_INCLUDED == TRUE)
+      BTIF_TRACE_DEBUG(
+          "bta_ag_co_audio_state(handle %d)::Closed (OFF), codec: 0x%x", handle,
+          codec);
+      set_audio_state(handle, (sco_codec_t)codec, (sco_state_t)state);
+#else
+      BTIF_TRACE_DEBUG("bta_ag_co_audio_state(handle %d)::Closed (OFF)",
+                       handle);
+#endif
+      break;
+    case SCO_STATE_OFF_TRANSFER:
+      BTIF_TRACE_DEBUG("bta_ag_co_audio_state(handle %d)::Closed (XFERRING)",
+                       handle);
+      break;
+    case SCO_STATE_SETUP:
+#if (BTM_WBS_INCLUDED == TRUE)
+      set_audio_state(handle, (sco_codec_t)codec, (sco_state_t)state);
+#else
+      set_audio_state(handle, (sco_codec_t)BTA_AG_CODEC_CVSD,
+                      (sco_state_t)state);
+#endif
+      break;
+    default:
+      break;
+  }
+#if (BTM_WBS_INCLUDED == TRUE)
+  APPL_TRACE_DEBUG(
+      "bta_ag_co_audio_state(handle %d, app_id: %d, state %d, codec: 0x%x)",
+      handle, app_id, state, codec);
+#else
+  APPL_TRACE_DEBUG("bta_ag_co_audio_state(handle %d, app_id: %d, state %d)",
+                   handle, app_id, state);
+#endif
+}
+
+/*******************************************************************************
+ *
+ * Function         bta_ag_co_data_open
+ *
+ * Description      This function is executed by AG when a service level
+ *                  connection is opened.  The phone can use this function to
+ *                  set up data paths or perform any required initialization or
+ *                  set up particular to the connected service.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+void bta_ag_co_data_open(uint16_t handle, tBTA_SERVICE_ID service) {
+  BTIF_TRACE_DEBUG("bta_ag_co_data_open handle:%d service:%d", handle, service);
+}
+
+/*******************************************************************************
+ *
+ * Function         bta_ag_co_data_close
+ *
+ * Description      This function is called by AG when a service level
+ *                  connection is closed
+ *
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+void bta_ag_co_data_close(uint16_t handle) {
+  BTIF_TRACE_DEBUG("bta_ag_co_data_close handle:%d", handle);
+}
+
+/*******************************************************************************
+ **
+ ** Function         bta_ag_co_tx_write
+ **
+ ** Description      This function is called by the AG to send data to the
+ **                  phone when the AG is configured for AT command
+ **                  pass-through. The implementation of this function must copy
+ **                  the data to the phones memory.
+ **
+ ** Returns          void
+ **
+ ******************************************************************************/
+void bta_ag_co_tx_write(uint16_t handle, UNUSED_ATTR uint8_t* p_data,
+                        uint16_t len) {
+  BTIF_TRACE_DEBUG("bta_ag_co_tx_write: handle: %d, len: %d", handle, len);
+}
diff --git a/system/bt/btif/co/bta_dm_co.cc b/system/bt/btif/co/bta_dm_co.cc
index dfd512be1..eaf12cc59 100644
--- a/system/bt/btif/co/bta_dm_co.cc
+++ b/system/bt/btif/co/bta_dm_co.cc
@@ -165,6 +165,141 @@ void bta_dm_co_rmt_oob(const RawAddress& bd_addr) {
   bta_dm_ci_rmt_oob(result, bd_addr, p_c, p_r);
 }
 
+// REMOVE FOR BLUEDROID ?
+
+#if (BTM_SCO_HCI_INCLUDED == TRUE) && (BTM_SCO_INCLUDED == TRUE)
+
+/*******************************************************************************
+ *
+ * Function         btui_sco_codec_callback
+ *
+ * Description      Callback for btui codec.
+ *
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void btui_sco_codec_callback(uint16_t event, uint16_t sco_handle) {
+  bta_dm_sco_ci_data_ready(event, sco_handle);
+}
+/*******************************************************************************
+ *
+ * Function         bta_dm_sco_co_init
+ *
+ * Description      This function can be used by the phone to initialize audio
+ *                  codec or for other initialization purposes before SCO
+ *                  connection is opened.
+ *
+ *
+ * Returns          tBTA_DM_SCO_ROUTE_TYPE: SCO routing configuration type.
+ *
+ ******************************************************************************/
+tBTA_DM_SCO_ROUTE_TYPE bta_dm_sco_co_init(uint32_t rx_bw, uint32_t tx_bw,
+                                          tBTA_CODEC_INFO* p_codec_type,
+                                          uint8_t app_id) {
+  tBTM_SCO_ROUTE_TYPE route = BTA_DM_SCO_ROUTE_PCM;
+
+  BTIF_TRACE_DEBUG("bta_dm_sco_co_init");
+
+  /* set up SCO routing configuration if SCO over HCI app ID is used and run
+     time
+      configuration is set to SCO over HCI */
+  /* HS invoke this call-out */
+  if (
+#if (BTA_HS_INCLUDED == TRUE)
+      (app_id == BTUI_DM_SCO_4_HS_APP_ID && btui_cfg.hs_sco_over_hci) ||
+#endif
+      /* AG invoke this call-out */
+      (app_id != BTUI_DM_SCO_4_HS_APP_ID && btui_cfg.ag_sco_over_hci)) {
+    route = btui_cb.sco_hci = BTA_DM_SCO_ROUTE_HCI;
+  }
+  /* no codec is is used for the SCO data */
+  if (p_codec_type->codec_type == BTA_SCO_CODEC_PCM &&
+      route == BTA_DM_SCO_ROUTE_HCI) {
+    /* initialize SCO codec */
+    if (!btui_sco_codec_init(rx_bw, tx_bw)) {
+      BTIF_TRACE_ERROR("codec initialization exception!");
+    }
+  }
+
+  return route;
+}
+
+/*******************************************************************************
+ *
+ * Function         bta_dm_sco_co_open
+ *
+ * Description      This function is executed when a SCO connection is open.
+ *
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+void bta_dm_sco_co_open(uint16_t handle, uint8_t pkt_size, uint16_t event) {
+  tBTUI_SCO_CODEC_CFG cfg;
+
+  if (btui_cb.sco_hci) {
+    BTIF_TRACE_DEBUG("bta_dm_sco_co_open handle:%d pkt_size:%d", handle,
+                     pkt_size);
+    cfg.p_cback = btui_sco_codec_callback;
+    cfg.pkt_size = pkt_size;
+    cfg.cb_event = event;
+    /* open and start the codec */
+    btui_sco_codec_open(&cfg);
+    btui_sco_codec_start(handle);
+  }
+}
+
+/*******************************************************************************
+ *
+ * Function         bta_dm_sco_co_close
+ *
+ * Description      This function is called when a SCO connection is closed
+ *
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+void bta_dm_sco_co_close(void) {
+  if (btui_cb.sco_hci) {
+    BTIF_TRACE_DEBUG("bta_dm_sco_co_close close codec");
+    /* close sco codec */
+    btui_sco_codec_close();
+
+    btui_cb.sco_hci = false;
+  }
+}
+
+/*******************************************************************************
+ *
+ * Function         bta_dm_sco_co_in_data
+ *
+ * Description      This function is called to send incoming SCO data to
+ *                  application.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+void bta_dm_sco_co_in_data(BT_HDR* p_buf) {
+  if (btui_cfg.sco_use_mic)
+    btui_sco_codec_inqdata(p_buf);
+  else
+    osi_free(p_buf);
+}
+
+/*******************************************************************************
+ *
+ * Function         bta_dm_sco_co_out_data
+ *
+ * Description      This function is called to send SCO data over HCI.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+void bta_dm_sco_co_out_data(BT_HDR** p_buf) { btui_sco_codec_readbuf(p_buf); }
+
+#endif /* (BTM_SCO_HCI_INCLUDED == TRUE) && (BTM_SCO_INCLUDED == TRUE)*/
+
 /*******************************************************************************
  *
  * Function         bta_dm_co_le_io_key_req
diff --git a/system/bt/btif/src/btif_hf.cc b/system/bt/btif/src/btif_hf.cc
index 24656c290..c4c7edf4b 100644
--- a/system/bt/btif/src/btif_hf.cc
+++ b/system/bt/btif/src/btif_hf.cc
@@ -72,6 +72,7 @@ namespace headset {
 #define BTIF_HF_SECURITY (BTA_SEC_AUTHENTICATE | BTA_SEC_ENCRYPT)
 #endif
 
+#if (BTM_WBS_INCLUDED == TRUE)
 #ifndef BTIF_HF_FEATURES
 #define BTIF_HF_FEATURES                                       \
   (BTA_AG_FEAT_3WAY | BTA_AG_FEAT_ECNR | BTA_AG_FEAT_REJECT |  \
@@ -79,6 +80,14 @@ namespace headset {
    BTA_AG_FEAT_CODEC | BTA_AG_FEAT_HF_IND | BTA_AG_FEAT_ESCO | \
    BTA_AG_FEAT_UNAT)
 #endif
+#else
+#ifndef BTIF_HF_FEATURES
+#define BTIF_HF_FEATURES                                      \
+  (BTA_AG_FEAT_3WAY | BTA_AG_FEAT_ECNR | BTA_AG_FEAT_REJECT | \
+   BTA_AG_FEAT_ECS | BTA_AG_FEAT_EXTERR | BTA_AG_FEAT_VREC | \
+   BTA_AG_FEAT_HF_IND | BTA_AG_FEAT_ESCO | BTA_AG_FEAT_UNAT)
+#endif
+#endif
 
 /* HF features supported at runtime */
 static uint32_t btif_hf_features = BTIF_HF_FEATURES;
@@ -459,6 +468,7 @@ static void btif_hf_upstreams_evt(uint16_t event, char* p_param) {
       bt_hf_callbacks->KeyPressedCallback(&btif_hf_cb[idx].connected_bda);
       break;
 
+#if (BTM_WBS_INCLUDED == TRUE)
     case BTA_AG_WBS_EVT:
       BTIF_TRACE_DEBUG(
           "BTA_AG_WBS_EVT Set codec status %d codec %d 1=CVSD 2=MSBC",
@@ -474,7 +484,7 @@ static void btif_hf_upstreams_evt(uint16_t event, char* p_param) {
                                      &btif_hf_cb[idx].connected_bda);
       }
       break;
-
+#endif
     /* Java needs to send OK/ERROR for these commands */
     case BTA_AG_AT_CHLD_EVT:
       bt_hf_callbacks->AtChldCallback((bthf_chld_type_t)atoi(p_data->val.str),
@@ -506,13 +516,17 @@ static void btif_hf_upstreams_evt(uint16_t event, char* p_param) {
       break;
     case BTA_AG_AT_BAC_EVT:
       BTIF_TRACE_DEBUG("AG Bitmap of peer-codecs %d", p_data->val.num);
-      /* If the peer supports mSBC and the BTIF preferred codec is also mSBC,
+#if (BTM_WBS_INCLUDED == TRUE)
+      /* If the peer supports mSBC and the BTIF prefferred codec is also mSBC,
       then
       we should set the BTA AG Codec to mSBC. This would trigger a +BCS to mSBC
       at the time
       of SCO connection establishment */
       if ((btif_conf_hf_force_wbs) && (p_data->val.num & BTA_AG_CODEC_MSBC)) {
         BTIF_TRACE_EVENT("%s: btif_hf override-Preferred Codec to MSBC",
+      if ((btif_conf_hf_force_wbs == true) &&
+          (p_data->val.num & BTA_AG_CODEC_MSBC)) {
+        BTIF_TRACE_EVENT("%s btif_hf override-Preferred Codec to MSBC",
                          __func__);
         BTA_AgSetCodec(btif_hf_cb[idx].handle, BTA_AG_CODEC_MSBC);
       } else {
@@ -520,6 +534,7 @@ static void btif_hf_upstreams_evt(uint16_t event, char* p_param) {
                          __func__);
         BTA_AgSetCodec(btif_hf_cb[idx].handle, BTA_AG_CODEC_CVSD);
       }
+#endif
       break;
     case BTA_AG_AT_BCS_EVT:
       BTIF_TRACE_DEBUG("%s: AG final selected codec is 0x%02x 1=CVSD 2=MSBC",
@@ -528,6 +543,12 @@ static void btif_hf_upstreams_evt(uint16_t event, char* p_param) {
       /* Only CVSD is considered narrow band speech */
       bt_hf_callbacks->WbsCallback(
           (p_data->val.num == BTA_AG_CODEC_CVSD) ? BTHF_WBS_NO : BTHF_WBS_YES,
+      BTIF_TRACE_DEBUG("AG final seleded codec is %d 1=CVSD 2=MSBC",
+                       p_data->val.num);
+      /*  no BTHF_WBS_NONE case, becuase HF1.6 supported device can send BCS */
+      HAL_CBACK(
+          bt_hf_callbacks, wbs_cb,
+          (p_data->val.num == BTA_AG_CODEC_MSBC) ? BTHF_WBS_YES : BTHF_WBS_NO,
           &btif_hf_cb[idx].connected_bda);
       break;
 
@@ -1129,6 +1150,11 @@ bt_status_t HeadsetInterface::PhoneStateChange(
     // CIND response should have been updated.
     // just open SCO connection.
     if (call_setup_state != BTHF_CALL_STATE_IDLE) {
+    /* Addition call setup with the Active call
+    ** CIND response should have been updated.
+    ** just open SCO conenction.
+    */
+    if (call_setup_state != BTHF_CALL_STATE_IDLE)
       res = BTA_AG_MULTI_CALL_RES;
     } else {
       res = BTA_AG_OUT_CALL_CONN_RES;
diff --git a/system/bt/btif/src/btif_rc.cc b/system/bt/btif/src/btif_rc.cc
index c226b5f21..ce0a80d97 100644
--- a/system/bt/btif/src/btif_rc.cc
+++ b/system/bt/btif/src/btif_rc.cc
@@ -1096,6 +1096,10 @@ bool btif_rc_is_connected_peer(const RawAddress& peer_addr) {
     if (p_dev != NULL && (p_dev->rc_connected == TRUE) &&
         peer_addr == p_dev->rc_addr) {
       return true;
+    p_dev = get_connected_device(idx);
+    if (p_dev != NULL && (p_dev->rc_connected == TRUE)) {
+      bdcpy(peer_addr, p_dev->rc_addr);
+      return TRUE;
     }
   }
   return false;
diff --git a/system/bt/btif/src/btif_sock_sco.cc b/system/bt/btif/src/btif_sock_sco.cc
index 62831960c..4961dc83d 100644
--- a/system/bt/btif/src/btif_sock_sco.cc
+++ b/system/bt/btif/src/btif_sock_sco.cc
@@ -32,7 +32,6 @@
 #include <hardware/bt_sock.h>
 
 #include "btif_common.h"
-#include "device/include/esco_parameters.h"
 #include "osi/include/allocator.h"
 #include "osi/include/list.h"
 #include "osi/include/log.h"
@@ -64,6 +63,17 @@ typedef struct {
   bool connect_completed;
 } sco_socket_t;
 
+// TODO: verify packet types that are being sent OTA.
+static tBTM_ESCO_PARAMS sco_parameters = {
+    BTM_64KBITS_RATE, /* TX Bandwidth (64 kbits/sec)              */
+    BTM_64KBITS_RATE, /* RX Bandwidth (64 kbits/sec)              */
+    0x000a,           /* 10 ms (HS/HF can use EV3, 2-EV3, 3-EV3)  */
+    0x0060,           /* Inp Linear, Air CVSD, 2s Comp, 16bit     */
+    (BTM_SCO_LINK_ALL_PKT_MASK | BTM_SCO_PKT_TYPES_MASK_NO_2_EV5 |
+     BTM_SCO_PKT_TYPES_MASK_NO_3_EV5),
+    BTM_ESCO_RETRANS_POWER /* Retransmission effort                      */
+};
+
 static sco_socket_t* sco_socket_establish_locked(bool is_listening,
                                                  const RawAddress* bd_addr,
                                                  int* sock_fd);
@@ -90,8 +100,7 @@ bt_status_t btsock_sco_init(thread_t* thread_) {
   if (!sco_sockets) return BT_STATUS_FAIL;
 
   thread = thread_;
-  enh_esco_params_t params = esco_parameters_for_codec(ESCO_CODEC_CVSD);
-  BTM_SetEScoMode(&params);
+  BTM_SetEScoMode(BTM_LINK_TYPE_ESCO, &sco_parameters);
 
   return BT_STATUS_SUCCESS;
 }
@@ -136,7 +145,7 @@ static sco_socket_t* sco_socket_establish_locked(bool is_listening,
   sco_socket_t* sco_socket = NULL;
   socket_t* socket = NULL;
   tBTM_STATUS status;
-  enh_esco_params_t params;
+
   if (socketpair(AF_LOCAL, SOCK_STREAM, 0, pair) == -1) {
     LOG_ERROR(LOG_TAG, "%s unable to allocate socket pair: %s", __func__,
               strerror(errno));
@@ -153,6 +162,9 @@ static sco_socket_t* sco_socket_establish_locked(bool is_listening,
   status = BTM_CreateSco(bd_addr, !is_listening, params.packet_types,
                          &sco_socket->sco_handle, connect_completed_cb,
                          disconnect_completed_cb);
+  status = BTM_CreateSco((uint8_t*)bd_addr, !is_listening,
+                         sco_parameters.packet_types, &sco_socket->sco_handle,
+                         connect_completed_cb, disconnect_completed_cb);
   if (status != BTM_CMD_STARTED) {
     LOG_ERROR(LOG_TAG, "%s unable to create SCO socket: %d", __func__, status);
     goto error;
diff --git a/system/bt/btif/src/btif_util.cc b/system/bt/btif/src/btif_util.cc
index 26d84fd65..a7c849a8f 100644
--- a/system/bt/btif/src/btif_util.cc
+++ b/system/bt/btif/src/btif_util.cc
@@ -189,7 +189,9 @@ const char* dump_hf_event(uint16_t event) {
     CASE_RETURN_STR(BTA_AG_MIC_EVT)
     CASE_RETURN_STR(BTA_AG_AT_CKPD_EVT)
     CASE_RETURN_STR(BTA_AG_DISABLE_EVT)
+#if (BTM_WBS_INCLUDED == TRUE)
     CASE_RETURN_STR(BTA_AG_WBS_EVT)
+#endif
     CASE_RETURN_STR(BTA_AG_AT_A_EVT)
     CASE_RETURN_STR(BTA_AG_AT_D_EVT)
     CASE_RETURN_STR(BTA_AG_AT_CHLD_EVT)
diff --git a/system/bt/device/Android.bp b/system/bt/device/Android.bp
index 0b7cda7a9..6a8b9b5c5 100644
--- a/system/bt/device/Android.bp
+++ b/system/bt/device/Android.bp
@@ -16,7 +16,6 @@ cc_library_static {
     ],
     srcs: [
         "src/controller.cc",
-        "src/esco_parameters.cc",
         "src/interop.cc",
     ],
     shared_libs: [
diff --git a/system/bt/device/BUILD.gn b/system/bt/device/BUILD.gn
index 5de439d30..ace5e5e28 100644
--- a/system/bt/device/BUILD.gn
+++ b/system/bt/device/BUILD.gn
@@ -17,7 +17,6 @@
 static_library("device") {
   sources = [
     "src/controller.cc",
-    "src/esco_parameters.cc",
     "src/interop.cc",
   ]
 
diff --git a/system/bt/device/include/controller.h b/system/bt/device/include/controller.h
index f1c85aa3f..39ce025f3 100644
--- a/system/bt/device/include/controller.h
+++ b/system/bt/device/include/controller.h
@@ -48,8 +48,6 @@ typedef struct controller_t {
   bool (*supports_rssi_with_inquiry_results)(void);
   bool (*supports_extended_inquiry_response)(void);
   bool (*supports_master_slave_role_switch)(void);
-  bool (*supports_enhanced_setup_synchronous_connection)(void);
-  bool (*supports_enhanced_accept_synchronous_connection)(void);
 
   bool (*supports_ble)(void);
   bool (*supports_ble_packet_extension)(void);
diff --git a/system/bt/device/include/esco_parameters.h b/system/bt/device/include/esco_parameters.h
index b79948d00..1cf626d3e 100644
--- a/system/bt/device/include/esco_parameters.h
+++ b/system/bt/device/include/esco_parameters.h
@@ -20,15 +20,6 @@
 
 #include <stdint.h>
 
-/*******************
- * SCO Codec Types
- *******************/
-typedef enum {
-  SCO_CODEC_NONE = 0x0000,
-  SCO_CODEC_CVSD = 0x0001,
-  SCO_CODEC_MSBC = 0x0002,
-} sco_codec_t;
-
 typedef enum {
   ESCO_CODEC_CVSD = 0,
   ESCO_CODEC_MSBC_T1,
@@ -131,7 +122,10 @@ typedef struct {
   esco_packet_types_t packet_types; /* Packet Types */
   esco_retransmission_effort_t
       retransmission_effort; /* 0x00-0x02, 0xFF don't care */
-} enh_esco_params_t;
+} enhanced_esco_parameters_t;
+
+typedef esco_coding_id_format_t esco_coding_id_format_t;
+typedef enhanced_esco_parameters_t enh_esco_params_t;
 
 // Get the enhanced eSCO configuration parameters for the provided |codec|
 enh_esco_params_t esco_parameters_for_codec(esco_codec_t codec);
diff --git a/system/bt/device/src/controller.cc b/system/bt/device/src/controller.cc
index 1480951f8..6f128c72e 100644
--- a/system/bt/device/src/controller.cc
+++ b/system/bt/device/src/controller.cc
@@ -378,16 +378,6 @@ static bool supports_master_slave_role_switch(void) {
   return HCI_SWITCH_SUPPORTED(features_classic[0].as_array);
 }
 
-static bool supports_enhanced_setup_synchronous_connection(void) {
-  assert(readable);
-  return HCI_ENH_SETUP_SYNCH_CONN_SUPPORTED(supported_commands);
-}
-
-static bool supports_enhanced_accept_synchronous_connection(void) {
-  assert(readable);
-  return HCI_ENH_ACCEPT_SYNCH_CONN_SUPPORTED(supported_commands);
-}
-
 static bool supports_ble(void) {
   CHECK(readable);
   return ble_supported;
@@ -554,8 +544,6 @@ static const controller_t interface = {
     supports_rssi_with_inquiry_results,
     supports_extended_inquiry_response,
     supports_master_slave_role_switch,
-    supports_enhanced_setup_synchronous_connection,
-    supports_enhanced_accept_synchronous_connection,
 
     supports_ble,
     supports_ble_packet_extension,
diff --git a/system/bt/device/src/esco_parameters.cc b/system/bt/device/src/esco_parameters.cc
index 7f550a142..69d8430b8 100644
--- a/system/bt/device/src/esco_parameters.cc
+++ b/system/bt/device/src/esco_parameters.cc
@@ -140,8 +140,6 @@ static const enh_esco_params_t default_esco_parameters[ESCO_NUM_CODECS] = {
      .retransmission_effort = ESCO_RETRANSMISSION_QUALITY}};
 
 enh_esco_params_t esco_parameters_for_codec(esco_codec_t codec) {
-  CHECK(codec >= 0) << "codec index " << (int)codec << "< 0";
-  CHECK(codec < ESCO_NUM_CODECS) << "codec index " << (int)codec << " > "
-                                 << ESCO_NUM_CODECS;
+  CHECK(codec >= 0 && codec < ESCO_NUM_CODECS);
   return default_esco_parameters[codec];
 }
diff --git a/system/bt/hci/Android.bp b/system/bt/hci/Android.bp
index 635d939e3..ff61e8fc5 100644
--- a/system/bt/hci/Android.bp
+++ b/system/bt/hci/Android.bp
@@ -19,6 +19,7 @@ cc_library_static {
         "src/btsnoop_mem.cc",
         "src/btsnoop_net.cc",
         "src/buffer_allocator.cc",
+        "src/hci_audio.cc",
         "src/hci_inject.cc",
         "src/hci_layer.cc",
         "src/hci_layer_android.cc",
diff --git a/system/bt/hci/BUILD.gn b/system/bt/hci/BUILD.gn
index fc9c2ce02..a73cc6150 100644
--- a/system/bt/hci/BUILD.gn
+++ b/system/bt/hci/BUILD.gn
@@ -20,6 +20,7 @@ static_library("hci") {
     "src/btsnoop_mem.cc",
     "src/btsnoop_net.cc",
     "src/buffer_allocator.cc",
+    "src/hci_audio.cc",
     "src/hci_inject.cc",
     "src/hci_layer.cc",
     "src/hci_layer_linux.cc",
diff --git a/system/bt/hci/include/bt_vendor_lib.h b/system/bt/hci/include/bt_vendor_lib.h
index a274af777..cad6ee53b 100644
--- a/system/bt/hci/include/bt_vendor_lib.h
+++ b/system/bt/hci/include/bt_vendor_lib.h
@@ -19,7 +19,6 @@
 #ifndef BT_VENDOR_LIB_H
 #define BT_VENDOR_LIB_H
 
-#include <stdbool.h>
 #include <stdint.h>
 #include <sys/cdefs.h>
 #include <sys/types.h>
@@ -241,7 +240,6 @@ typedef struct {
   uint16_t handle;
   uint16_t peer_codec;
   uint16_t state;
-  bool use_enhanced_sco;
 } bt_vendor_op_audio_state_t;
 
 /*
diff --git a/system/bt/hci/include/hci_audio.h b/system/bt/hci/include/hci_audio.h
new file mode 100644
index 000000000..3ca019c7a
--- /dev/null
+++ b/system/bt/hci/include/hci_audio.h
@@ -0,0 +1,40 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2015 Google, Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+
+#include <stdint.h>
+
+// Audio state definitions.
+typedef enum {
+  SCO_STATE_OFF = 0,       // Audio is off.
+  SCO_STATE_OFF_TRANSFER,  // Closed pending final transfer of audio.
+  SCO_STATE_ON,            // Audio is on.
+  SCO_STATE_SETUP,         // Open pending completion of audio setup.
+} sco_state_t;
+
+// Codec type definitions.
+typedef enum {
+  SCO_CODEC_NONE = 0x0000,
+  SCO_CODEC_CVSD = 0x0001,
+  SCO_CODEC_MSBC = 0x0002,
+} sco_codec_t;
+
+// Set the audio state on the controller for SCO (PCM, WBS, ...) using the
+// vendor library.
+void set_audio_state(uint16_t handle, sco_codec_t codec, sco_state_t state);
diff --git a/system/bt/hci/src/hci_audio.cc b/system/bt/hci/src/hci_audio.cc
new file mode 100644
index 000000000..30eb25961
--- /dev/null
+++ b/system/bt/hci/src/hci_audio.cc
@@ -0,0 +1,38 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2015 Google, Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "bt_hci_audio"
+
+#include "hci/include/hci_audio.h"
+
+#include "hci/include/bt_vendor_lib.h"
+#include "osi/include/log.h"
+
+void set_audio_state(uint16_t handle, sco_codec_t codec, sco_state_t state) {
+  /*
+  TODO(eisenbach): [HIDL] Re-implement using VSC
+
+    bt_vendor_op_audio_state_t audio_state;
+
+    audio_state.handle = handle;
+    audio_state.peer_codec = codec;
+    audio_state.state = state;
+
+    vendor_get_interface()->send_command(VENDOR_SET_AUDIO_STATE, &audio_state);
+  */
+}
diff --git a/system/bt/internal_include/bt_target.h b/system/bt/internal_include/bt_target.h
index 3de5510d3..06f92108c 100644
--- a/system/bt/internal_include/bt_target.h
+++ b/system/bt/internal_include/bt_target.h
@@ -92,10 +92,10 @@
 #endif
 
 #ifndef BTA_AG_SCO_PKT_TYPES
-#define BTA_AG_SCO_PKT_TYPES                                     \
-  (BTM_SCO_LINK_ONLY_MASK | ESCO_PKT_TYPES_MASK_EV3 |            \
-   ESCO_PKT_TYPES_MASK_NO_3_EV3 | ESCO_PKT_TYPES_MASK_NO_2_EV5 | \
-   ESCO_PKT_TYPES_MASK_NO_3_EV5)
+#define BTA_AG_SCO_PKT_TYPES                                           \
+  (BTM_SCO_LINK_ONLY_MASK | BTM_SCO_PKT_TYPES_MASK_EV3 |               \
+   BTM_SCO_PKT_TYPES_MASK_NO_3_EV3 | BTM_SCO_PKT_TYPES_MASK_NO_2_EV5 | \
+   BTM_SCO_PKT_TYPES_MASK_NO_3_EV5)
 #endif
 
 #ifndef BTA_AV_RET_TOUT
@@ -280,6 +280,19 @@
 #define BTM_SCO_INCLUDED TRUE /* TRUE includes SCO code */
 #endif
 
+/* Includes SCO if TRUE */
+#ifndef BTM_SCO_HCI_INCLUDED
+#define BTM_SCO_HCI_INCLUDED FALSE /* TRUE includes SCO over HCI code */
+#endif
+
+/* Includes WBS if TRUE */
+// TODO(eisenbch): Temporarily disable WBS; to be replaced with proper eSCO
+// setup
+#ifdef BTM_WBS_INCLUDED
+#undef BTM_WBS_INCLUDED
+#endif
+#define BTM_WBS_INCLUDED FALSE /* TRUE includes WBS code */
+
 /*  This is used to work around a controller bug that doesn't like Disconnect
  *  issued while there is a role switch in progress
 */
diff --git a/system/bt/stack/btm/btm_devctl.cc b/system/bt/stack/btm/btm_devctl.cc
index 2e425aa8a..41b6d76b6 100644
--- a/system/bt/stack/btm/btm_devctl.cc
+++ b/system/bt/stack/btm/btm_devctl.cc
@@ -99,9 +99,9 @@ void btm_dev_init(void) {
       BTM_ACL_PKT_TYPES_MASK_DH5 + BTM_ACL_PKT_TYPES_MASK_DM5;
 
   btm_cb.btm_sco_pkt_types_supported =
-      ESCO_PKT_TYPES_MASK_HV1 + ESCO_PKT_TYPES_MASK_HV2 +
-      ESCO_PKT_TYPES_MASK_HV3 + ESCO_PKT_TYPES_MASK_EV3 +
-      ESCO_PKT_TYPES_MASK_EV4 + ESCO_PKT_TYPES_MASK_EV5;
+      BTM_SCO_PKT_TYPES_MASK_HV1 + BTM_SCO_PKT_TYPES_MASK_HV2 +
+      BTM_SCO_PKT_TYPES_MASK_HV3 + BTM_SCO_PKT_TYPES_MASK_EV3 +
+      BTM_SCO_PKT_TYPES_MASK_EV4 + BTM_SCO_PKT_TYPES_MASK_EV5;
 }
 
 /*******************************************************************************
@@ -324,43 +324,49 @@ static void btm_decode_ext_features_page(uint8_t page_number,
       btm_cb.sco_cb.esco_supported = false;
 #endif
       if (HCI_SCO_LINK_SUPPORTED(p_features)) {
-        btm_cb.btm_sco_pkt_types_supported = ESCO_PKT_TYPES_MASK_HV1;
+        btm_cb.btm_sco_pkt_types_supported = BTM_SCO_PKT_TYPES_MASK_HV1;
 
         if (HCI_HV2_PACKETS_SUPPORTED(p_features))
-          btm_cb.btm_sco_pkt_types_supported |= ESCO_PKT_TYPES_MASK_HV2;
+          btm_cb.btm_sco_pkt_types_supported |= BTM_SCO_PKT_TYPES_MASK_HV2;
 
         if (HCI_HV3_PACKETS_SUPPORTED(p_features))
-          btm_cb.btm_sco_pkt_types_supported |= ESCO_PKT_TYPES_MASK_HV3;
+          btm_cb.btm_sco_pkt_types_supported |= BTM_SCO_PKT_TYPES_MASK_HV3;
       }
 
       if (HCI_ESCO_EV3_SUPPORTED(p_features))
-        btm_cb.btm_sco_pkt_types_supported |= ESCO_PKT_TYPES_MASK_EV3;
+        btm_cb.btm_sco_pkt_types_supported |= BTM_SCO_PKT_TYPES_MASK_EV3;
 
       if (HCI_ESCO_EV4_SUPPORTED(p_features))
-        btm_cb.btm_sco_pkt_types_supported |= ESCO_PKT_TYPES_MASK_EV4;
+        btm_cb.btm_sco_pkt_types_supported |= BTM_SCO_PKT_TYPES_MASK_EV4;
 
       if (HCI_ESCO_EV5_SUPPORTED(p_features))
-        btm_cb.btm_sco_pkt_types_supported |= ESCO_PKT_TYPES_MASK_EV5;
+        btm_cb.btm_sco_pkt_types_supported |= BTM_SCO_PKT_TYPES_MASK_EV5;
+#if (BTM_SCO_INCLUDED == TRUE)
       if (btm_cb.btm_sco_pkt_types_supported & BTM_ESCO_LINK_ONLY_MASK) {
         btm_cb.sco_cb.esco_supported = true;
 
         /* Add in EDR related eSCO types */
         if (HCI_EDR_ESCO_2MPS_SUPPORTED(p_features)) {
           if (!HCI_3_SLOT_EDR_ESCO_SUPPORTED(p_features))
-            btm_cb.btm_sco_pkt_types_supported |= ESCO_PKT_TYPES_MASK_NO_2_EV5;
+            btm_cb.btm_sco_pkt_types_supported |=
+                BTM_SCO_PKT_TYPES_MASK_NO_2_EV5;
         } else {
           btm_cb.btm_sco_pkt_types_supported |=
-              (ESCO_PKT_TYPES_MASK_NO_2_EV3 + ESCO_PKT_TYPES_MASK_NO_2_EV5);
+              (BTM_SCO_PKT_TYPES_MASK_NO_2_EV3 +
+               BTM_SCO_PKT_TYPES_MASK_NO_2_EV5);
         }
 
         if (HCI_EDR_ESCO_3MPS_SUPPORTED(p_features)) {
           if (!HCI_3_SLOT_EDR_ESCO_SUPPORTED(p_features))
-            btm_cb.btm_sco_pkt_types_supported |= ESCO_PKT_TYPES_MASK_NO_3_EV5;
+            btm_cb.btm_sco_pkt_types_supported |=
+                BTM_SCO_PKT_TYPES_MASK_NO_3_EV5;
         } else {
           btm_cb.btm_sco_pkt_types_supported |=
-              (ESCO_PKT_TYPES_MASK_NO_3_EV3 + ESCO_PKT_TYPES_MASK_NO_3_EV5);
+              (BTM_SCO_PKT_TYPES_MASK_NO_3_EV3 +
+               BTM_SCO_PKT_TYPES_MASK_NO_3_EV5);
         }
       }
+#endif
 
       BTM_TRACE_DEBUG("Local supported SCO packet types: 0x%04x",
                       btm_cb.btm_sco_pkt_types_supported);
diff --git a/system/bt/stack/btm/btm_int.h b/system/bt/stack/btm/btm_int.h
index 21f7ce3e1..094569b37 100644
--- a/system/bt/stack/btm/btm_int.h
+++ b/system/bt/stack/btm/btm_int.h
@@ -35,8 +35,6 @@
 #include "rfcdefs.h"
 
 #include "btm_api.h"
-#include "device/include/esco_parameters.h"
-
 #include "btm_ble_int.h"
 #include "btm_int_types.h"
 #include "smp_api.h"
@@ -170,7 +168,7 @@ extern bool btm_is_sco_active(uint16_t handle);
 extern void btm_remove_sco_links(const RawAddress& bda);
 extern bool btm_is_sco_active_by_bdaddr(const RawAddress& remote_bda);
 
-extern void btm_read_def_esco_mode(enh_esco_params_t* p_parms);
+extern tBTM_SCO_TYPE btm_read_def_esco_mode(tBTM_ESCO_PARAMS* p_parms);
 extern uint16_t btm_find_scb_by_handle(uint16_t handle);
 extern void btm_sco_flush_sco_data(uint16_t sco_inx);
 
diff --git a/system/bt/stack/btm/btm_int_types.h b/system/bt/stack/btm/btm_int_types.h
index 8f91cef45..1d6b87eb4 100644
--- a/system/bt/stack/btm/btm_int_types.h
+++ b/system/bt/stack/btm/btm_int_types.h
@@ -317,8 +317,9 @@ typedef void(tBTM_SCO_IND_CBACK)(uint16_t sco_inx);
   (HCI_PKT_TYPES_MASK_HV1 | HCI_PKT_TYPES_MASK_HV2 | HCI_PKT_TYPES_MASK_HV3)
 
 /* Mask defining only the SCO types of an esco packet type */
-#define BTM_ESCO_PKT_TYPE_MASK \
-  (ESCO_PKT_TYPES_MASK_HV1 | ESCO_PKT_TYPES_MASK_HV2 | ESCO_PKT_TYPES_MASK_HV3)
+#define BTM_ESCO_PKT_TYPE_MASK                                 \
+  (HCI_ESCO_PKT_TYPES_MASK_HV1 | HCI_ESCO_PKT_TYPES_MASK_HV2 | \
+   HCI_ESCO_PKT_TYPES_MASK_HV3)
 
 #define BTM_SCO_2_ESCO(scotype) \
   ((uint16_t)(((scotype)&BTM_SCO_PKT_TYPE_MASK) >> 5))
@@ -327,21 +328,21 @@ typedef void(tBTM_SCO_IND_CBACK)(uint16_t sco_inx);
 
 /* Define masks for supported and exception 2.0 SCO packet types
 */
-#define BTM_SCO_SUPPORTED_PKTS_MASK                    \
-  (ESCO_PKT_TYPES_MASK_HV1 | ESCO_PKT_TYPES_MASK_HV2 | \
-   ESCO_PKT_TYPES_MASK_HV3 | ESCO_PKT_TYPES_MASK_EV3 | \
-   ESCO_PKT_TYPES_MASK_EV4 | ESCO_PKT_TYPES_MASK_EV5)
+#define BTM_SCO_SUPPORTED_PKTS_MASK                            \
+  (HCI_ESCO_PKT_TYPES_MASK_HV1 | HCI_ESCO_PKT_TYPES_MASK_HV2 | \
+   HCI_ESCO_PKT_TYPES_MASK_HV3 | HCI_ESCO_PKT_TYPES_MASK_EV3 | \
+   HCI_ESCO_PKT_TYPES_MASK_EV4 | HCI_ESCO_PKT_TYPES_MASK_EV5)
 
-#define BTM_SCO_EXCEPTION_PKTS_MASK                              \
-  (ESCO_PKT_TYPES_MASK_NO_2_EV3 | ESCO_PKT_TYPES_MASK_NO_3_EV3 | \
-   ESCO_PKT_TYPES_MASK_NO_2_EV5 | ESCO_PKT_TYPES_MASK_NO_3_EV5)
+#define BTM_SCO_EXCEPTION_PKTS_MASK                                      \
+  (HCI_ESCO_PKT_TYPES_MASK_NO_2_EV3 | HCI_ESCO_PKT_TYPES_MASK_NO_3_EV3 | \
+   HCI_ESCO_PKT_TYPES_MASK_NO_2_EV5 | HCI_ESCO_PKT_TYPES_MASK_NO_3_EV5)
 
 #define BTM_SCO_ROUTE_UNKNOWN 0xff
 
 /* Define the structure that contains (e)SCO data */
 typedef struct {
   tBTM_ESCO_CBACK* p_esco_cback; /* Callback for eSCO events     */
-  enh_esco_params_t setup;
+  tBTM_ESCO_PARAMS setup;
   tBTM_ESCO_DATA data; /* Connection complete information */
   uint8_t hci_status;
 } tBTM_ESCO_INFO;
@@ -362,16 +363,28 @@ typedef struct {
 /* SCO Management control block */
 typedef struct {
   tBTM_SCO_IND_CBACK* app_sco_ind_cb;
+#if (BTM_SCO_HCI_INCLUDED == TRUE)
+  tBTM_SCO_DATA_CB* p_data_cb; /* Callback for SCO data over HCI */
+  uint32_t xmit_window_size;   /* Total SCO window in bytes  */
+#endif
   tSCO_CONN sco_db[BTM_MAX_SCO_LINKS];
-  enh_esco_params_t def_esco_parms;
+  tBTM_ESCO_PARAMS def_esco_parms;
+  BD_ADDR xfer_addr;
   uint16_t sco_disc_reason;
-  bool esco_supported;        /* true if 1.2 cntlr AND supports eSCO links */
-  esco_data_path_t sco_route; /* HCI, PCM, or TEST */
+  bool esco_supported; /* true if 1.2 cntlr AND supports eSCO links */
+  tBTM_SCO_TYPE desired_sco_mode;
+  tBTM_SCO_TYPE xfer_sco_type;
+  tBTM_SCO_PCM_PARAM sco_pcm_param;
+  tBTM_SCO_CODEC_TYPE codec_in_use; /* None, CVSD, MSBC, etc. */
+#if (BTM_SCO_HCI_INCLUDED == TRUE)
+  tBTM_SCO_ROUTE_TYPE sco_path;
+#endif
+
 } tSCO_CB;
 
 #if (BTM_SCO_INCLUDED == TRUE)
 extern void btm_set_sco_ind_cback(tBTM_SCO_IND_CBACK* sco_ind_cb);
-extern void btm_accept_sco_link(uint16_t sco_inx, enh_esco_params_t* p_setup,
+extern void btm_accept_sco_link(uint16_t sco_inx, tBTM_ESCO_PARAMS* p_setup,
                                 tBTM_SCO_CB* p_conn_cb, tBTM_SCO_CB* p_disc_cb);
 extern void btm_reject_sco_link(uint16_t sco_inx);
 extern void btm_sco_chk_pend_rolechange(uint16_t hci_handle);
diff --git a/system/bt/stack/btm/btm_sco.cc b/system/bt/stack/btm/btm_sco.cc
index 6e7f97ce6..7d37ba075 100644
--- a/system/bt/stack/btm/btm_sco.cc
+++ b/system/bt/stack/btm/btm_sco.cc
@@ -35,7 +35,6 @@
 #include "btm_int_types.h"
 #include "btu.h"
 #include "device/include/controller.h"
-#include "device/include/esco_parameters.h"
 #include "hcidefs.h"
 #include "hcimsgs.h"
 #include "osi/include/osi.h"
@@ -60,7 +59,17 @@
 /*            L O C A L    F U N C T I O N     P R O T O T Y P E S            */
 /******************************************************************************/
 
-static uint16_t btm_sco_voice_settings_to_legacy(enh_esco_params_t* p_parms);
+static const tBTM_ESCO_PARAMS btm_esco_defaults = {
+    BTM_64KBITS_RATE,             /* TX Bandwidth (64 kbits/sec)              */
+    BTM_64KBITS_RATE,             /* RX Bandwidth (64 kbits/sec)              */
+    0x000c,                       /* 12 ms (HS/HF can use EV3, 2-EV3, 3-EV3)  */
+    0x0060,                       /* Inp Linear, Air CVSD, 2s Comp, 16bit     */
+    (BTM_SCO_PKT_TYPES_MASK_HV1 + /* Packet Types                             */
+     BTM_SCO_PKT_TYPES_MASK_HV2 + BTM_SCO_PKT_TYPES_MASK_HV3 +
+     BTM_SCO_PKT_TYPES_MASK_EV3 + BTM_SCO_PKT_TYPES_MASK_EV4 +
+     BTM_SCO_PKT_TYPES_MASK_EV5),
+    BTM_ESCO_RETRANS_QUALITY /* Retransmission Effort */
+};
 
 /*******************************************************************************
  *
@@ -84,11 +93,17 @@ void btm_sco_flush_sco_data(UNUSED_ATTR uint16_t sco_inx) {}
  *
  ******************************************************************************/
 void btm_sco_init(void) {
+#if (BTM_SCO_HCI_INCLUDED == TRUE)
+  for (int i = 0; i < BTM_MAX_SCO_LINKS; i++)
+    btm_cb.sco_cb.sco_db[i].xmit_data_q = fixed_queue_new(SIZE_MAX);
+#endif
+
   /* Initialize nonzero defaults */
   btm_cb.sco_cb.sco_disc_reason = BTM_INVALID_SCO_DISC_REASON;
-  btm_cb.sco_cb.def_esco_parms = esco_parameters_for_codec(ESCO_CODEC_CVSD);
-  btm_cb.sco_cb.def_esco_parms.max_latency_ms = 12;
-  btm_cb.sco_cb.sco_route = ESCO_DATA_PATH_PCM;
+
+  btm_cb.sco_cb.def_esco_parms =
+      btm_esco_defaults; /* Initialize with defaults */
+  btm_cb.sco_cb.desired_sco_mode = BTM_DEFAULT_SCO_MODE;
 }
 
 /*******************************************************************************
@@ -110,8 +125,12 @@ void btm_sco_init(void) {
 static void btm_esco_conn_rsp(uint16_t sco_inx, uint8_t hci_status,
                               const RawAddress& bda,
                               enh_esco_params_t* p_parms) {
+static void btm_esco_conn_rsp(uint16_t sco_inx, uint8_t hci_status, BD_ADDR bda,
+                              tBTM_ESCO_PARAMS* p_parms) {
 #if (BTM_MAX_SCO_LINKS > 0)
   tSCO_CONN* p_sco = NULL;
+  tBTM_ESCO_PARAMS* p_setup;
+  uint16_t temp_pkt_types;
 
   if (sco_inx < BTM_MAX_SCO_LINKS) p_sco = &btm_cb.sco_cb.sco_db[sco_inx];
 
@@ -121,72 +140,52 @@ static void btm_esco_conn_rsp(uint16_t sco_inx, uint8_t hci_status,
       p_sco->state = (p_sco->state == SCO_ST_W4_CONN_RSP) ? SCO_ST_LISTENING
                                                           : SCO_ST_UNUSED;
     }
+
     if (!btm_cb.sco_cb.esco_supported) {
       btsnd_hcic_reject_conn(bda, hci_status);
     } else {
       btsnd_hcic_reject_esco_conn(bda, hci_status);
     }
-  } else {
-    /* Connection is being accepted */
+  } else /* Connection is being accepted */
+  {
     p_sco->state = SCO_ST_CONNECTING;
-    enh_esco_params_t* p_setup = &p_sco->esco.setup;
+    p_setup = &p_sco->esco.setup;
     /* If parameters not specified use the default */
-    if (p_parms) {
+    if (p_parms)
       *p_setup = *p_parms;
-    } else {
-      /* Use the last setup passed thru BTM_SetEscoMode (or defaults) */
+    else /* Use the last setup passed thru BTM_SetEscoMode (or defaults) */
+    {
       *p_setup = btm_cb.sco_cb.def_esco_parms;
     }
 
-    uint16_t temp_packet_types =
-        (p_setup->packet_types & BTM_SCO_SUPPORTED_PKTS_MASK &
-         btm_cb.btm_sco_pkt_types_supported);
+    temp_pkt_types = (p_setup->packet_types & BTM_SCO_SUPPORTED_PKTS_MASK &
+                      btm_cb.btm_sco_pkt_types_supported);
 
     /* Make sure at least one eSCO packet type is sent, else might confuse peer
      */
     /* Taking this out to confirm with BQB tests
     ** Real application would like to include this though, as many devices
     ** do not retry with SCO only if an eSCO connection fails.
-    if (!(temp_packet_types & BTM_ESCO_LINK_ONLY_MASK))
+    if (!(temp_pkt_types & BTM_ESCO_LINK_ONLY_MASK))
     {
-        temp_packet_types |= BTM_SCO_PKT_TYPES_MASK_EV3;
+        temp_pkt_types |= BTM_SCO_PKT_TYPES_MASK_EV3;
     }
     */
     /* If SCO request, remove eSCO packet types (conformance) */
     if (p_sco->esco.data.link_type == BTM_LINK_TYPE_SCO) {
-      temp_packet_types &= BTM_SCO_LINK_ONLY_MASK;
-      temp_packet_types |= BTM_SCO_EXCEPTION_PKTS_MASK;
+      temp_pkt_types &= BTM_SCO_LINK_ONLY_MASK;
+      temp_pkt_types |= BTM_SCO_EXCEPTION_PKTS_MASK;
     } else {
       /* OR in any exception packet types */
-      temp_packet_types |=
+      temp_pkt_types |=
           ((p_setup->packet_types & BTM_SCO_EXCEPTION_PKTS_MASK) |
            (btm_cb.btm_sco_pkt_types_supported & BTM_SCO_EXCEPTION_PKTS_MASK));
     }
 
-    /* Use Enhanced Synchronous commands if supported */
-    if (controller_get_interface()
-            ->supports_enhanced_setup_synchronous_connection()) {
-      /* Use the saved SCO routing */
-      p_setup->input_data_path = p_setup->output_data_path =
-          btm_cb.sco_cb.sco_route;
-
-      BTM_TRACE_DEBUG(
-          "%s: txbw 0x%x, rxbw 0x%x, lat 0x%x, retrans 0x%02x, "
-          "pkt 0x%04x, path %u",
-          __func__, p_setup->transmit_bandwidth, p_setup->receive_bandwidth,
-          p_setup->max_latency_ms, p_setup->retransmission_effort,
-          p_setup->packet_types, p_setup->input_data_path);
-
-      btsnd_hcic_enhanced_accept_synchronous_connection(bda, p_setup);
-
-    } else {
-      /* Use legacy command if enhanced SCO setup is not supported */
-      uint16_t voice_content_format = btm_sco_voice_settings_to_legacy(p_setup);
-      btsnd_hcic_accept_esco_conn(
-          bda, p_setup->transmit_bandwidth, p_setup->receive_bandwidth,
-          p_setup->max_latency_ms, voice_content_format,
-          p_setup->retransmission_effort, p_setup->packet_types);
-    }
+    btsnd_hcic_accept_esco_conn(bda, p_setup->tx_bw, p_setup->rx_bw,
+                                p_setup->max_latency, p_setup->voice_contfmt,
+                                p_setup->retrans_effort, temp_pkt_types);
+    p_setup->packet_types = temp_pkt_types;
   }
 #endif
 }
@@ -225,6 +224,53 @@ void btm_route_sco_data(BT_HDR* p_msg) {
  *
  *
  ******************************************************************************/
+#if (BTM_SCO_HCI_INCLUDED == TRUE && BTM_MAX_SCO_LINKS > 0)
+tBTM_STATUS BTM_WriteScoData(uint16_t sco_inx, BT_HDR* p_buf) {
+  tSCO_CONN* p_ccb = &btm_cb.sco_cb.sco_db[sco_inx];
+  uint8_t* p;
+  tBTM_STATUS status = BTM_SUCCESS;
+
+  if (sco_inx < BTM_MAX_SCO_LINKS && btm_cb.sco_cb.p_data_cb &&
+      p_ccb->state == SCO_ST_CONNECTED) {
+    /* Ensure we have enough space in the buffer for the SCO and HCI headers */
+    if (p_buf->offset < HCI_SCO_PREAMBLE_SIZE) {
+      BTM_TRACE_ERROR("BTM SCO - cannot send buffer, offset: %d",
+                      p_buf->offset);
+      osi_free(p_buf);
+      status = BTM_ILLEGAL_VALUE;
+    } else /* write HCI header */
+    {
+      /* Step back 3 bytes to add the headers */
+      p_buf->offset -= HCI_SCO_PREAMBLE_SIZE;
+      /* Set the pointer to the beginning of the data */
+      p = (uint8_t*)(p_buf + 1) + p_buf->offset;
+      /* add HCI handle */
+      UINT16_TO_STREAM(p, p_ccb->hci_handle);
+      /* only sent the first BTM_SCO_DATA_SIZE_MAX bytes data if more than max,
+         and set warning status */
+      if (p_buf->len > BTM_SCO_DATA_SIZE_MAX) {
+        p_buf->len = BTM_SCO_DATA_SIZE_MAX;
+        status = BTM_SCO_BAD_LENGTH;
+      }
+
+      UINT8_TO_STREAM(p, (uint8_t)p_buf->len);
+      p_buf->len += HCI_SCO_PREAMBLE_SIZE;
+
+      fixed_queue_enqueue(p_ccb->xmit_data_q, p_buf);
+
+      btm_sco_check_send_pkts(sco_inx);
+    }
+  } else {
+    osi_free(p_buf);
+
+    BTM_TRACE_WARNING("BTM_WriteScoData, invalid sco index: %d at state [%d]",
+                      sco_inx, btm_cb.sco_cb.sco_db[sco_inx].state);
+    status = BTM_UNKNOWN_ADDR;
+  }
+
+  return (status);
+}
+#else
 tBTM_STATUS BTM_WriteScoData(UNUSED_ATTR uint16_t sco_inx,
                              UNUSED_ATTR BT_HDR* p_buf) {
   return (BTM_NO_RESOURCES);
@@ -242,7 +288,9 @@ tBTM_STATUS BTM_WriteScoData(UNUSED_ATTR uint16_t sco_inx,
  *
  ******************************************************************************/
 static tBTM_STATUS btm_send_connect_request(uint16_t acl_handle,
-                                            enh_esco_params_t* p_setup) {
+                                            tBTM_ESCO_PARAMS* p_setup) {
+  uint16_t temp_pkt_types;
+  uint8_t xx;
   tACL_CONN* p_acl;
 
   /* Send connect request depending on version of spec */
@@ -255,18 +303,20 @@ static tBTM_STATUS btm_send_connect_request(uint16_t acl_handle,
         (p_setup->packet_types &
          static_cast<uint16_t>(BTM_SCO_SUPPORTED_PKTS_MASK) &
          btm_cb.btm_sco_pkt_types_supported);
+    temp_pkt_types = (p_setup->packet_types & BTM_SCO_SUPPORTED_PKTS_MASK &
+                      btm_cb.btm_sco_pkt_types_supported);
 
     /* OR in any exception packet types */
-    temp_packet_types |=
+    temp_pkt_types |=
         ((p_setup->packet_types & BTM_SCO_EXCEPTION_PKTS_MASK) |
          (btm_cb.btm_sco_pkt_types_supported & BTM_SCO_EXCEPTION_PKTS_MASK));
 
     /* Finally, remove EDR eSCO if the remote device doesn't support it */
     /* UPF25:  Only SCO was brought up in this case */
     btm_handle_to_acl_index(acl_handle);
-    uint8_t acl_index = btm_handle_to_acl_index(acl_handle);
-    if (acl_index < MAX_L2CAP_LINKS) {
-      p_acl = &btm_cb.acl_db[acl_index];
+    xx = btm_handle_to_acl_index(acl_handle);
+    if (xx < MAX_L2CAP_LINKS) {
+      p_acl = &btm_cb.acl_db[xx];
       if (!HCI_EDR_ESCO_2MPS_SUPPORTED(p_acl->peer_lmp_feature_pages[0])) {
         BTM_TRACE_DEBUG("BTM Remote does not support 2-EDR eSCO");
         temp_packet_types |=
@@ -276,15 +326,23 @@ static tBTM_STATUS btm_send_connect_request(uint16_t acl_handle,
         BTM_TRACE_DEBUG("BTM Remote does not support 3-EDR eSCO");
         temp_packet_types |=
             (ESCO_PKT_TYPES_MASK_NO_3_EV3 | ESCO_PKT_TYPES_MASK_NO_3_EV5);
+        BTM_TRACE_WARNING("BTM Remote does not support 2-EDR eSCO");
+        temp_pkt_types |= (HCI_ESCO_PKT_TYPES_MASK_NO_2_EV3 |
+                           HCI_ESCO_PKT_TYPES_MASK_NO_2_EV5);
+      }
+      if (!HCI_EDR_ESCO_3MPS_SUPPORTED(p_acl->peer_lmp_feature_pages[0])) {
+        BTM_TRACE_WARNING("BTM Remote does not support 3-EDR eSCO");
+        temp_pkt_types |= (HCI_ESCO_PKT_TYPES_MASK_NO_3_EV3 |
+                           HCI_ESCO_PKT_TYPES_MASK_NO_3_EV5);
       }
 
       /* Check to see if BR/EDR Secure Connections is being used
       ** If so, we cannot use SCO-only packet types (HFP 1.7)
       */
       if (BTM_BothEndsSupportSecureConnections(p_acl->remote_addr)) {
-        temp_packet_types &= ~(BTM_SCO_PKT_TYPE_MASK);
+        temp_pkt_types &= ~(BTM_SCO_PKT_TYPE_MASK);
         BTM_TRACE_DEBUG("%s: SCO Conn: pkt_types after removing SCO (0x%04x)",
-                        __func__, temp_packet_types);
+                        __func__, temp_pkt_types);
 
         /* Return error if no packet types left */
         if (temp_packet_types == 0) {
@@ -292,6 +350,9 @@ static tBTM_STATUS btm_send_connect_request(uint16_t acl_handle,
                      << ": SCO Conn (BR/EDR SC): No packet types available for "
                         "acl_handle "
                      << unsigned(acl_handle);
+        if (temp_pkt_types == 0) {
+          BTM_TRACE_ERROR("%s: SCO Conn (BR/EDR SC): No packet types available",
+                          __func__);
           return (BTM_WRONG_MODE);
         }
       } else {
@@ -340,6 +401,16 @@ static tBTM_STATUS btm_send_connect_request(uint16_t acl_handle,
           p_setup->max_latency_ms, voice_content_format,
           p_setup->retransmission_effort, p_setup->packet_types);
     }
+    BTM_TRACE_API(
+        "      txbw 0x%x, rxbw 0x%x, lat 0x%x, voice 0x%x, retrans 0x%02x, pkt "
+        "0x%04x",
+        p_setup->tx_bw, p_setup->rx_bw, p_setup->max_latency,
+        p_setup->voice_contfmt, p_setup->retrans_effort, temp_pkt_types);
+
+    btsnd_hcic_setup_esco_conn(acl_handle, p_setup->tx_bw, p_setup->rx_bw,
+                               p_setup->max_latency, p_setup->voice_contfmt,
+                               p_setup->retrans_effort, temp_pkt_types);
+    p_setup->packet_types = temp_pkt_types;
   }
 
   return (BTM_CMD_STARTED);
@@ -370,7 +441,7 @@ void btm_set_sco_ind_cback(tBTM_SCO_IND_CBACK* sco_ind_cb) {
  * Returns          void
  *
  ******************************************************************************/
-void btm_accept_sco_link(uint16_t sco_inx, enh_esco_params_t* p_setup,
+void btm_accept_sco_link(uint16_t sco_inx, tBTM_ESCO_PARAMS* p_setup,
                          tBTM_SCO_CB* p_conn_cb, tBTM_SCO_CB* p_disc_cb) {
 #if (BTM_MAX_SCO_LINKS > 0)
   tSCO_CONN* p_sco;
@@ -434,15 +505,15 @@ tBTM_STATUS BTM_CreateSco(const RawAddress* remote_bda, bool is_orig,
                           uint16_t pkt_types, uint16_t* p_sco_inx,
                           tBTM_SCO_CB* p_conn_cb, tBTM_SCO_CB* p_disc_cb) {
 #if (BTM_MAX_SCO_LINKS > 0)
-  enh_esco_params_t* p_setup;
+  tBTM_ESCO_PARAMS* p_setup;
   tSCO_CONN* p = &btm_cb.sco_cb.sco_db[0];
   uint16_t xx;
   uint16_t acl_handle = 0;
+  uint16_t temp_pkt_types;
   tACL_CONN* p_acl;
   *p_sco_inx = BTM_INVALID_SCO_INDEX;
 
   /* If originating, ensure that there is an ACL connection to the BD Address */
-
   if (is_orig) {
     if (!remote_bda) {
       LOG(ERROR) << __func__ << ": remote_bda is null";
@@ -454,6 +525,9 @@ tBTM_STATUS BTM_CreateSco(const RawAddress* remote_bda, bool is_orig,
                  << remote_bda;
       return BTM_UNKNOWN_ADDR;
     }
+    if ((!remote_bda) || ((acl_handle = BTM_GetHCIConnHandle(
+                               remote_bda, BT_TRANSPORT_BR_EDR)) == 0xFFFF))
+      return (BTM_UNKNOWN_ADDR);
   }
 
   if (remote_bda) {
@@ -465,6 +539,8 @@ tBTM_STATUS BTM_CreateSco(const RawAddress* remote_bda, bool is_orig,
         LOG(ERROR) << __func__ << ": a sco connection is already going on for "
                    << *remote_bda << ", at state " << unsigned(p->state);
         return BTM_BUSY;
+          (!memcmp(p->esco.data.bd_addr, remote_bda, BD_ADDR_LEN))) {
+        return (BTM_BUSY);
       }
     }
   } else {
@@ -476,10 +552,13 @@ tBTM_STATUS BTM_CreateSco(const RawAddress* remote_bda, bool is_orig,
             << ": remote_bda is null and not known and we are still listening";
         return BTM_BUSY;
       }
+      if ((p->state == SCO_ST_LISTENING) && (!p->rem_bd_known))
+        return (BTM_BUSY);
     }
   }
 
-  /* Try to find an unused control block, and kick off the SCO establishment */
+  /* Now, try to find an unused control block, and kick off the SCO
+   * establishment */
   for (xx = 0, p = &btm_cb.sco_cb.sco_db[0]; xx < BTM_MAX_SCO_LINKS;
        xx++, p++) {
     if (p->state == SCO_ST_UNUSED) {
@@ -515,20 +594,33 @@ tBTM_STATUS BTM_CreateSco(const RawAddress* remote_bda, bool is_orig,
       } else
         p->rem_bd_known = false;
 
+      /* Link role is ignored in for this message */
+      if (pkt_types == BTM_IGNORE_SCO_PKT_TYPE)
+        pkt_types = btm_cb.sco_cb.def_esco_parms.packet_types;
+
       p_setup = &p->esco.setup;
       *p_setup = btm_cb.sco_cb.def_esco_parms;
+      p_setup->packet_types =
+          (btm_cb.sco_cb.desired_sco_mode == BTM_LINK_TYPE_SCO)
+              ? (pkt_types & BTM_SCO_LINK_ONLY_MASK)
+              : pkt_types;
+
+      temp_pkt_types = (p_setup->packet_types & BTM_SCO_SUPPORTED_PKTS_MASK &
+                        btm_cb.btm_sco_pkt_types_supported);
 
-      /* Determine the packet types */
-      p_setup->packet_types = pkt_types & BTM_SCO_SUPPORTED_PKTS_MASK &
-                              btm_cb.btm_sco_pkt_types_supported;
       /* OR in any exception packet types */
       if (controller_get_interface()->get_bt_version()->hci_version >=
           HCI_PROTO_VERSION_2_0) {
-        p_setup->packet_types |=
-            (pkt_types & BTM_SCO_EXCEPTION_PKTS_MASK) |
-            (btm_cb.btm_sco_pkt_types_supported & BTM_SCO_EXCEPTION_PKTS_MASK);
+        temp_pkt_types |=
+            ((p_setup->packet_types & BTM_SCO_EXCEPTION_PKTS_MASK) |
+             (btm_cb.btm_sco_pkt_types_supported &
+              BTM_SCO_EXCEPTION_PKTS_MASK));
+      } else /* Only using SCO packet types; turn off EDR also */
+      {
+        temp_pkt_types |= BTM_SCO_EXCEPTION_PKTS_MASK;
       }
 
+      p_setup->packet_types = temp_pkt_types;
       p->p_conn_cb = p_conn_cb;
       p->p_disc_cb = p_disc_cb;
       p->hci_handle = BTM_INVALID_HCI_HANDLE;
@@ -550,8 +642,10 @@ tBTM_STATUS BTM_CreateSco(const RawAddress* remote_bda, bool is_orig,
       if (p->state != SCO_ST_PEND_UNPARK &&
           p->state != SCO_ST_PEND_ROLECHANGE) {
         if (is_orig) {
-          BTM_TRACE_API("%s:(e)SCO Link for ACL handle 0x%04x", __func__,
-                        acl_handle);
+          BTM_TRACE_API(
+              "BTM_CreateSco -> (e)SCO Link for ACL handle 0x%04x, Desired "
+              "Type %d",
+              acl_handle, btm_cb.sco_cb.desired_sco_mode);
 
           if ((btm_send_connect_request(acl_handle, p_setup)) !=
               BTM_CMD_STARTED) {
@@ -571,6 +665,8 @@ tBTM_STATUS BTM_CreateSco(const RawAddress* remote_bda, bool is_orig,
       *p_sco_inx = xx;
       BTM_TRACE_API("%s: BTM_CreateSco succeeded", __func__);
       return BTM_CMD_STARTED;
+
+      return (BTM_CMD_STARTED);
     }
   }
 
@@ -578,6 +674,7 @@ tBTM_STATUS BTM_CreateSco(const RawAddress* remote_bda, bool is_orig,
   /* If here, all SCO blocks in use */
   LOG(ERROR) << __func__ << ": all SCO control blocks are in use";
   return BTM_NO_RESOURCES;
+  return (BTM_NO_RESOURCES);
 }
 
 #if (BTM_SCO_WAKE_PARKED_LINK == TRUE)
@@ -605,6 +702,20 @@ void btm_sco_chk_pend_unpark(uint8_t hci_status, uint16_t hci_handle) {
                 << ", hci_status=" << unsigned(hci_status);
       if (btm_send_connect_request(acl_handle, &p->esco.setup) ==
           BTM_CMD_STARTED) {
+
+  for (xx = 0; xx < BTM_MAX_SCO_LINKS; xx++, p++) {
+    if ((p->state == SCO_ST_PEND_UNPARK) &&
+        ((acl_handle = BTM_GetHCIConnHandle(
+              p->esco.data.bd_addr, BT_TRANSPORT_BR_EDR)) == hci_handle))
+
+    {
+      BTM_TRACE_API(
+          "btm_sco_chk_pend_unpark -> (e)SCO Link for ACL handle 0x%04x, "
+          "Desired Type %d, hci_status 0x%02x",
+          acl_handle, btm_cb.sco_cb.desired_sco_mode, hci_status);
+
+      if ((btm_send_connect_request(acl_handle, &p->esco.setup)) ==
+          BTM_CMD_STARTED)
         p->state = SCO_ST_CONNECTING;
       } else {
         LOG(ERROR) << __func__ << ": failed to send connection request for "
@@ -841,8 +952,8 @@ void btm_sco_connected(uint8_t hci_status, const RawAddress* bda,
         if (spt) {
           parms.packet_types = p->esco.setup.packet_types;
           /* Keep the other parameters the same for SCO */
-          parms.max_latency_ms = p->esco.setup.max_latency_ms;
-          parms.retransmission_effort = p->esco.setup.retransmission_effort;
+          parms.max_latency = p->esco.setup.max_latency;
+          parms.retrans_effort = p->esco.setup.retrans_effort;
 
           BTM_ChangeEScoLinkParms(xx, &parms);
         }
@@ -1061,8 +1172,8 @@ tBTM_STATUS BTM_SetScoPacketTypes(uint16_t sco_inx, uint16_t pkt_types) {
   parms.packet_types = pkt_types;
 
   /* Keep the other parameters the same for SCO */
-  parms.max_latency_ms = p->esco.setup.max_latency_ms;
-  parms.retransmission_effort = p->esco.setup.retransmission_effort;
+  parms.max_latency = p->esco.setup.max_latency;
+  parms.retrans_effort = p->esco.setup.retrans_effort;
 
   return (BTM_ChangeEScoLinkParms(sco_inx, &parms));
 #else
@@ -1212,27 +1323,43 @@ const RawAddress* BTM_ReadScoBdAddr(uint16_t sco_inx) {
  *                  BTM_BUSY if there are one or more active (e)SCO links.
  *
  ******************************************************************************/
-tBTM_STATUS BTM_SetEScoMode(enh_esco_params_t* p_parms) {
-  enh_esco_params_t* p_def = &btm_cb.sco_cb.def_esco_parms;
+tBTM_STATUS BTM_SetEScoMode(tBTM_SCO_TYPE sco_mode, tBTM_ESCO_PARAMS* p_parms) {
+  tSCO_CB* p_esco = &btm_cb.sco_cb;
+  tBTM_ESCO_PARAMS* p_def = &p_esco->def_esco_parms;
 
-  if (btm_cb.sco_cb.esco_supported) {
-    *p_def = *p_parms;
+  if (p_esco->esco_supported) {
+    if (p_parms) {
+      if (sco_mode == BTM_LINK_TYPE_ESCO)
+        *p_def = *p_parms; /* Save as the default parameters */
+      else                 /* Load only the SCO packet types */
+      {
+        p_def->packet_types = p_parms->packet_types;
+        p_def->tx_bw = BTM_64KBITS_RATE;
+        p_def->rx_bw = BTM_64KBITS_RATE;
+        p_def->max_latency = 0x000a;
+        p_def->voice_contfmt = 0x0060;
+        p_def->retrans_effort = 0;
+
+        /* OR in any exception packet types */
+        p_def->packet_types |= BTM_SCO_EXCEPTION_PKTS_MASK;
+      }
+    }
+    p_esco->desired_sco_mode = sco_mode;
+    BTM_TRACE_API("BTM_SetEScoMode -> mode %d", sco_mode);
   } else {
-    /* Load defaults for SCO only */
-    *p_def = esco_parameters_for_codec(ESCO_CODEC_CVSD);
+    p_esco->desired_sco_mode = BTM_LINK_TYPE_SCO;
     p_def->packet_types &= BTM_SCO_LINK_ONLY_MASK;
-    p_def->retransmission_effort = ESCO_RETRANSMISSION_OFF;
-    p_def->max_latency_ms = 12;
-    BTM_TRACE_WARNING("%s: eSCO not supported", __func__);
+    p_def->retrans_effort = 0;
+    BTM_TRACE_API("BTM_SetEScoMode -> mode SCO (eSCO not supported)");
   }
 
-  BTM_TRACE_API(
-      "%s: txbw 0x%08x, rxbw 0x%08x, max_lat 0x%04x, "
-      "pkt 0x%04x, rtx effort 0x%02x",
-      __func__, p_def->transmit_bandwidth, p_def->receive_bandwidth,
-      p_def->max_latency_ms, p_def->packet_types, p_def->retransmission_effort);
+  BTM_TRACE_DEBUG(
+      "    txbw 0x%08x, rxbw 0x%08x, max_lat 0x%04x, voice 0x%04x, pkt 0x%04x, "
+      "rtx effort 0x%02x",
+      p_def->tx_bw, p_def->rx_bw, p_def->max_latency, p_def->voice_contfmt,
+      p_def->packet_types, p_def->retrans_effort);
 
-  return BTM_SUCCESS;
+  return (BTM_SUCCESS);
 }
 
 /*******************************************************************************
@@ -1290,7 +1417,7 @@ tBTM_STATUS BTM_ReadEScoLinkParms(uint16_t sco_inx, tBTM_ESCO_DATA* p_parms) {
 #if (BTM_MAX_SCO_LINKS > 0)
   uint8_t index;
 
-  BTM_TRACE_API("%s: -> sco_inx 0x%04x", __func__, sco_inx);
+  BTM_TRACE_API("BTM_ReadEScoLinkParms -> sco_inx 0x%04x", sco_inx);
 
   if (sco_inx < BTM_MAX_SCO_LINKS &&
       btm_cb.sco_cb.sco_db[sco_inx].state >= SCO_ST_CONNECTED) {
@@ -1301,7 +1428,8 @@ tBTM_STATUS BTM_ReadEScoLinkParms(uint16_t sco_inx, tBTM_ESCO_DATA* p_parms) {
   if (sco_inx == BTM_FIRST_ACTIVE_SCO_INDEX) {
     for (index = 0; index < BTM_MAX_SCO_LINKS; index++) {
       if (btm_cb.sco_cb.sco_db[index].state >= SCO_ST_CONNECTED) {
-        BTM_TRACE_API("%s: the first active SCO index is %d", __func__, index);
+        BTM_TRACE_API("BTM_ReadEScoLinkParms the first active SCO index is %d",
+                      index);
         *p_parms = btm_cb.sco_cb.sco_db[index].esco.data;
         return (BTM_SUCCESS);
       }
@@ -1338,17 +1466,17 @@ tBTM_STATUS BTM_ReadEScoLinkParms(uint16_t sco_inx, tBTM_ESCO_DATA* p_parms) {
 tBTM_STATUS BTM_ChangeEScoLinkParms(uint16_t sco_inx,
                                     tBTM_CHG_ESCO_PARAMS* p_parms) {
 #if (BTM_MAX_SCO_LINKS > 0)
+  tBTM_ESCO_PARAMS* p_setup;
+  tSCO_CONN* p_sco;
+  uint16_t temp_pkt_types;
 
   /* Make sure sco handle is valid and on an active link */
   if (sco_inx >= BTM_MAX_SCO_LINKS ||
       btm_cb.sco_cb.sco_db[sco_inx].state != SCO_ST_CONNECTED)
     return (BTM_WRONG_MODE);
 
-  tSCO_CONN* p_sco = &btm_cb.sco_cb.sco_db[sco_inx];
-  enh_esco_params_t* p_setup = &p_sco->esco.setup;
-
-  /* Save the previous types in case command fails */
-  uint16_t saved_packet_types = p_setup->packet_types;
+  p_sco = &btm_cb.sco_cb.sco_db[sco_inx];
+  p_setup = &p_sco->esco.setup;
 
   /* If SCO connection OR eSCO not supported just send change packet types */
   if (p_sco->esco.data.link_type == BTM_LINK_TYPE_SCO ||
@@ -1357,60 +1485,34 @@ tBTM_STATUS BTM_ChangeEScoLinkParms(uint16_t sco_inx,
         p_parms->packet_types &
         (btm_cb.btm_sco_pkt_types_supported & BTM_SCO_LINK_ONLY_MASK);
 
-    BTM_TRACE_API("%s: SCO Link for handle 0x%04x, pkt 0x%04x", __func__,
-                  p_sco->hci_handle, p_setup->packet_types);
-
-    BTM_TRACE_API("%s: SCO Link for handle 0x%04x, pkt 0x%04x", __func__,
-                  p_sco->hci_handle, p_setup->packet_types);
+    BTM_TRACE_API(
+        "BTM_ChangeEScoLinkParms -> SCO Link for handle 0x%04x, pkt 0x%04x",
+        p_sco->hci_handle, p_setup->packet_types);
 
     btsnd_hcic_change_conn_type(p_sco->hci_handle,
                                 BTM_ESCO_2_SCO(p_setup->packet_types));
-  } else /* eSCO is supported and the link type is eSCO */
-  {
-    uint16_t temp_packet_types =
-        (p_parms->packet_types & BTM_SCO_SUPPORTED_PKTS_MASK &
-         btm_cb.btm_sco_pkt_types_supported);
+  } else {
+    temp_pkt_types = (p_parms->packet_types & BTM_SCO_SUPPORTED_PKTS_MASK &
+                      btm_cb.btm_sco_pkt_types_supported);
 
     /* OR in any exception packet types */
-    temp_packet_types |=
+    temp_pkt_types |=
         ((p_parms->packet_types & BTM_SCO_EXCEPTION_PKTS_MASK) |
          (btm_cb.btm_sco_pkt_types_supported & BTM_SCO_EXCEPTION_PKTS_MASK));
-    p_setup->packet_types = temp_packet_types;
 
-    BTM_TRACE_API("%s -> eSCO Link for handle 0x%04x", __func__,
+    BTM_TRACE_API("BTM_ChangeEScoLinkParms -> eSCO Link for handle 0x%04x",
                   p_sco->hci_handle);
     BTM_TRACE_API(
-        "   txbw 0x%x, rxbw 0x%x, lat 0x%x, retrans 0x%02x, pkt 0x%04x",
-        p_setup->transmit_bandwidth, p_setup->receive_bandwidth,
-        p_parms->max_latency_ms, p_parms->retransmission_effort,
-        temp_packet_types);
-
-    /* Use Enhanced Synchronous commands if supported */
-    if (controller_get_interface()
-            ->supports_enhanced_setup_synchronous_connection()) {
-      /* Use the saved SCO routing */
-      p_setup->input_data_path = p_setup->output_data_path =
-          btm_cb.sco_cb.sco_route;
-
-      btsnd_hcic_enhanced_set_up_synchronous_connection(p_sco->hci_handle,
-                                                        p_setup);
-      p_setup->packet_types = saved_packet_types;
-    } else { /* Use older command */
-      uint16_t voice_content_format = btm_sco_voice_settings_to_legacy(p_setup);
-      /* When changing an existing link, only change latency, retrans, and
-       * pkts */
-      btsnd_hcic_setup_esco_conn(p_sco->hci_handle, p_setup->transmit_bandwidth,
-                                 p_setup->receive_bandwidth,
-                                 p_parms->max_latency_ms, voice_content_format,
-                                 p_parms->retransmission_effort,
-                                 p_setup->packet_types);
-    }
-
-    BTM_TRACE_API(
-        "%s: txbw 0x%x, rxbw 0x%x, lat 0x%x, retrans 0x%02x, pkt 0x%04x",
-        __func__, p_setup->transmit_bandwidth, p_setup->receive_bandwidth,
-        p_parms->max_latency_ms, p_parms->retransmission_effort,
-        temp_packet_types);
+        "      txbw 0x%x, rxbw 0x%x, lat 0x%x, voice 0x%x, retrans 0x%02x, pkt "
+        "0x%04x",
+        p_setup->tx_bw, p_setup->rx_bw, p_parms->max_latency,
+        p_setup->voice_contfmt, p_parms->retrans_effort, temp_pkt_types);
+
+    /* When changing an existing link, only change latency, retrans, and pkts */
+    btsnd_hcic_setup_esco_conn(
+        p_sco->hci_handle, p_setup->tx_bw, p_setup->rx_bw, p_parms->max_latency,
+        p_setup->voice_contfmt, p_parms->retrans_effort, temp_pkt_types);
+    p_parms->packet_types = temp_pkt_types;
   }
 
   return (BTM_CMD_STARTED);
@@ -1438,7 +1540,7 @@ tBTM_STATUS BTM_ChangeEScoLinkParms(uint16_t sco_inx,
  *
  ******************************************************************************/
 void BTM_EScoConnRsp(uint16_t sco_inx, uint8_t hci_status,
-                     enh_esco_params_t* p_parms) {
+                     tBTM_ESCO_PARAMS* p_parms) {
 #if (BTM_MAX_SCO_LINKS > 0)
   if (sco_inx < BTM_MAX_SCO_LINKS &&
       btm_cb.sco_cb.sco_db[sco_inx].state == SCO_ST_W4_CONN_RSP) {
@@ -1458,9 +1560,12 @@ void BTM_EScoConnRsp(uint16_t sco_inx, uint8_t hci_status,
  * Returns          tBTM_SCO_TYPE
  *
  ******************************************************************************/
-void btm_read_def_esco_mode(enh_esco_params_t* p_parms) {
+tBTM_SCO_TYPE btm_read_def_esco_mode(tBTM_ESCO_PARAMS* p_parms) {
 #if (BTM_MAX_SCO_LINKS > 0)
   *p_parms = btm_cb.sco_cb.def_esco_parms;
+  return btm_cb.sco_cb.desired_sco_mode;
+#else
+  return BTM_LINK_TYPE_SCO;
 #endif
 }
 
@@ -1584,114 +1689,6 @@ bool btm_is_sco_active_by_bdaddr(const RawAddress& remote_bda) {
 #endif
   return (false);
 }
-
-/*******************************************************************************
- *
- * Function         btm_sco_voice_settings_2_legacy
- *
- * Description      This function is called to convert the Enhanced eSCO
- *                  parameters into voice setting parameter mask used
- *                  for legacy setup synchronous connection HCI commands
- *
- * Returns          UINT16 - 16-bit mask for voice settings
- *
- *          HCI_INP_CODING_LINEAR           0x0000 (0000000000)
- *          HCI_INP_CODING_U_LAW            0x0100 (0100000000)
- *          HCI_INP_CODING_A_LAW            0x0200 (1000000000)
- *          HCI_INP_CODING_MASK             0x0300 (1100000000)
- *
- *          HCI_INP_DATA_FMT_1S_COMPLEMENT  0x0000 (0000000000)
- *          HCI_INP_DATA_FMT_2S_COMPLEMENT  0x0040 (0001000000)
- *          HCI_INP_DATA_FMT_SIGN_MAGNITUDE 0x0080 (0010000000)
- *          HCI_INP_DATA_FMT_UNSIGNED       0x00c0 (0011000000)
- *          HCI_INP_DATA_FMT_MASK           0x00c0 (0011000000)
- *
- *          HCI_INP_SAMPLE_SIZE_8BIT        0x0000 (0000000000)
- *          HCI_INP_SAMPLE_SIZE_16BIT       0x0020 (0000100000)
- *          HCI_INP_SAMPLE_SIZE_MASK        0x0020 (0000100000)
- *
- *          HCI_INP_LINEAR_PCM_BIT_POS_MASK 0x001c (0000011100)
- *          HCI_INP_LINEAR_PCM_BIT_POS_OFFS 2
- *
- *          HCI_AIR_CODING_FORMAT_CVSD      0x0000 (0000000000)
- *          HCI_AIR_CODING_FORMAT_U_LAW     0x0001 (0000000001)
- *          HCI_AIR_CODING_FORMAT_A_LAW     0x0002 (0000000010)
- *          HCI_AIR_CODING_FORMAT_TRANSPNT  0x0003 (0000000011)
- *          HCI_AIR_CODING_FORMAT_MASK      0x0003 (0000000011)
- *
- *          default (0001100000)
- *          HCI_DEFAULT_VOICE_SETTINGS    (HCI_INP_CODING_LINEAR \
- *                                   | HCI_INP_DATA_FMT_2S_COMPLEMENT \
- *                                   | HCI_INP_SAMPLE_SIZE_16BIT \
- *                                   | HCI_AIR_CODING_FORMAT_CVSD)
- *
- ******************************************************************************/
-static uint16_t btm_sco_voice_settings_to_legacy(enh_esco_params_t* p_params) {
-  uint16_t voice_settings = 0;
-
-  /* Convert Input Coding Format: If no uLaw or aLAW then Linear will be used
-   * (0) */
-  if (p_params->input_coding_format.coding_format == ESCO_CODING_FORMAT_ULAW)
-    voice_settings |= HCI_INP_CODING_U_LAW;
-  else if (p_params->input_coding_format.coding_format ==
-           ESCO_CODING_FORMAT_ALAW)
-    voice_settings |= HCI_INP_CODING_A_LAW;
-  /* else default value of '0 is good 'Linear' */
-
-  /* Convert Input Data Format. Use 2's Compliment as the default */
-  switch (p_params->input_pcm_data_format) {
-    case ESCO_PCM_DATA_FORMAT_1_COMP:
-      /* voice_settings |= HCI_INP_DATA_FMT_1S_COMPLEMENT;     value is '0'
-       * already */
-      break;
-
-    case ESCO_PCM_DATA_FORMAT_SIGN:
-      voice_settings |= HCI_INP_DATA_FMT_SIGN_MAGNITUDE;
-      break;
-
-    case ESCO_PCM_DATA_FORMAT_UNSIGN:
-      voice_settings |= HCI_INP_DATA_FMT_UNSIGNED;
-      break;
-
-    default: /* 2's Compliment */
-      voice_settings |= HCI_INP_DATA_FMT_2S_COMPLEMENT;
-      break;
-  }
-
-  /* Convert Over the Air Coding. Use CVSD as the default */
-  switch (p_params->transmit_coding_format.coding_format) {
-    case ESCO_CODING_FORMAT_ULAW:
-      voice_settings |= HCI_AIR_CODING_FORMAT_U_LAW;
-      break;
-
-    case ESCO_CODING_FORMAT_ALAW:
-      voice_settings |= HCI_AIR_CODING_FORMAT_A_LAW;
-      break;
-
-    case ESCO_CODING_FORMAT_MSBC:
-      voice_settings |= HCI_AIR_CODING_FORMAT_TRANSPNT;
-      break;
-
-    default: /* CVSD (0) */
-      break;
-  }
-
-  /* Convert PCM payload MSB position (0000011100) */
-  voice_settings |= (uint16_t)(((p_params->input_pcm_payload_msb_position & 0x7)
-                                << HCI_INP_LINEAR_PCM_BIT_POS_OFFS));
-
-  /* Convert Input Sample Size (0000011100) */
-  if (p_params->input_coded_data_size == 16)
-    voice_settings |= HCI_INP_SAMPLE_SIZE_16BIT;
-  else /* Use 8 bit for all others */
-    voice_settings |= HCI_INP_SAMPLE_SIZE_8BIT;
-
-  BTM_TRACE_DEBUG("%s: voice setting for legacy 0x%03x", __func__,
-                  voice_settings);
-
-  return (voice_settings);
-}
-
 #else /* SCO_EXCLUDED == TRUE (Link in stubs) */
 
 tBTM_STATUS BTM_CreateSco(const RawAddress* remote_bda, bool is_orig,
@@ -1712,7 +1709,7 @@ const RawAddress* BTM_ReadScoBdAddr(uint16_t sco_inx) {
   return ((uint8_t*)NULL);
 }
 uint16_t BTM_ReadScoDiscReason(void) { return (BTM_INVALID_SCO_DISC_REASON); }
-tBTM_STATUS BTM_SetEScoMode(enh_esco_params_t* p_parms) {
+tBTM_STATUS BTM_SetEScoMode(tBTM_SCO_TYPE sco_mode, tBTM_ESCO_PARAMS* p_parms) {
   return (BTM_MODE_UNSUPPORTED);
 }
 tBTM_STATUS BTM_RegForEScoEvts(uint16_t sco_inx,
@@ -1727,7 +1724,7 @@ tBTM_STATUS BTM_ChangeEScoLinkParms(uint16_t sco_inx,
   return (BTM_MODE_UNSUPPORTED);
 }
 void BTM_EScoConnRsp(uint16_t sco_inx, uint8_t hci_status,
-                     enh_esco_params_t* p_parms) {}
+                     tBTM_ESCO_PARAMS* p_parms) {}
 uint8_t BTM_GetNumScoLinks(void) { return (0); }
 
 #endif /* If SCO is being used */
diff --git a/system/bt/stack/btu/btu_hcif.cc b/system/bt/stack/btu/btu_hcif.cc
index eac71a684..d7ae978cb 100644
--- a/system/bt/stack/btu/btu_hcif.cc
+++ b/system/bt/stack/btu/btu_hcif.cc
@@ -1155,14 +1155,13 @@ static void btu_hcif_hdl_command_status(uint16_t opcode, uint8_t status,
 
 #if (BTM_SCO_INCLUDED == TRUE)
           case HCI_SETUP_ESCO_CONNECTION:
-          case HCI_ENH_SETUP_ESCO_CONNECTION:
             /* read handle out of stored command */
             if (p_cmd != NULL) {
               p_cmd++;
               STREAM_TO_UINT16(handle, p_cmd);
 
-              /* Determine if initial connection failed or is a change
-               * of setup */
+              /* Determine if initial connection failed or is a change of setup
+               */
               if (btm_is_sco_active(handle))
                 btm_esco_proc_conn_chg(status, handle, 0, 0, 0, 0);
               else
diff --git a/system/bt/stack/hcic/hcicmds.cc b/system/bt/stack/hcic/hcicmds.cc
index 56ff381f1..b5acb2917 100644
--- a/system/bt/stack/hcic/hcicmds.cc
+++ b/system/bt/stack/hcic/hcicmds.cc
@@ -433,8 +433,7 @@ void btsnd_hcic_read_lmp_handle(uint16_t handle) {
   btu_hcif_send_cmd(LOCAL_BR_EDR_CONTROLLER_ID, p);
 }
 
-void btsnd_hcic_setup_esco_conn(uint16_t handle, uint32_t transmit_bandwidth,
-                                uint32_t receive_bandwidth,
+void btsnd_hcic_setup_esco_conn(uint16_t handle, uint32_t tx_bw, uint32_t rx_bw,
                                 uint16_t max_latency, uint16_t voice,
                                 uint8_t retrans_effort, uint16_t packet_types) {
   BT_HDR* p = (BT_HDR*)osi_malloc(HCI_CMD_BUF_SIZE);
@@ -447,8 +446,8 @@ void btsnd_hcic_setup_esco_conn(uint16_t handle, uint32_t transmit_bandwidth,
   UINT8_TO_STREAM(pp, HCIC_PARAM_SIZE_SETUP_ESCO);
 
   UINT16_TO_STREAM(pp, handle);
-  UINT32_TO_STREAM(pp, transmit_bandwidth);
-  UINT32_TO_STREAM(pp, receive_bandwidth);
+  UINT32_TO_STREAM(pp, tx_bw);
+  UINT32_TO_STREAM(pp, rx_bw);
   UINT16_TO_STREAM(pp, max_latency);
   UINT16_TO_STREAM(pp, voice);
   UINT8_TO_STREAM(pp, retrans_effort);
@@ -462,6 +461,9 @@ void btsnd_hcic_accept_esco_conn(const RawAddress& bd_addr,
                                  uint32_t receive_bandwidth,
                                  uint16_t max_latency, uint16_t content_fmt,
                                  uint8_t retrans_effort,
+void btsnd_hcic_accept_esco_conn(BD_ADDR bd_addr, uint32_t tx_bw,
+                                 uint32_t rx_bw, uint16_t max_latency,
+                                 uint16_t content_fmt, uint8_t retrans_effort,
                                  uint16_t packet_types) {
   BT_HDR* p = (BT_HDR*)osi_malloc(HCI_CMD_BUF_SIZE);
   uint8_t* pp = (uint8_t*)(p + 1);
@@ -473,8 +475,8 @@ void btsnd_hcic_accept_esco_conn(const RawAddress& bd_addr,
   UINT8_TO_STREAM(pp, HCIC_PARAM_SIZE_ACCEPT_ESCO);
 
   BDADDR_TO_STREAM(pp, bd_addr);
-  UINT32_TO_STREAM(pp, transmit_bandwidth);
-  UINT32_TO_STREAM(pp, receive_bandwidth);
+  UINT32_TO_STREAM(pp, tx_bw);
+  UINT32_TO_STREAM(pp, rx_bw);
   UINT16_TO_STREAM(pp, max_latency);
   UINT16_TO_STREAM(pp, content_fmt);
   UINT8_TO_STREAM(pp, retrans_effort);
@@ -1067,6 +1069,7 @@ void btsnd_hcic_enhanced_set_up_synchronous_connection(
 void btsnd_hcic_enhanced_accept_synchronous_connection(
     const RawAddress& bd_addr, enh_esco_params_t* p_params) {
   BT_HDR* p = (BT_HDR*)osi_malloc(HCI_CMD_BUF_SIZE);
+  ;
   uint8_t* pp = (uint8_t*)(p + 1);
 
   p->len = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_ENH_ACC_ESCO_CONN;
@@ -1115,6 +1118,7 @@ void btsnd_hcic_enhanced_accept_synchronous_connection(
 
 void btsnd_hcic_io_cap_req_neg_reply(const RawAddress& bd_addr,
                                      uint8_t err_code) {
+void btsnd_hcic_io_cap_req_neg_reply(BD_ADDR bd_addr, uint8_t err_code) {
   BT_HDR* p = (BT_HDR*)osi_malloc(HCI_CMD_BUF_SIZE);
   uint8_t* pp = (uint8_t*)(p + 1);
 
diff --git a/system/bt/stack/include/btm_api.h b/system/bt/stack/include/btm_api.h
index 6ffc0f924..96d63e75a 100644
--- a/system/bt/stack/include/btm_api.h
+++ b/system/bt/stack/include/btm_api.h
@@ -26,7 +26,6 @@
 #define BTM_API_H
 
 #include "bt_target.h"
-#include "device/include/esco_parameters.h"
 #include "hcidefs.h"
 #include "sdp_api.h"
 
@@ -1094,7 +1093,8 @@ extern uint16_t BTM_ReadScoDiscReason(void);
  *                  BTM_BUSY if there are one or more active (e)SCO links.
  *
  ******************************************************************************/
-extern tBTM_STATUS BTM_SetEScoMode(enh_esco_params_t* p_parms);
+extern tBTM_STATUS BTM_SetEScoMode(tBTM_SCO_TYPE sco_mode,
+                                   tBTM_ESCO_PARAMS* p_parms);
 
 /*******************************************************************************
  *
@@ -1190,7 +1190,7 @@ extern tBTM_STATUS BTM_ChangeEScoLinkParms(uint16_t sco_inx,
  *
  ******************************************************************************/
 extern void BTM_EScoConnRsp(uint16_t sco_inx, uint8_t hci_status,
-                            enh_esco_params_t* p_parms);
+                            tBTM_ESCO_PARAMS* p_parms);
 
 /*******************************************************************************
  *
@@ -2004,7 +2004,7 @@ extern uint8_t BTM_GetEirUuidList(uint8_t* p_eir, size_t eir_len,
  *
  *
  ******************************************************************************/
-extern tBTM_STATUS BTM_ConfigScoPath(esco_data_path_t path,
+extern tBTM_STATUS BTM_ConfigScoPath(tBTM_SCO_ROUTE_TYPE path,
                                      tBTM_SCO_DATA_CB* p_sco_data_cb,
                                      tBTM_SCO_PCM_PARAM* p_pcm_param,
                                      bool err_data_rpt);
diff --git a/system/bt/stack/include/btm_api_types.h b/system/bt/stack/include/btm_api_types.h
index 8cc94859d..b0b506231 100644
--- a/system/bt/stack/include/btm_api_types.h
+++ b/system/bt/stack/include/btm_api_types.h
@@ -20,7 +20,6 @@
 #define BTM_API_TYPES_H
 
 #include "bt_target.h"
-#include "device/include/esco_parameters.h"
 #include "hcidefs.h"
 #include "smp_api_types.h"
 
@@ -919,17 +918,34 @@ typedef void(tBTM_ACL_DB_CHANGE_CB)(const RawAddress& p_bda, DEV_CLASS p_dc,
 /* Define first active SCO index */
 #define BTM_FIRST_ACTIVE_SCO_INDEX BTM_MAX_SCO_LINKS
 
-#define BTM_SCO_LINK_ONLY_MASK \
-  (ESCO_PKT_TYPES_MASK_HV1 | ESCO_PKT_TYPES_MASK_HV2 | ESCO_PKT_TYPES_MASK_HV3)
-
-#define BTM_ESCO_LINK_ONLY_MASK \
-  (ESCO_PKT_TYPES_MASK_EV3 | ESCO_PKT_TYPES_MASK_EV4 | ESCO_PKT_TYPES_MASK_EV5)
+/* Define SCO packet types used in APIs */
+#define BTM_SCO_PKT_TYPES_MASK_HV1 HCI_ESCO_PKT_TYPES_MASK_HV1
+#define BTM_SCO_PKT_TYPES_MASK_HV2 HCI_ESCO_PKT_TYPES_MASK_HV2
+#define BTM_SCO_PKT_TYPES_MASK_HV3 HCI_ESCO_PKT_TYPES_MASK_HV3
+#define BTM_SCO_PKT_TYPES_MASK_EV3 HCI_ESCO_PKT_TYPES_MASK_EV3
+#define BTM_SCO_PKT_TYPES_MASK_EV4 HCI_ESCO_PKT_TYPES_MASK_EV4
+#define BTM_SCO_PKT_TYPES_MASK_EV5 HCI_ESCO_PKT_TYPES_MASK_EV5
+#define BTM_SCO_PKT_TYPES_MASK_NO_2_EV3 HCI_ESCO_PKT_TYPES_MASK_NO_2_EV3
+#define BTM_SCO_PKT_TYPES_MASK_NO_3_EV3 HCI_ESCO_PKT_TYPES_MASK_NO_3_EV3
+#define BTM_SCO_PKT_TYPES_MASK_NO_2_EV5 HCI_ESCO_PKT_TYPES_MASK_NO_2_EV5
+#define BTM_SCO_PKT_TYPES_MASK_NO_3_EV5 HCI_ESCO_PKT_TYPES_MASK_NO_3_EV5
+
+#define BTM_SCO_LINK_ONLY_MASK                               \
+  (BTM_SCO_PKT_TYPES_MASK_HV1 | BTM_SCO_PKT_TYPES_MASK_HV2 | \
+   BTM_SCO_PKT_TYPES_MASK_HV3)
+
+#define BTM_ESCO_LINK_ONLY_MASK                              \
+  (BTM_SCO_PKT_TYPES_MASK_EV3 | BTM_SCO_PKT_TYPES_MASK_EV4 | \
+   BTM_SCO_PKT_TYPES_MASK_EV5)
 
 #define BTM_SCO_LINK_ALL_PKT_MASK \
   (BTM_SCO_LINK_ONLY_MASK | BTM_ESCO_LINK_ONLY_MASK)
 
 #define BTM_VALID_SCO_ALL_PKT_TYPE HCI_VALID_SCO_ALL_PKT_TYPE
 
+/* Passed in BTM_CreateSco if the packet type parameter should be ignored */
+#define BTM_IGNORE_SCO_PKT_TYPE 0
+
 /***************
  *  SCO Types
  ***************/
@@ -937,15 +953,32 @@ typedef void(tBTM_ACL_DB_CHANGE_CB)(const RawAddress& p_bda, DEV_CLASS p_dc,
 #define BTM_LINK_TYPE_ESCO HCI_LINK_TYPE_ESCO
 typedef uint8_t tBTM_SCO_TYPE;
 
+/*******************
+ * SCO Routing Path
+ *******************/
+#define BTM_SCO_ROUTE_PCM HCI_BRCM_SCO_ROUTE_PCM
+#define BTM_SCO_ROUTE_HCI HCI_BRCM_SCO_ROUTE_HCI
+typedef uint8_t tBTM_SCO_ROUTE_TYPE;
+
 /*******************
  * SCO Codec Types
  *******************/
 // TODO(google) This should use common definitions
+// in hci/include/hci_audio.h
 #define BTM_SCO_CODEC_NONE 0x0000
 #define BTM_SCO_CODEC_CVSD 0x0001
 #define BTM_SCO_CODEC_MSBC 0x0002
 typedef uint16_t tBTM_SCO_CODEC_TYPE;
 
+/*******************
+ * SCO Air Mode Types
+ *******************/
+#define BTM_SCO_AIR_MODE_U_LAW 0
+#define BTM_SCO_AIR_MODE_A_LAW 1
+#define BTM_SCO_AIR_MODE_CVSD 2
+#define BTM_SCO_AIR_MODE_TRANSPNT 3
+typedef uint8_t tBTM_SCO_AIR_MODE_TYPE;
+
 /*******************
  * SCO Voice Settings
  *******************/
@@ -975,6 +1008,20 @@ typedef void(tBTM_SCO_CB)(uint16_t sco_inx);
 typedef void(tBTM_SCO_DATA_CB)(uint16_t sco_inx, BT_HDR* p_data,
                                tBTM_SCO_DATA_FLAG status);
 
+/******************
+ *  eSCO Constants
+ ******************/
+#define BTM_64KBITS_RATE 0x00001f40 /* 64 kbits/sec data rate */
+
+/* Retransmission effort */
+#define BTM_ESCO_RETRANS_OFF 0
+#define BTM_ESCO_RETRANS_POWER 1
+#define BTM_ESCO_RETRANS_QUALITY 2
+#define BTM_ESCO_RETRANS_DONTCARE 0xff
+
+/* Max Latency Don't Care */
+#define BTM_ESCO_MAX_LAT_DONTCARE 0xffff
+
 /***************
  *  eSCO Types
  ***************/
@@ -983,13 +1030,20 @@ typedef void(tBTM_SCO_DATA_CB)(uint16_t sco_inx, BT_HDR* p_data,
 #define BTM_ESCO_CONN_REQ_EVT 2
 typedef uint8_t tBTM_ESCO_EVT;
 
-/* Structure passed with SCO change command and events.
- * Used by both Sync and Enhanced sync messaging
- */
+/* Passed into BTM_SetEScoMode() */
+typedef struct {
+  uint32_t tx_bw;
+  uint32_t rx_bw;
+  uint16_t max_latency;
+  uint16_t voice_contfmt; /* Voice Settings or Content Format */
+  uint16_t packet_types;
+  uint8_t retrans_effort;
+} tBTM_ESCO_PARAMS;
+
 typedef struct {
-  uint16_t max_latency_ms;
+  uint16_t max_latency;
   uint16_t packet_types;
-  uint8_t retransmission_effort;
+  uint8_t retrans_effort;
 } tBTM_CHG_ESCO_PARAMS;
 
 /* Returned by BTM_ReadEScoLinkParms() */
diff --git a/system/bt/stack/include/hcidefs.h b/system/bt/stack/include/hcidefs.h
index 8f9174317..dc61a2acc 100644
--- a/system/bt/stack/include/hcidefs.h
+++ b/system/bt/stack/include/hcidefs.h
@@ -833,24 +833,37 @@ constexpr uint8_t HCI_LE_STATES_INIT_MASTER_SLAVE_BIT = 41;
             HCI_PKT_TYPES_MASK_DM3 | HCI_PKT_TYPES_MASK_DH3 |                 \
             HCI_PKT_TYPES_MASK_DM5 | HCI_PKT_TYPES_MASK_DH5)) != 0))
 
+/*
+ * Definitions for eSCO packet type masks (BT1.2 and BT2.0 definitions)
+*/
+#define HCI_ESCO_PKT_TYPES_MASK_HV1 0x0001
+#define HCI_ESCO_PKT_TYPES_MASK_HV2 0x0002
+#define HCI_ESCO_PKT_TYPES_MASK_HV3 0x0004
+#define HCI_ESCO_PKT_TYPES_MASK_EV3 0x0008
+#define HCI_ESCO_PKT_TYPES_MASK_EV4 0x0010
+#define HCI_ESCO_PKT_TYPES_MASK_EV5 0x0020
+#define HCI_ESCO_PKT_TYPES_MASK_NO_2_EV3 0x0040
+#define HCI_ESCO_PKT_TYPES_MASK_NO_3_EV3 0x0080
+#define HCI_ESCO_PKT_TYPES_MASK_NO_2_EV5 0x0100
+#define HCI_ESCO_PKT_TYPES_MASK_NO_3_EV5 0x0200
+
 /* Packet type should be one of valid but at least one should be specified for
  * 1.2 */
-#define HCI_VALID_ESCO_PKT_TYPE(t)                                           \
-  (((((t) &                                                                  \
-      ~(HCI_ESCO_PKT_TYPES_MASK_EV3 | HCI_ESCO_PKT_TYPES_MASK_EV4 |          \
-        HCI_ESCO_PKT_TYPES_MASK_EV5)) == 0)) &&                              \
-   ((t) != 0)) /* Packet type should be one of valid but at least one should \
-                  be specified */
-
-#define HCI_VALID_ESCO_SCOPKT_TYPE(t)                           \
-  (((((t) &                                                     \
-      ~(ESCO_PKT_TYPES_MASK_HV1 | HCI_ESCO_PKT_TYPES_MASK_HV2 | \
-        HCI_ESCO_PKT_TYPES_MASK_HV3)) == 0)) &&                 \
+#define HCI_VALID_ESCO_PKT_TYPE(t)                                  \
+  (((((t) &                                                         \
+      ~(HCI_ESCO_PKT_TYPES_MASK_EV3 | HCI_ESCO_PKT_TYPES_MASK_EV4 | \
+        HCI_ESCO_PKT_TYPES_MASK_EV5)) == 0)) &&                     \
+   ((t) != 0))
+
+#define HCI_VALID_ESCO_SCOPKT_TYPE(t)                               \
+  (((((t) &                                                         \
+      ~(HCI_ESCO_PKT_TYPES_MASK_HV1 | HCI_ESCO_PKT_TYPES_MASK_HV2 | \
+        HCI_ESCO_PKT_TYPES_MASK_HV3)) == 0)) &&                     \
    ((t) != 0))
 
 #define HCI_VALID_SCO_ALL_PKT_TYPE(t)                                         \
   (((((t) &                                                                   \
-      ~(ESCO_PKT_TYPES_MASK_HV1 | HCI_ESCO_PKT_TYPES_MASK_HV2 |               \
+      ~(HCI_ESCO_PKT_TYPES_MASK_HV1 | HCI_ESCO_PKT_TYPES_MASK_HV2 |           \
         HCI_ESCO_PKT_TYPES_MASK_HV3 | HCI_ESCO_PKT_TYPES_MASK_EV3 |           \
         HCI_ESCO_PKT_TYPES_MASK_EV4 | HCI_ESCO_PKT_TYPES_MASK_EV5)) == 0)) && \
    ((t) != 0))
@@ -1662,5 +1675,1213 @@ typedef struct {
 #define HCI_LE_ENH_TX_TEST_SUPPORTED(x) ((x)[36] & 0x01)
 
 #define HCI_LE_SET_PRIVACY_MODE_SUPPORTED(x) ((x)[39] & 0x04)
+/* Supported Commands Byte 0 */
+#define HCI_SUPP_COMMANDS_INQUIRY_MASK 0x01
+#define HCI_SUPP_COMMANDS_INQUIRY_OFF 0
+#define HCI_INQUIRY_SUPPORTED(x) \
+  ((x)[HCI_SUPP_COMMANDS_INQUIRY_OFF] & HCI_SUPP_COMMANDS_INQUIRY_MASK)
+
+#define HCI_SUPP_COMMANDS_INQUIRY_CANCEL_MASK 0x02
+#define HCI_SUPP_COMMANDS_INQUIRY_CANCEL_OFF 0
+#define HCI_INQUIRY_CANCEL_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_INQUIRY_CANCEL_OFF] & \
+   HCI_SUPP_COMMANDS_INQUIRY_CANCEL_MASK)
+
+#define HCI_SUPP_COMMANDS_PERIODIC_INQUIRY_MASK 0x04
+#define HCI_SUPP_COMMANDS_PERIODIC_INQUIRY_OFF 0
+#define HCI_PERIODIC_INQUIRY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_PERIODIC_INQUIRY_OFF] & \
+   HCI_SUPP_COMMANDS_PERIODIC_INQUIRY_MASK)
+
+#define HCI_SUPP_COMMANDS_EXIT_PERIODIC_INQUIRY_MASK 0x08
+#define HCI_SUPP_COMMANDS_EXIT_PERIODIC_INQUIRY_OFF 0
+#define HCI_EXIT_PERIODIC_INQUIRY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_EXIT_PERIODIC_INQUIRY_OFF] & \
+   HCI_SUPP_COMMANDS_EXIT_PERIODIC_INQUIRY_MASK)
+
+#define HCI_SUPP_COMMANDS_CREATE_CONN_MASK 0x10
+#define HCI_SUPP_COMMANDS_CREATE_CONN_OFF 0
+#define HCI_CREATE_CONN_SUPPORTED(x) \
+  ((x)[HCI_SUPP_COMMANDS_CREATE_CONN_OFF] & HCI_SUPP_COMMANDS_CREATE_CONN_MASK)
+
+#define HCI_SUPP_COMMANDS_DISCONNECT_MASK 0x20
+#define HCI_SUPP_COMMANDS_DISCONNECT_OFF 0
+#define HCI_DISCONNECT_SUPPORTED(x) \
+  ((x)[HCI_SUPP_COMMANDS_DISCONNECT_OFF] & HCI_SUPP_COMMANDS_DISCONNECT_MASK)
+
+#define HCI_SUPP_COMMANDS_ADD_SCO_CONN_MASK 0x40
+#define HCI_SUPP_COMMANDS_ADD_SCO_CONN_OFF 0
+#define HCI_ADD_SCO_CONN_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_ADD_SCO_CONN_OFF] & \
+   HCI_SUPP_COMMANDS_ADD_SCO_CONN_MASK)
+
+#define HCI_SUPP_COMMANDS_CANCEL_CREATE_CONN_MASK 0x80
+#define HCI_SUPP_COMMANDS_CANCEL_CREATE_CONN_OFF 0
+#define HCI_CANCEL_CREATE_CONN_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_CANCEL_CREATE_CONN_OFF] & \
+   HCI_SUPP_COMMANDS_CANCEL_CREATE_CONN_MASK)
+
+#define HCI_SUPP_COMMANDS_ACCEPT_CONN_REQUEST_MASK 0x01
+#define HCI_SUPP_COMMANDS_ACCEPT_CONN_REQUEST_OFF 1
+#define HCI_ACCEPT_CONN_REQUEST_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_ACCEPT_CONN_REQUEST_OFF] & \
+   HCI_SUPP_COMMANDS_ACCEPT_CONN_REQUEST_MASK)
+
+#define HCI_SUPP_COMMANDS_REJECT_CONN_REQUEST_MASK 0x02
+#define HCI_SUPP_COMMANDS_REJECT_CONN_REQUEST_OFF 1
+#define HCI_REJECT_CONN_REQUEST_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_REJECT_CONN_REQUEST_OFF] & \
+   HCI_SUPP_COMMANDS_REJECT_CONN_REQUEST_MASK)
+
+#define HCI_SUPP_COMMANDS_LINK_KEY_REQUEST_REPLY_MASK 0x04
+#define HCI_SUPP_COMMANDS_LINK_KEY_REQUEST_REPLY_OFF 1
+#define HCI_LINK_KEY_REQUEST_REPLY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_LINK_KEY_REQUEST_REPLY_OFF] & \
+   HCI_SUPP_COMMANDS_LINK_KEY_REQUEST_REPLY_MASK)
+
+#define HCI_SUPP_COMMANDS_LINK_KEY_REQUEST_NEG_REPLY_MASK 0x08
+#define HCI_SUPP_COMMANDS_LINK_KEY_REQUEST_NEG_REPLY_OFF 1
+#define HCI_LINK_KEY_REQUEST_NEG_REPLY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_LINK_KEY_REQUEST_NEG_REPLY_OFF] & \
+   HCI_SUPP_COMMANDS_LINK_KEY_REQUEST_NEG_REPLY_MASK)
+
+#define HCI_SUPP_COMMANDS_PIN_CODE_REQUEST_REPLY_MASK 0x10
+#define HCI_SUPP_COMMANDS_PIN_CODE_REQUEST_REPLY_OFF 1
+#define HCI_PIN_CODE_REQUEST_REPLY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_PIN_CODE_REQUEST_REPLY_OFF] & \
+   HCI_SUPP_COMMANDS_PIN_CODE_REQUEST_REPLY_MASK)
+
+#define HCI_SUPP_COMMANDS_PIN_CODE_REQUEST_NEG_REPLY_MASK 0x20
+#define HCI_SUPP_COMMANDS_PIN_CODE_REQUEST_NEG_REPLY_OFF 1
+#define HCI_PIN_CODE_REQUEST_NEG_REPLY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_PIN_CODE_REQUEST_NEG_REPLY_OFF] & \
+   HCI_SUPP_COMMANDS_PIN_CODE_REQUEST_NEG_REPLY_MASK)
+
+#define HCI_SUPP_COMMANDS_CHANGE_CONN_PKT_TYPE_MASK 0x40
+#define HCI_SUPP_COMMANDS_CHANGE_CONN_PKT_TYPE_OFF 1
+#define HCI_CHANGE_CONN_PKT_TYPE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_CHANGE_CONN_PKT_TYPE_OFF] & \
+   HCI_SUPP_COMMANDS_CHANGE_CONN_PKT_TYPE_MASK)
+
+#define HCI_SUPP_COMMANDS_AUTH_REQUEST_MASK 0x80
+#define HCI_SUPP_COMMANDS_AUTH_REQUEST_OFF 1
+#define HCI_AUTH_REQUEST_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_AUTH_REQUEST_OFF] & \
+   HCI_SUPP_COMMANDS_AUTH_REQUEST_MASK)
+
+#define HCI_SUPP_COMMANDS_SET_CONN_ENCRYPTION_MASK 0x01
+#define HCI_SUPP_COMMANDS_SET_CONN_ENCRYPTION_OFF 2
+#define HCI_SET_CONN_ENCRYPTION_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_SET_CONN_ENCRYPTION_OFF] & \
+   HCI_SUPP_COMMANDS_SET_CONN_ENCRYPTION_MASK)
+
+#define HCI_SUPP_COMMANDS_CHANGE_CONN_LINK_KEY_MASK 0x02
+#define HCI_SUPP_COMMANDS_CHANGE_CONN_LINK_KEY_OFF 2
+#define HCI_CHANGE_CONN_LINK_KEY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_CHANGE_CONN_LINK_KEY_OFF] & \
+   HCI_SUPP_COMMANDS_CHANGE_CONN_LINK_KEY_MASK)
+
+#define HCI_SUPP_COMMANDS_MASTER_LINK_KEY_MASK 0x04
+#define HCI_SUPP_COMMANDS_MASTER_LINK_KEY_OFF 2
+#define HCI_MASTER_LINK_KEY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_MASTER_LINK_KEY_OFF] & \
+   HCI_SUPP_COMMANDS_MASTER_LINK_KEY_MASK)
+
+#define HCI_SUPP_COMMANDS_REMOTE_NAME_REQUEST_MASK 0x08
+#define HCI_SUPP_COMMANDS_REMOTE_NAME_REQUEST_OFF 2
+#define HCI_REMOTE_NAME_REQUEST_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_REMOTE_NAME_REQUEST_OFF] & \
+   HCI_SUPP_COMMANDS_REMOTE_NAME_REQUEST_MASK)
+
+#define HCI_SUPP_COMMANDS_CANCEL_REMOTE_NAME_REQUEST_MASK 0x10
+#define HCI_SUPP_COMMANDS_CANCEL_REMOTE_NAME_REQUEST_OFF 2
+#define HCI_CANCEL_REMOTE_NAME_REQUEST_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_CANCEL_REMOTE_NAME_REQUEST_OFF] & \
+   HCI_SUPP_COMMANDS_CANCEL_REMOTE_NAME_REQUEST_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_REMOTE_SUPP_FEATURES_MASK 0x20
+#define HCI_SUPP_COMMANDS_READ_REMOTE_SUPP_FEATURES_OFF 2
+#define HCI_READ_REMOTE_SUPP_FEATURES_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_REMOTE_SUPP_FEATURES_OFF] & \
+   HCI_SUPP_COMMANDS_READ_REMOTE_SUPP_FEATURES_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_REMOTE_EXT_FEATURES_MASK 0x40
+#define HCI_SUPP_COMMANDS_READ_REMOTE_EXT_FEATURES_OFF 2
+#define HCI_READ_REMOTE_EXT_FEATURES_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_REMOTE_EXT_FEATURES_OFF] & \
+   HCI_SUPP_COMMANDS_READ_REMOTE_EXT_FEATURES_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_REMOTE_VER_INFO_MASK 0x80
+#define HCI_SUPP_COMMANDS_READ_REMOTE_VER_INFO_OFF 2
+#define HCI_READ_REMOTE_VER_INFO_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_REMOTE_VER_INFO_OFF] & \
+   HCI_SUPP_COMMANDS_READ_REMOTE_VER_INFO_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_CLOCK_OFFSET_MASK 0x01
+#define HCI_SUPP_COMMANDS_READ_CLOCK_OFFSET_OFF 3
+#define HCI_READ_CLOCK_OFFSET_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_CLOCK_OFFSET_OFF] & \
+   HCI_SUPP_COMMANDS_READ_CLOCK_OFFSET_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_LMP_HANDLE_MASK 0x02
+#define HCI_SUPP_COMMANDS_READ_LMP_HANDLE_OFF 3
+#define HCI_READ_LMP_HANDLE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_LMP_HANDLE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_LMP_HANDLE_MASK)
+
+#define HCI_SUPP_COMMANDS_HOLD_MODE_CMD_MASK 0x02
+#define HCI_SUPP_COMMANDS_HOLD_MODE_CMD_OFF 4
+#define HCI_HOLD_MODE_CMD_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_HOLD_MODE_CMD_OFF] & \
+   HCI_SUPP_COMMANDS_HOLD_MODE_CMD_MASK)
+
+#define HCI_SUPP_COMMANDS_SNIFF_MODE_CMD_MASK 0x04
+#define HCI_SUPP_COMMANDS_SNIFF_MODE_CMD_OFF 4
+#define HCI_SNIFF_MODE_CMD_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_SNIFF_MODE_CMD_OFF] & \
+   HCI_SUPP_COMMANDS_SNIFF_MODE_CMD_MASK)
+
+#define HCI_SUPP_COMMANDS_EXIT_SNIFF_MODE_MASK 0x08
+#define HCI_SUPP_COMMANDS_EXIT_SNIFF_MODE_OFF 4
+#define HCI_EXIT_SNIFF_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_EXIT_SNIFF_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_EXIT_SNIFF_MODE_MASK)
+
+#define HCI_SUPP_COMMANDS_PARK_STATE_MASK 0x10
+#define HCI_SUPP_COMMANDS_PARK_STATE_OFF 4
+#define HCI_PARK_STATE_SUPPORTED(x) \
+  ((x)[HCI_SUPP_COMMANDS_PARK_STATE_OFF] & HCI_SUPP_COMMANDS_PARK_STATE_MASK)
+
+#define HCI_SUPP_COMMANDS_EXIT_PARK_STATE_MASK 0x20
+#define HCI_SUPP_COMMANDS_EXIT_PARK_STATE_OFF 4
+#define HCI_EXIT_PARK_STATE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_EXIT_PARK_STATE_OFF] & \
+   HCI_SUPP_COMMANDS_EXIT_PARK_STATE_MASK)
+
+#define HCI_SUPP_COMMANDS_QOS_SETUP_MASK 0x40
+#define HCI_SUPP_COMMANDS_QOS_SETUP_OFF 4
+#define HCI_QOS_SETUP_SUPPORTED(x) \
+  ((x)[HCI_SUPP_COMMANDS_QOS_SETUP_OFF] & HCI_SUPP_COMMANDS_QOS_SETUP_MASK)
+
+#define HCI_SUPP_COMMANDS_ROLE_DISCOVERY_MASK 0x80
+#define HCI_SUPP_COMMANDS_ROLE_DISCOVERY_OFF 4
+#define HCI_ROLE_DISCOVERY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_ROLE_DISCOVERY_OFF] & \
+   HCI_SUPP_COMMANDS_ROLE_DISCOVERY_MASK)
+
+#define HCI_SUPP_COMMANDS_SWITCH_ROLE_MASK 0x01
+#define HCI_SUPP_COMMANDS_SWITCH_ROLE_OFF 5
+#define HCI_SWITCH_ROLE_SUPPORTED(x) \
+  ((x)[HCI_SUPP_COMMANDS_SWITCH_ROLE_OFF] & HCI_SUPP_COMMANDS_SWITCH_ROLE_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_LINK_POLICY_SET_MASK 0x02
+#define HCI_SUPP_COMMANDS_READ_LINK_POLICY_SET_OFF 5
+#define HCI_READ_LINK_POLICY_SET_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_LINK_POLICY_SET_OFF] & \
+   HCI_SUPP_COMMANDS_READ_LINK_POLICY_SET_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_LINK_POLICY_SET_MASK 0x04
+#define HCI_SUPP_COMMANDS_WRITE_LINK_POLICY_SET_OFF 5
+#define HCI_WRITE_LINK_POLICY_SET_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_LINK_POLICY_SET_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_LINK_POLICY_SET_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_DEF_LINK_POLICY_SET_MASK 0x08
+#define HCI_SUPP_COMMANDS_READ_DEF_LINK_POLICY_SET_OFF 5
+#define HCI_READ_DEF_LINK_POLICY_SET_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_DEF_LINK_POLICY_SET_OFF] & \
+   HCI_SUPP_COMMANDS_READ_DEF_LINK_POLICY_SET_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_DEF_LINK_POLICY_SET_MASK 0x10
+#define HCI_SUPP_COMMANDS_WRITE_DEF_LINK_POLICY_SET_OFF 5
+#define HCI_WRITE_DEF_LINK_POLICY_SET_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_DEF_LINK_POLICY_SET_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_DEF_LINK_POLICY_SET_MASK)
+
+#define HCI_SUPP_COMMANDS_FLOW_SPECIFICATION_MASK 0x20
+#define HCI_SUPP_COMMANDS_FLOW_SPECIFICATION_OFF 5
+#define HCI_FLOW_SPECIFICATION_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_FLOW_SPECIFICATION_OFF] & \
+   HCI_SUPP_COMMANDS_FLOW_SPECIFICATION_MASK)
+
+#define HCI_SUPP_COMMANDS_SET_EVENT_MASK_MASK 0x40
+#define HCI_SUPP_COMMANDS_SET_EVENT_MASK_OFF 5
+#define HCI_SET_EVENT_MASK_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_SET_EVENT_MASK_OFF] & \
+   HCI_SUPP_COMMANDS_SET_EVENT_MASK_MASK)
+
+#define HCI_SUPP_COMMANDS_RESET_MASK 0x80
+#define HCI_SUPP_COMMANDS_RESET_OFF 5
+#define HCI_RESET_SUPPORTED(x) \
+  ((x)[HCI_SUPP_COMMANDS_RESET_OFF] & HCI_SUPP_COMMANDS_RESET_MASK)
+
+#define HCI_SUPP_COMMANDS_SET_EVENT_FILTER_MASK 0x01
+#define HCI_SUPP_COMMANDS_SET_EVENT_FILTER_OFF 6
+#define HCI_SET_EVENT_FILTER_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_SET_EVENT_FILTER_OFF] & \
+   HCI_SUPP_COMMANDS_SET_EVENT_FILTER_MASK)
+
+#define HCI_SUPP_COMMANDS_FLUSH_MASK 0x02
+#define HCI_SUPP_COMMANDS_FLUSH_OFF 6
+#define HCI_FLUSH_SUPPORTED(x) \
+  ((x)[HCI_SUPP_COMMANDS_FLUSH_OFF] & HCI_SUPP_COMMANDS_FLUSH_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_PIN_TYPE_MASK 0x04
+#define HCI_SUPP_COMMANDS_READ_PIN_TYPE_OFF 6
+#define HCI_READ_PIN_TYPE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_PIN_TYPE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_PIN_TYPE_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_PIN_TYPE_MASK 0x08
+#define HCI_SUPP_COMMANDS_WRITE_PIN_TYPE_OFF 6
+#define HCI_WRITE_PIN_TYPE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_PIN_TYPE_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_PIN_TYPE_MASK)
+
+#define HCI_SUPP_COMMANDS_CREATE_NEW_UNIT_KEY_MASK 0x10
+#define HCI_SUPP_COMMANDS_CREATE_NEW_UNIT_KEY_OFF 6
+#define HCI_CREATE_NEW_UNIT_KEY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_CREATE_NEW_UNIT_KEY_OFF] & \
+   HCI_SUPP_COMMANDS_CREATE_NEW_UNIT_KEY_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_STORED_LINK_KEY_MASK 0x20
+#define HCI_SUPP_COMMANDS_READ_STORED_LINK_KEY_OFF 6
+#define HCI_READ_STORED_LINK_KEY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_STORED_LINK_KEY_OFF] & \
+   HCI_SUPP_COMMANDS_READ_STORED_LINK_KEY_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_STORED_LINK_KEY_MASK 0x40
+#define HCI_SUPP_COMMANDS_WRITE_STORED_LINK_KEY_OFF 6
+#define HCI_WRITE_STORED_LINK_KEY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_STORED_LINK_KEY_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_STORED_LINK_KEY_MASK)
+
+#define HCI_SUPP_COMMANDS_DELETE_STORED_LINK_KEY_MASK 0x80
+#define HCI_SUPP_COMMANDS_DELETE_STORED_LINK_KEY_OFF 6
+#define HCI_DELETE_STORED_LINK_KEY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_DELETE_STORED_LINK_KEY_OFF] & \
+   HCI_SUPP_COMMANDS_DELETE_STORED_LINK_KEY_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_LOCAL_NAME_MASK 0x01
+#define HCI_SUPP_COMMANDS_WRITE_LOCAL_NAME_OFF 7
+#define HCI_WRITE_LOCAL_NAME_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_LOCAL_NAME_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_LOCAL_NAME_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_LOCAL_NAME_MASK 0x02
+#define HCI_SUPP_COMMANDS_READ_LOCAL_NAME_OFF 7
+#define HCI_READ_LOCAL_NAME_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_LOCAL_NAME_OFF] & \
+   HCI_SUPP_COMMANDS_READ_LOCAL_NAME_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_CONN_ACCEPT_TOUT_MASK 0x04
+#define HCI_SUPP_COMMANDS_READ_CONN_ACCEPT_TOUT_OFF 7
+#define HCI_READ_CONN_ACCEPT_TOUT_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_CONN_ACCEPT_TOUT_OFF] & \
+   HCI_SUPP_COMMANDS_READ_CONN_ACCEPT_TOUT_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_CONN_ACCEPT_TOUT_MASK 0x08
+#define HCI_SUPP_COMMANDS_WRITE_CONN_ACCEPT_TOUT_OFF 7
+#define HCI_WRITE_CONN_ACCEPT_TOUT_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_CONN_ACCEPT_TOUT_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_CONN_ACCEPT_TOUT_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_PAGE_TOUT_MASK 0x10
+#define HCI_SUPP_COMMANDS_READ_PAGE_TOUT_OFF 7
+#define HCI_READ_PAGE_TOUT_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_PAGE_TOUT_OFF] & \
+   HCI_SUPP_COMMANDS_READ_PAGE_TOUT_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_PAGE_TOUT_MASK 0x20
+#define HCI_SUPP_COMMANDS_WRITE_PAGE_TOUT_OFF 7
+#define HCI_WRITE_PAGE_TOUT_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_PAGE_TOUT_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_PAGE_TOUT_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_SCAN_ENABLE_MASK 0x40
+#define HCI_SUPP_COMMANDS_READ_SCAN_ENABLE_OFF 7
+#define HCI_READ_SCAN_ENABLE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_SCAN_ENABLE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_SCAN_ENABLE_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_SCAN_ENABLE_MASK 0x80
+#define HCI_SUPP_COMMANDS_WRITE_SCAN_ENABLE_OFF 7
+#define HCI_WRITE_SCAN_ENABLE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_SCAN_ENABLE_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_SCAN_ENABLE_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_PAGE_SCAN_ACTIVITY_MASK 0x01
+#define HCI_SUPP_COMMANDS_READ_PAGE_SCAN_ACTIVITY_OFF 8
+#define HCI_READ_PAGE_SCAN_ACTIVITY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_PAGE_SCAN_ACTIVITY_OFF] & \
+   HCI_SUPP_COMMANDS_READ_PAGE_SCAN_ACTIVITY_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_PAGE_SCAN_ACTIVITY_MASK 0x02
+#define HCI_SUPP_COMMANDS_WRITE_PAGE_SCAN_ACTIVITY_OFF 8
+#define HCI_WRITE_PAGE_SCAN_ACTIVITY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_PAGE_SCAN_ACTIVITY_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_PAGE_SCAN_ACTIVITY_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_INQURIY_SCAN_ACTIVITY_MASK 0x04
+#define HCI_SUPP_COMMANDS_READ_INQURIY_SCAN_ACTIVITY_OFF 8
+#define HCI_READ_INQURIY_SCAN_ACTIVITY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_INQURIY_SCAN_ACTIVITY_OFF] & \
+   HCI_SUPP_COMMANDS_READ_INQURIY_SCAN_ACTIVITY_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_INQURIY_SCAN_ACTIVITY_MASK 0x08
+#define HCI_SUPP_COMMANDS_WRITE_INQURIY_SCAN_ACTIVITY_OFF 8
+#define HCI_WRITE_INQURIY_SCAN_ACTIVITY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_INQURIY_SCAN_ACTIVITY_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_INQURIY_SCAN_ACTIVITY_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_AUTH_ENABLE_MASK 0x10
+#define HCI_SUPP_COMMANDS_READ_AUTH_ENABLE_OFF 8
+#define HCI_READ_AUTH_ENABLE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_AUTH_ENABLE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_AUTH_ENABLE_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_AUTH_ENABLE_MASK 0x20
+#define HCI_SUPP_COMMANDS_WRITE_AUTH_ENABLE_OFF 8
+#define HCI_WRITE_AUTH_ENABLE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_AUTH_ENABLE_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_AUTH_ENABLE_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_ENCRYPT_ENABLE_MASK 0x40
+#define HCI_SUPP_COMMANDS_READ_ENCRYPT_ENABLE_OFF 8
+#define HCI_READ_ENCRYPT_ENABLE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_ENCRYPT_ENABLE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_ENCRYPT_ENABLE_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_ENCRYPT_ENABLE_MASK 0x80
+#define HCI_SUPP_COMMANDS_WRITE_ENCRYPT_ENABLE_OFF 8
+#define HCI_WRITE_ENCRYPT_ENABLE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_ENCRYPT_ENABLE_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_ENCRYPT_ENABLE_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_CLASS_DEVICE_MASK 0x01
+#define HCI_SUPP_COMMANDS_READ_CLASS_DEVICE_OFF 9
+#define HCI_READ_CLASS_DEVICE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_CLASS_DEVICE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_CLASS_DEVICE_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_CLASS_DEVICE_MASK 0x02
+#define HCI_SUPP_COMMANDS_WRITE_CLASS_DEVICE_OFF 9
+#define HCI_WRITE_CLASS_DEVICE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_CLASS_DEVICE_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_CLASS_DEVICE_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_VOICE_SETTING_MASK 0x04
+#define HCI_SUPP_COMMANDS_READ_VOICE_SETTING_OFF 9
+#define HCI_READ_VOICE_SETTING_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_VOICE_SETTING_OFF] & \
+   HCI_SUPP_COMMANDS_READ_VOICE_SETTING_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_VOICE_SETTING_MASK 0x08
+#define HCI_SUPP_COMMANDS_WRITE_VOICE_SETTING_OFF 9
+#define HCI_WRITE_VOICE_SETTING_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_VOICE_SETTING_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_VOICE_SETTING_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_AUTO_FLUSH_TOUT_MASK 0x10
+#define HCI_SUPP_COMMANDS_READ_AUTO_FLUSH_TOUT_OFF 9
+#define HCI_READ_AUTO_FLUSH_TOUT_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_AUTO_FLUSH_TOUT_OFF] & \
+   HCI_SUPP_COMMANDS_READ_AUTO_FLUSH_TOUT_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_AUTO_FLUSH_TOUT_MASK 0x20
+#define HCI_SUPP_COMMANDS_WRITE_AUTO_FLUSH_TOUT_OFF 9
+#define HCI_WRITE_AUTO_FLUSH_TOUT_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_AUTO_FLUSH_TOUT_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_AUTO_FLUSH_TOUT_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_NUM_BROAD_RETRANS_MASK 0x40
+#define HCI_SUPP_COMMANDS_READ_NUM_BROAD_RETRANS_OFF 9
+#define HCI_READ_NUM_BROAD_RETRANS_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_NUM_BROAD_RETRANS_OFF] & \
+   HCI_SUPP_COMMANDS_READ_NUM_BROAD_RETRANS_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_NUM_BROAD_RETRANS_MASK 0x80
+#define HCI_SUPP_COMMANDS_WRITE_NUM_BROAD_RETRANS_OFF 9
+#define HCI_WRITE_NUM_BROAD_RETRANS_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_NUM_BROAD_RETRANS_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_NUM_BROAD_RETRANS_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_HOLD_MODE_ACTIVITY_MASK 0x01
+#define HCI_SUPP_COMMANDS_READ_HOLD_MODE_ACTIVITY_OFF 10
+#define HCI_READ_HOLD_MODE_ACTIVITY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_HOLD_MODE_ACTIVITY_OFF] & \
+   HCI_SUPP_COMMANDS_READ_HOLD_MODE_ACTIVITY_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_HOLD_MODE_ACTIVITY_MASK 0x02
+#define HCI_SUPP_COMMANDS_WRITE_HOLD_MODE_ACTIVITY_OFF 10
+#define HCI_WRITE_HOLD_MODE_ACTIVITY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_HOLD_MODE_ACTIVITY_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_HOLD_MODE_ACTIVITY_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_TRANS_PWR_LEVEL_MASK 0x04
+#define HCI_SUPP_COMMANDS_READ_TRANS_PWR_LEVEL_OFF 10
+#define HCI_READ_TRANS_PWR_LEVEL_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_TRANS_PWR_LEVEL_OFF] & \
+   HCI_SUPP_COMMANDS_READ_TRANS_PWR_LEVEL_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_SYNCH_FLOW_CTRL_ENABLE_MASK 0x08
+#define HCI_SUPP_COMMANDS_READ_SYNCH_FLOW_CTRL_ENABLE_OFF 10
+#define HCI_READ_SYNCH_FLOW_CTRL_ENABLE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_SYNCH_FLOW_CTRL_ENABLE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_SYNCH_FLOW_CTRL_ENABLE_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_SYNCH_FLOW_CTRL_ENABLE_MASK 0x10
+#define HCI_SUPP_COMMANDS_WRITE_SYNCH_FLOW_CTRL_ENABLE_OFF 10
+#define HCI_WRITE_SYNCH_FLOW_CTRL_ENABLE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_SYNCH_FLOW_CTRL_ENABLE_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_SYNCH_FLOW_CTRL_ENABLE_MASK)
+
+#define HCI_SUPP_COMMANDS_SET_HOST_CTRLR_TO_HOST_FC_MASK 0x20
+#define HCI_SUPP_COMMANDS_SET_HOST_CTRLR_TO_HOST_FC_OFF 10
+#define HCI_SET_HOST_CTRLR_TO_HOST_FC_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_SET_HOST_CTRLR_TO_HOST_FC_OFF] & \
+   HCI_SUPP_COMMANDS_SET_HOST_CTRLR_TO_HOST_FC_MASK)
+
+#define HCI_SUPP_COMMANDS_HOST_BUFFER_SIZE_MASK 0x40
+#define HCI_SUPP_COMMANDS_HOST_BUFFER_SIZE_OFF 10
+#define HCI_HOST_BUFFER_SIZE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_HOST_BUFFER_SIZE_OFF] & \
+   HCI_SUPP_COMMANDS_HOST_BUFFER_SIZE_MASK)
+
+#define HCI_SUPP_COMMANDS_HOST_NUM_COMPLETED_PKTS_MASK 0x80
+#define HCI_SUPP_COMMANDS_HOST_NUM_COMPLETED_PKTS_OFF 10
+#define HCI_HOST_NUM_COMPLETED_PKTS_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_HOST_NUM_COMPLETED_PKTS_OFF] & \
+   HCI_SUPP_COMMANDS_HOST_NUM_COMPLETED_PKTS_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_LINK_SUP_TOUT_MASK 0x01
+#define HCI_SUPP_COMMANDS_READ_LINK_SUP_TOUT_OFF 11
+#define HCI_READ_LINK_SUP_TOUT_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_LINK_SUP_TOUT_OFF] & \
+   HCI_SUPP_COMMANDS_READ_LINK_SUP_TOUT_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_LINK_SUP_TOUT_MASK 0x02
+#define HCI_SUPP_COMMANDS_WRITE_LINK_SUP_TOUT_OFF 11
+#define HCI_WRITE_LINK_SUP_TOUT_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_LINK_SUP_TOUT_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_LINK_SUP_TOUT_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_NUM_SUPP_IAC_MASK 0x04
+#define HCI_SUPP_COMMANDS_READ_NUM_SUPP_IAC_OFF 11
+#define HCI_READ_NUM_SUPP_IAC_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_NUM_SUPP_IAC_OFF] & \
+   HCI_SUPP_COMMANDS_READ_NUM_SUPP_IAC_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_CURRENT_IAC_LAP_MASK 0x08
+#define HCI_SUPP_COMMANDS_READ_CURRENT_IAC_LAP_OFF 11
+#define HCI_READ_CURRENT_IAC_LAP_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_CURRENT_IAC_LAP_OFF] & \
+   HCI_SUPP_COMMANDS_READ_CURRENT_IAC_LAP_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_CURRENT_IAC_LAP_MASK 0x10
+#define HCI_SUPP_COMMANDS_WRITE_CURRENT_IAC_LAP_OFF 11
+#define HCI_WRITE_CURRENT_IAC_LAP_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_CURRENT_IAC_LAP_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_CURRENT_IAC_LAP_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_PAGE_SCAN_PER_MODE_MASK 0x20
+#define HCI_SUPP_COMMANDS_READ_PAGE_SCAN_PER_MODE_OFF 11
+#define HCI_READ_PAGE_SCAN_PER_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_PAGE_SCAN_PER_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_PAGE_SCAN_PER_MODE_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_PAGE_SCAN_PER_MODE_MASK 0x40
+#define HCI_SUPP_COMMANDS_WRITE_PAGE_SCAN_PER_MODE_OFF 11
+#define HCI_WRITE_PAGE_SCAN_PER_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_PAGE_SCAN_PER_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_PAGE_SCAN_PER_MODE_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_PAGE_SCAN_MODE_MASK 0x80
+#define HCI_SUPP_COMMANDS_READ_PAGE_SCAN_MODE_OFF 11
+#define HCI_READ_PAGE_SCAN_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_PAGE_SCAN_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_PAGE_SCAN_MODE_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_PAGE_SCAN_MODE_MASK 0x01
+#define HCI_SUPP_COMMANDS_WRITE_PAGE_SCAN_MODE_OFF 12
+#define HCI_WRITE_PAGE_SCAN_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_PAGE_SCAN_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_PAGE_SCAN_MODE_MASK)
+
+#define HCI_SUPP_COMMANDS_SET_AFH_CHNL_CLASS_MASK 0x02
+#define HCI_SUPP_COMMANDS_SET_AFH_CHNL_CLASS_OFF 12
+#define HCI_SET_AFH_CHNL_CLASS_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_SET_AFH_CHNL_CLASS_OFF] & \
+   HCI_SUPP_COMMANDS_SET_AFH_CHNL_CLASS_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_INQUIRY_SCAN_TYPE_MASK 0x10
+#define HCI_SUPP_COMMANDS_READ_INQUIRY_SCAN_TYPE_OFF 12
+#define HCI_READ_INQUIRY_SCAN_TYPE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_INQUIRY_SCAN_TYPE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_INQUIRY_SCAN_TYPE_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_INQUIRY_SCAN_TYPE_MASK 0x20
+#define HCI_SUPP_COMMANDS_WRITE_INQUIRY_SCAN_TYPE_OFF 12
+#define HCI_WRITE_INQUIRY_SCAN_TYPE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_INQUIRY_SCAN_TYPE_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_INQUIRY_SCAN_TYPE_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_INQUIRY_MODE_MASK 0x40
+#define HCI_SUPP_COMMANDS_READ_INQUIRY_MODE_OFF 12
+#define HCI_READ_INQUIRY_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_INQUIRY_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_INQUIRY_MODE_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_INQUIRY_MODE_MASK 0x80
+#define HCI_SUPP_COMMANDS_WRITE_INQUIRY_MODE_OFF 12
+#define HCI_WRITE_INQUIRY_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_INQUIRY_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_INQUIRY_MODE_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_PAGE_SCAN_TYPE_MASK 0x01
+#define HCI_SUPP_COMMANDS_READ_PAGE_SCAN_TYPE_OFF 13
+#define HCI_READ_PAGE_SCAN_TYPE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_PAGE_SCAN_TYPE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_PAGE_SCAN_TYPE_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_PAGE_SCAN_TYPE_MASK 0x02
+#define HCI_SUPP_COMMANDS_WRITE_PAGE_SCAN_TYPE_OFF 13
+#define HCI_WRITE_PAGE_SCAN_TYPE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_PAGE_SCAN_TYPE_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_PAGE_SCAN_TYPE_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_AFH_CHNL_ASSESS_MODE_MASK 0x04
+#define HCI_SUPP_COMMANDS_READ_AFH_CHNL_ASSESS_MODE_OFF 13
+#define HCI_READ_AFH_CHNL_ASSESS_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_AFH_CHNL_ASSESS_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_AFH_CHNL_ASSESS_MODE_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_AFH_CHNL_ASSESS_MODE_MASK 0x08
+#define HCI_SUPP_COMMANDS_WRITE_AFH_CHNL_ASSESS_MODE_OFF 13
+#define HCI_WRITE_AFH_CHNL_ASSESS_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_AFH_CHNL_ASSESS_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_AFH_CHNL_ASSESS_MODE_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_LOCAL_VER_INFO_MASK 0x08
+#define HCI_SUPP_COMMANDS_READ_LOCAL_VER_INFO_OFF 14
+#define HCI_READ_LOCAL_VER_INFO_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_LOCAL_VER_INFO_OFF] & \
+   HCI_SUPP_COMMANDS_READ_LOCAL_VER_INFO_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_LOCAL_SUP_CMDS_MASK 0x10
+#define HCI_SUPP_COMMANDS_READ_LOCAL_SUP_CMDS_OFF 14
+#define HCI_READ_LOCAL_SUP_CMDS_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_LOCAL_SUP_CMDS_OFF] & \
+   HCI_SUPP_COMMANDS_READ_LOCAL_SUP_CMDS_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_LOCAL_SUPP_FEATURES_MASK 0x20
+#define HCI_SUPP_COMMANDS_READ_LOCAL_SUPP_FEATURES_OFF 14
+#define HCI_READ_LOCAL_SUPP_FEATURES_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_LOCAL_SUPP_FEATURES_OFF] & \
+   HCI_SUPP_COMMANDS_READ_LOCAL_SUPP_FEATURES_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_LOCAL_EXT_FEATURES_MASK 0x40
+#define HCI_SUPP_COMMANDS_READ_LOCAL_EXT_FEATURES_OFF 14
+#define HCI_READ_LOCAL_EXT_FEATURES_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_LOCAL_EXT_FEATURES_OFF] & \
+   HCI_SUPP_COMMANDS_READ_LOCAL_EXT_FEATURES_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_BUFFER_SIZE_MASK 0x80
+#define HCI_SUPP_COMMANDS_READ_BUFFER_SIZE_OFF 14
+#define HCI_READ_BUFFER_SIZE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_BUFFER_SIZE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_BUFFER_SIZE_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_COUNTRY_CODE_MASK 0x01
+#define HCI_SUPP_COMMANDS_READ_COUNTRY_CODE_OFF 15
+#define HCI_READ_COUNTRY_CODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_COUNTRY_CODE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_COUNTRY_CODE_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_BD_ADDR_MASK 0x02
+#define HCI_SUPP_COMMANDS_READ_BD_ADDR_OFF 15
+#define HCI_READ_BD_ADDR_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_BD_ADDR_OFF] & \
+   HCI_SUPP_COMMANDS_READ_BD_ADDR_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_FAIL_CONTACT_CNTR_MASK 0x04
+#define HCI_SUPP_COMMANDS_READ_FAIL_CONTACT_CNTR_OFF 15
+#define HCI_READ_FAIL_CONTACT_CNTR_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_FAIL_CONTACT_CNTR_OFF] & \
+   HCI_SUPP_COMMANDS_READ_FAIL_CONTACT_CNTR_MASK)
+
+#define HCI_SUPP_COMMANDS_RESET_FAIL_CONTACT_CNTR_MASK 0x08
+#define HCI_SUPP_COMMANDS_RESET_FAIL_CONTACT_CNTR_OFF 15
+#define HCI_RESET_FAIL_CONTACT_CNTR_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_RESET_FAIL_CONTACT_CNTR_OFF] & \
+   HCI_SUPP_COMMANDS_RESET_FAIL_CONTACT_CNTR_MASK)
+
+#define HCI_SUPP_COMMANDS_GET_LINK_QUALITY_MASK 0x10
+#define HCI_SUPP_COMMANDS_GET_LINK_QUALITY_OFF 15
+#define HCI_GET_LINK_QUALITY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_GET_LINK_QUALITY_OFF] & \
+   HCI_SUPP_COMMANDS_GET_LINK_QUALITY_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_RSSI_MASK 0x20
+#define HCI_SUPP_COMMANDS_READ_RSSI_OFF 15
+#define HCI_READ_RSSI_SUPPORTED(x) \
+  ((x)[HCI_SUPP_COMMANDS_READ_RSSI_OFF] & HCI_SUPP_COMMANDS_READ_RSSI_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_AFH_CH_MAP_MASK 0x40
+#define HCI_SUPP_COMMANDS_READ_AFH_CH_MAP_OFF 15
+#define HCI_READ_AFH_CH_MAP_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_AFH_CH_MAP_OFF] & \
+   HCI_SUPP_COMMANDS_READ_AFH_CH_MAP_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_BD_CLOCK_MASK 0x80
+#define HCI_SUPP_COMMANDS_READ_BD_CLOCK_OFF 15
+#define HCI_READ_BD_CLOCK_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_BD_CLOCK_OFF] & \
+   HCI_SUPP_COMMANDS_READ_BD_CLOCK_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_LOOPBACK_MODE_MASK 0x01
+#define HCI_SUPP_COMMANDS_READ_LOOPBACK_MODE_OFF 16
+#define HCI_READ_LOOPBACK_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_LOOPBACK_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_LOOPBACK_MODE_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_LOOPBACK_MODE_MASK 0x02
+#define HCI_SUPP_COMMANDS_WRITE_LOOPBACK_MODE_OFF 16
+#define HCI_WRITE_LOOPBACK_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_LOOPBACK_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_LOOPBACK_MODE_MASK)
+
+#define HCI_SUPP_COMMANDS_ENABLE_DEV_UNDER_TEST_MASK 0x04
+#define HCI_SUPP_COMMANDS_ENABLE_DEV_UNDER_TEST_OFF 16
+#define HCI_ENABLE_DEV_UNDER_TEST_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_ENABLE_DEV_UNDER_TEST_OFF] & \
+   HCI_SUPP_COMMANDS_ENABLE_DEV_UNDER_TEST_MASK)
+
+#define HCI_SUPP_COMMANDS_SETUP_SYNCH_CONN_MASK 0x08
+#define HCI_SUPP_COMMANDS_SETUP_SYNCH_CONN_OFF 16
+#define HCI_SETUP_SYNCH_CONN_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_SETUP_SYNCH_CONN_OFF] & \
+   HCI_SUPP_COMMANDS_SETUP_SYNCH_CONN_MASK)
+
+#define HCI_SUPP_COMMANDS_ACCEPT_SYNCH_CONN_MASK 0x10
+#define HCI_SUPP_COMMANDS_ACCEPT_SYNCH_CONN_OFF 16
+#define HCI_ACCEPT_SYNCH_CONN_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_ACCEPT_SYNCH_CONN_OFF] & \
+   HCI_SUPP_COMMANDS_ACCEPT_SYNCH_CONN_MASK)
+
+#define HCI_SUPP_COMMANDS_REJECT_SYNCH_CONN_MASK 0x20
+#define HCI_SUPP_COMMANDS_REJECT_SYNCH_CONN_OFF 16
+#define HCI_REJECT_SYNCH_CONN_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_REJECT_SYNCH_CONN_OFF] & \
+   HCI_SUPP_COMMANDS_REJECT_SYNCH_CONN_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_EXT_INQUIRY_RESP_MASK 0x01
+#define HCI_SUPP_COMMANDS_READ_EXT_INQUIRY_RESP_OFF 17
+#define HCI_READ_EXT_INQUIRY_RESP_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_EXT_INQUIRY_RESP_OFF] & \
+   HCI_SUPP_COMMANDS_READ_EXT_INQUIRY_RESP_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_EXT_INQUIRY_RESP_MASK 0x02
+#define HCI_SUPP_COMMANDS_WRITE_EXT_INQUIRY_RESP_OFF 17
+#define HCI_WRITE_EXT_INQUIRY_RESP_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_EXT_INQUIRY_RESP_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_EXT_INQUIRY_RESP_MASK)
+
+#define HCI_SUPP_COMMANDS_REFRESH_ENCRYPTION_KEY_MASK 0x04
+#define HCI_SUPP_COMMANDS_REFRESH_ENCRYPTION_KEY_OFF 17
+#define HCI_REFRESH_ENCRYPTION_KEY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_REFRESH_ENCRYPTION_KEY_OFF] & \
+   HCI_SUPP_COMMANDS_REFRESH_ENCRYPTION_KEY_MASK)
+
+/* Octet 17, bit 3 is reserved */
+
+#define HCI_SUPP_COMMANDS_SNIFF_SUB_RATE_MASK 0x10
+#define HCI_SUPP_COMMANDS_SNIFF_SUB_RATE_OFF 17
+#define HCI_SNIFF_SUB_RATE_CMD_SUPPORTED(x)    \
+  ((x)[HCI_SUPP_COMMANDS_SNIFF_SUB_RATE_OFF] & \
+   HCI_SUPP_COMMANDS_SNIFF_SUB_RATE_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_SIMPLE_PAIRING_MODE_MASK 0x20
+#define HCI_SUPP_COMMANDS_READ_SIMPLE_PAIRING_MODE_OFF 17
+#define HCI_READ_SIMPLE_PAIRING_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_SIMPLE_PAIRING_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_SIMPLE_PAIRING_MODE_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_SIMPLE_PAIRING_MODE_MASK 0x40
+#define HCI_SUPP_COMMANDS_WRITE_SIMPLE_PAIRING_MODE_OFF 17
+#define HCI_WRITE_SIMPLE_PAIRING_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_SIMPLE_PAIRING_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_SIMPLE_PAIRING_MODE_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_LOCAL_OOB_DATA_MASK 0x80
+#define HCI_SUPP_COMMANDS_READ_LOCAL_OOB_DATA_OFF 17
+#define HCI_READ_LOCAL_OOB_DATA_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_LOCAL_OOB_DATA_OFF] & \
+   HCI_SUPP_COMMANDS_READ_LOCAL_OOB_DATA_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_INQUIRY_RESPONSE_TX_POWER_MASK 0x01
+#define HCI_SUPP_COMMANDS_READ_INQUIRY_RESPONSE_TX_POWER_OFF 18
+#define HCI_READ_INQUIRY_RESPONSE_TX_POWER_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_INQUIRY_RESPONSE_TX_POWER_OFF] & \
+   HCI_SUPP_COMMANDS_READ_INQUIRY_RESPONSE_TX_POWER_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_INQUIRY_RESPONSE_TX_POWER_MASK 0x02
+#define HCI_SUPP_COMMANDS_WRITE_INQUIRY_RESPONSE_TX_POWER_OFF 18
+#define HCI_WRITE_INQUIRY_RESPONSE_TX_POWER_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_INQUIRY_RESPONSE_TX_POWER_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_INQUIRY_RESPONSE_TX_POWER_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_DEFAULT_ERRONEOUS_DATA_REPORTING_MASK 0x04
+#define HCI_SUPP_COMMANDS_READ_DEFAULT_ERRONEOUS_DATA_REPORTING_OFF 18
+#define HCI_READ_DEFAULT_ERRONEOUS_DATA_REPORTING_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_DEFAULT_ERRONEOUS_DATA_REPORTING_OFF] & \
+   HCI_SUPP_COMMANDS_READ_DEFAULT_ERRONEOUS_DATA_REPORTING_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_DEFAULT_ERRONEOUS_DATA_REPORTING_MASK 0x08
+#define HCI_SUPP_COMMANDS_WRITE_DEFAULT_ERRONEOUS_DATA_REPORTING_OFF 18
+#define HCI_WRITE_DEFAULT_ERRONEOUS_DATA_REPORTING_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_DEFAULT_ERRONEOUS_DATA_REPORTING_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_DEFAULT_ERRONEOUS_DATA_REPORTING_MASK)
+
+#define HCI_SUPP_COMMANDS_IO_CAPABILITY_REQUEST_REPLY_MASK 0x80
+#define HCI_SUPP_COMMANDS_IO_CAPABILITY_REQUEST_REPLY_OFF 18
+#define HCI_IO_CAPABILITY_REQUEST_REPLY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_IO_CAPABILITY_REQUEST_REPLY_OFF] & \
+   HCI_SUPP_COMMANDS_IO_CAPABILITY_REQUEST_REPLY_MASK)
+
+#define HCI_SUPP_COMMANDS_USER_CONFIRMATION_REQUEST_REPLY_MASK 0x01
+#define HCI_SUPP_COMMANDS_USER_CONFIRMATION_REQUEST_REPLY_OFF 19
+#define HCI_USER_CONFIRMATION_REQUEST_REPLY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_USER_CONFIRMATION_REQUEST_REPLY_OFF] & \
+   HCI_SUPP_COMMANDS_USER_CONFIRMATION_REQUEST_REPLY_MASK)
+
+#define HCI_SUPP_COMMANDS_USER_CONFIRMATION_REQUEST_NEG_REPLY_MASK 0x02
+#define HCI_SUPP_COMMANDS_USER_CONFIRMATION_REQUEST_NEG_REPLY_OFF 19
+#define HCI_USER_CONFIRMATION_REQUEST_NEG_REPLY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_USER_CONFIRMATION_REQUEST_NEG_REPLY_OFF] & \
+   HCI_SUPP_COMMANDS_USER_CONFIRMATION_REQUEST_NEG_REPLY_MASK)
+
+#define HCI_SUPP_COMMANDS_USER_PASSKEY_REQUEST_REPLY_MASK 0x04
+#define HCI_SUPP_COMMANDS_USER_PASSKEY_REQUEST_REPLY_OFF 19
+#define HCI_USER_PASSKEY_REQUEST_REPLY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_USER_PASSKEY_REQUEST_REPLY_OFF] & \
+   HCI_SUPP_COMMANDS_USER_PASSKEY_REQUEST_REPLY_MASK)
+
+#define HCI_SUPP_COMMANDS_USER_PASSKEY_REQUEST_NEG_REPLY_MASK 0x08
+#define HCI_SUPP_COMMANDS_USER_PASSKEY_REQUEST_NEG_REPLY_OFF 19
+#define HCI_USER_PASSKEY_REQUEST_NEG_REPLY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_USER_PASSKEY_REQUEST_NEG_REPLY_OFF] & \
+   HCI_SUPP_COMMANDS_USER_PASSKEY_REQUEST_NEG_REPLY_MASK)
+
+#define HCI_SUPP_COMMANDS_REMOTE_OOB_DATA_REQUEST_REPLY_MASK 0x10
+#define HCI_SUPP_COMMANDS_REMOTE_OOB_DATA_REQUEST_REPLY_OFF 19
+#define HCI_REMOTE_OOB_DATA_REQUEST_REPLY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_REMOTE_OOB_DATA_REQUEST_REPLY_OFF] & \
+   HCI_SUPP_COMMANDS_REMOTE_OOB_DATA_REQUEST_REPLY_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_SIMPLE_PAIRING_DBG_MODE_MASK 0x20
+#define HCI_SUPP_COMMANDS_WRITE_SIMPLE_PAIRING_DBG_MODE_OFF 19
+#define HCI_WRITE_SIMPLE_PAIRING_DBG_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_SIMPLE_PAIRING_DBG_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_SIMPLE_PAIRING_DBG_MODE_MASK)
+
+#define HCI_SUPP_COMMANDS_ENHANCED_FLUSH_MASK 0x40
+#define HCI_SUPP_COMMANDS_ENHANCED_FLUSH_OFF 19
+#define HCI_ENHANCED_FLUSH_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_ENHANCED_FLUSH_OFF] & \
+   HCI_SUPP_COMMANDS_ENHANCED_FLUSH_MASK)
+
+#define HCI_SUPP_COMMANDS_REMOTE_OOB_DATA_REQUEST_NEG_REPLY_MASK 0x80
+#define HCI_SUPP_COMMANDS_REMOTE_OOB_DATA_REQUEST_NEG_REPLY_OFF 19
+#define HCI_REMOTE_OOB_DATA_REQUEST_NEG_REPLY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_REMOTE_OOB_DATA_REQUEST_NEG_REPLY_OFF] & \
+   HCI_SUPP_COMMANDS_REMOTE_OOB_DATA_REQUEST_NEG_REPLY_MASK)
+
+/* Supported Commands (Byte 20) */
+#define HCI_SUPP_COMMANDS_SEND_KEYPRESS_NOTIF_MASK 0x04
+#define HCI_SUPP_COMMANDS_SEND_KEYPRESS_NOTIF_OFF 20
+#define HCI_SEND_NOTIF_SUPPORTED(x)                 \
+  ((x)[HCI_SUPP_COMMANDS_SEND_KEYPRESS_NOTIF_OFF] & \
+   HCI_SUPP_COMMANDS_SEND_KEYPRESS_NOTIF_MASK)
+
+#define HCI_SUPP_COMMANDS_IO_CAP_REQ_NEG_REPLY_MASK 0x08
+#define HCI_SUPP_COMMANDS_IO_CAP_REQ_NEG_REPLY_OFF 20
+#define HCI_IO_CAP_REQ_NEG_REPLY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_IO_CAP_REQ_NEG_REPLY_OFF] & \
+   HCI_SUPP_COMMANDS_IO_CAP_REQ_NEG_REPLY_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_ENCR_KEY_SIZE_MASK 0x10
+#define HCI_SUPP_COMMANDS_READ_ENCR_KEY_SIZE_OFF 20
+#define HCI_READ_ENCR_KEY_SIZE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_ENCR_KEY_SIZE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_ENCR_KEY_SIZE_MASK)
+
+/* Supported Commands (Byte 21) */
+#define HCI_SUPP_COMMANDS_CREATE_PHYSICAL_LINK_MASK 0x01
+#define HCI_SUPP_COMMANDS_CREATE_PHYSICAL_LINK_OFF 21
+#define HCI_CREATE_PHYSICAL_LINK_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_CREATE_PHYSICAL_LINK_OFF] & \
+   HCI_SUPP_COMMANDS_CREATE_PHYSICAL_LINK_MASK)
+
+#define HCI_SUPP_COMMANDS_ACCEPT_PHYSICAL_LINK_MASK 0x02
+#define HCI_SUPP_COMMANDS_ACCEPT_PHYSICAL_LINK_OFF 21
+#define HCI_ACCEPT_PHYSICAL_LINK_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_ACCEPT_PHYSICAL_LINK_OFF] & \
+   HCI_SUPP_COMMANDS_ACCEPT_PHYSICAL_LINK_MASK)
+
+#define HCI_SUPP_COMMANDS_DISCONNECT_PHYSICAL_LINK_MASK 0x04
+#define HCI_SUPP_COMMANDS_DISCONNECT_PHYSICAL_LINK_OFF 21
+#define HCI_DISCONNECT_PHYSICAL_LINK_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_DISCONNECT_PHYSICAL_LINK_OFF] & \
+   HCI_SUPP_COMMANDS_DISCONNECT_PHYSICAL_LINK_MASK)
+
+#define HCI_SUPP_COMMANDS_CREATE_LOGICAL_LINK_MASK 0x08
+#define HCI_SUPP_COMMANDS_CREATE_LOGICAL_LINK_OFF 21
+#define HCI_CREATE_LOGICAL_LINK_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_CREATE_LOGICAL_LINK_OFF] & \
+   HCI_SUPP_COMMANDS_CREATE_LOGICAL_LINK_MASK)
+
+#define HCI_SUPP_COMMANDS_ACCEPT_LOGICAL_LINK_MASK 0x10
+#define HCI_SUPP_COMMANDS_ACCEPT_LOGICAL_LINK_OFF 21
+#define HCI_ACCEPT_LOGICAL_LINK_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_ACCEPT_LOGICAL_LINK_OFF] & \
+   HCI_SUPP_COMMANDS_ACCEPT_LOGICAL_LINK_MASK)
+
+#define HCI_SUPP_COMMANDS_DISCONNECT_LOGICAL_LINK_MASK 0x20
+#define HCI_SUPP_COMMANDS_DISCONNECT_LOGICAL_LINK_OFF 21
+#define HCI_DISCONNECT_LOGICAL_LINK_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_DISCONNECT_LOGICAL_LINK_OFF] & \
+   HCI_SUPP_COMMANDS_DISCONNECT_LOGICAL_LINK_MASK)
+
+#define HCI_SUPP_COMMANDS_LOGICAL_LINK_CANCEL_MASK 0x40
+#define HCI_SUPP_COMMANDS_LOGICAL_LINK_CANCEL_OFF 21
+#define HCI_LOGICAL_LINK_CANCEL_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_LOGICAL_LINK_CANCEL_OFF] & \
+   HCI_SUPP_COMMANDS_LOGICAL_LINK_CANCEL_MASK)
+
+#define HCI_SUPP_COMMANDS_FLOW_SPEC_MODIFY_MASK 0x80
+#define HCI_SUPP_COMMANDS_FLOW_SPEC_MODIFY_OFF 21
+#define HCI_FLOW_SPEC_MODIFY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_FLOW_SPEC_MODIFY_OFF] & \
+   HCI_SUPP_COMMANDS_FLOW_SPEC_MODIFY_MASK)
+
+/* Supported Commands (Byte 22) */
+#define HCI_SUPP_COMMANDS_READ_LOGICAL_LINK_ACCEPT_TIMEOUT_MASK 0x01
+#define HCI_SUPP_COMMANDS_READ_LOGICAL_LINK_ACCEPT_TIMEOUT_OFF 22
+#define HCI_READ_LOGICAL_LINK_ACCEPT_TIMEOUT_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_LOGICAL_LINK_ACCEPT_TIMEOUT_OFF] & \
+   HCI_SUPP_COMMANDS_READ_LOGICAL_LINK_ACCEPT_TIMEOUT_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_LOGICAL_LINK_ACCEPT_TIMEOUT_MASK 0x02
+#define HCI_SUPP_COMMANDS_WRITE_LOGICAL_LINK_ACCEPT_TIMEOUT_OFF 22
+#define HCI_WRITE_LOGICAL_LINK_ACCEPT_TIMEOUT_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_LOGICAL_LINK_ACCEPT_TIMEOUT_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_LOGICAL_LINK_ACCEPT_TIMEOUT_MASK)
+
+#define HCI_SUPP_COMMANDS_SET_EVENT_MASK_PAGE_2_MASK 0x04
+#define HCI_SUPP_COMMANDS_SET_EVENT_MASK_PAGE_2_OFF 22
+#define HCI_SET_EVENT_MASK_PAGE_2_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_SET_EVENT_MASK_PAGE_2_OFF] & \
+   HCI_SUPP_COMMANDS_SET_EVENT_MASK_PAGE_2_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_LOCATION_DATA_MASK 0x08
+#define HCI_SUPP_COMMANDS_READ_LOCATION_DATA_OFF 22
+#define HCI_READ_LOCATION_DATA_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_LOCATION_DATA_OFF] & \
+   HCI_SUPP_COMMANDS_READ_LOCATION_DATA_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_LOCATION_DATA_MASK 0x10
+#define HCI_SUPP_COMMANDS_WRITE_LOCATION_DATA_OFF 22
+#define HCI_WRITE_LOCATION_DATA_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_LOCATION_DATA_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_LOCATION_DATA_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_LOCAL_AMP_INFO_MASK 0x20
+#define HCI_SUPP_COMMANDS_READ_LOCAL_AMP_INFO_OFF 22
+#define HCI_READ_LOCAL_AMP_INFO_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_LOCAL_AMP_INFO_OFF] & \
+   HCI_SUPP_COMMANDS_READ_LOCAL_AMP_INFO_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_LOCAL_AMP_ASSOC_MASK 0x40
+#define HCI_SUPP_COMMANDS_READ_LOCAL_AMP_ASSOC_OFF 22
+#define HCI_READ_LOCAL_AMP_ASSOC_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_LOCAL_AMP_ASSOC_OFF] & \
+   HCI_SUPP_COMMANDS_READ_LOCAL_AMP_ASSOC_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_REMOTE_AMP_ASSOC_MASK 0x80
+#define HCI_SUPP_COMMANDS_WRITE_REMOTE_AMP_ASSOC_OFF 22
+#define HCI_WRITE_REMOTE_AMP_ASSOC_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_REMOTE_AMP_ASSOC_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_REMOTE_AMP_ASSOC_MASK)
+
+/* Supported Commands (Byte 23) */
+#define HCI_SUPP_COMMANDS_READ_FLOW_CONTROL_MODE_MASK 0x01
+#define HCI_SUPP_COMMANDS_READ_FLOW_CONTROL_MODE_OFF 23
+#define HCI_READ_FLOW_CONTROL_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_FLOW_CONTROL_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_FLOW_CONTROL_MODE_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_FLOW_CONTROL_MODE_MASK 0x02
+#define HCI_SUPP_COMMANDS_WRITE_FLOW_CONTROL_MODE_OFF 23
+#define HCI_WRITE_FLOW_CONTROL_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_FLOW_CONTROL_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_FLOW_CONTROL_MODE_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_DATA_BLOCK_SIZE_MASK 0x04
+#define HCI_SUPP_COMMANDS_READ_DATA_BLOCK_SIZE_OFF 23
+#define HCI_READ_DATA_BLOCK_SIZE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_DATA_BLOCK_SIZE_OFF] & \
+   HCI_SUPP_COMMANDS_READ_DATA_BLOCK_SIZE_MASK)
+
+#define HCI_SUPP_COMMANDS_ENABLE_AMP_RCVR_REPORTS_MASK 0x20
+#define HCI_SUPP_COMMANDS_ENABLE_AMP_RCVR_REPORTS_OFF 23
+#define HCI_ENABLE_AMP_RCVR_REPORTS_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_ENABLE_AMP_RCVR_REPORTS_OFF] & \
+   HCI_SUPP_COMMANDS_ENABLE_AMP_RCVR_REPORTS_MASK)
+
+#define HCI_SUPP_COMMANDS_AMP_TEST_END_MASK 0x40
+#define HCI_SUPP_COMMANDS_AMP_TEST_END_OFF 23
+#define HCI_AMP_TEST_END_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_AMP_TEST_END_OFF] & \
+   HCI_SUPP_COMMANDS_AMP_TEST_END_MASK)
+
+#define HCI_SUPP_COMMANDS_AMP_TEST_MASK 0x80
+#define HCI_SUPP_COMMANDS_AMP_TEST_OFF 23
+#define HCI_AMP_TEST_SUPPORTED(x) \
+  ((x)[HCI_SUPP_COMMANDS_AMP_TEST_OFF] & HCI_SUPP_COMMANDS_AMP_TEST_MASK)
+
+/* Supported Commands (Byte 24) */
+#define HCI_SUPP_COMMANDS_READ_TRANSMIT_POWER_LEVEL_MASK 0x01
+#define HCI_SUPP_COMMANDS_READ_TRANSMIT_POWER_LEVEL_OFF 24
+#define HCI_READ_TRANSMIT_POWER_LEVEL_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_TRANSMIT_POWER_LEVEL_OFF] & \
+   HCI_SUPP_COMMANDS_READ_TRANSMIT_POWER_LEVEL_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_BE_FLUSH_TOUT_MASK 0x04
+#define HCI_SUPP_COMMANDS_READ_BE_FLUSH_TOUT_OFF 24
+#define HCI_READ_BE_FLUSH_TOUT_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_BE_FLUSH_TOUT_OFF] & \
+   HCI_SUPP_COMMANDS_READ_BE_FLUSH_TOUT_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_BE_FLUSH_TOUT_MASK 0x08
+#define HCI_SUPP_COMMANDS_WRITE_BE_FLUSH_TOUT_OFF 24
+#define HCI_WRITE_BE_FLUSH_TOUT_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_BE_FLUSH_TOUT_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_BE_FLUSH_TOUT_MASK)
+
+#define HCI_SUPP_COMMANDS_SHORT_RANGE_MODE_MASK 0x10
+#define HCI_SUPP_COMMANDS_SHORT_RANGE_MODE_OFF 24
+#define HCI_SHORT_RANGE_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_SHORT_RANGE_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_SHORT_RANGE_MODE_MASK)
+
+/* LE commands TBD
+ * Supported Commands (Byte 24 continued)
+ * Supported Commands (Byte 25)
+ * Supported Commands (Byte 26)
+ * Supported Commands (Byte 27)
+ * Supported Commands (Byte 28)
+*/
+
+/* Supported Commands (Byte 29) */
+#define HCI_SUPP_COMMANDS_ENH_SETUP_SYNCH_CONN_MASK 0x08
+#define HCI_SUPP_COMMANDS_ENH_SETUP_SYNCH_CONN_OFF 29
+#define HCI_READ_ENH_SETUP_SYNCH_CONN_SUPPORTED(x)   \
+  ((x)[HCI_SUPP_COMMANDS_ENH_SETUP_SYNCH_CONN_OFF] & \
+   HCI_SUPP_COMMANDS_ENH_SETUP_SYNCH_CONN_MASK)
+
+#define HCI_SUPP_COMMANDS_ENH_ACCEPT_SYNCH_CONN_MASK 0x10
+#define HCI_SUPP_COMMANDS_ENH_ACCEPT_SYNCH_CONN_OFF 29
+#define HCI_READ_ENH_ACCEPT_SYNCH_CONN_SUPPORTED(x)   \
+  ((x)[HCI_SUPP_COMMANDS_ENH_ACCEPT_SYNCH_CONN_OFF] & \
+   HCI_SUPP_COMMANDS_ENH_ACCEPT_SYNCH_CONN_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_LOCAL_CODECS_MASK 0x20
+#define HCI_SUPP_COMMANDS_READ_LOCAL_CODECS_OFF 29
+#define HCI_READ_LOCAL_CODECS_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_LOCAL_CODECS_OFF] & \
+   HCI_SUPP_COMMANDS_READ_LOCAL_CODECS_MASK)
+
+#define HCI_SUPP_COMMANDS_SET_MWS_CHANN_PARAM_MASK 0x40
+#define HCI_SUPP_COMMANDS_SET_MWS_CHANN_PARAM_OFF 29
+#define HCI_SET_MWS_CHANNEL_PARAMETERS_SUPPORTED(x) \
+  ((x)[HCI_SUPP_COMMANDS_SET_MWS_CHANN_PARAM_OFF] & \
+   HCI_SUPP_COMMANDS_SET_MWS_CHANN_PARAM_MASK)
+
+#define HCI_SUPP_COMMANDS_SET_EXT_FRAME_CONF_MASK 0x80
+#define HCI_SUPP_COMMANDS_SET_EXT_FRAME_CONF_OFF 29
+#define HCI_SET_EXTERNAL_FRAME_CONFIGURATION_SUPPORTED(x) \
+  ((x)[HCI_SUPP_COMMANDS_SET_EXT_FRAME_CONF_OFF] &        \
+   HCI_SUPP_COMMANDS_SET_EXT_FRAME_CONF_MASK)
+
+/* Supported Commands (Byte 30) */
+#define HCI_SUPP_COMMANDS_SET_MWS_SIGNALING_MASK 0x01
+#define HCI_SUPP_COMMANDS_SET_MWS_SIGNALING_OFF 30
+#define HCI_SET_MWS_SIGNALING_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_SET_MWS_SIGNALING_OFF] & \
+   HCI_SUPP_COMMANDS_SET_MWS_SIGNALING_MASK)
+
+#define HCI_SUPP_COMMANDS_SET_MWS_TRANS_LAYER_MASK 0x02
+#define HCI_SUPP_COMMANDS_SET_MWS_TRANS_LAYER_OFF 30
+#define HCI_SET_MWS_TRANSPORT_LAYER_SUPPORTED(x)    \
+  ((x)[HCI_SUPP_COMMANDS_SET_MWS_TRANS_LAYER_OFF] & \
+   HCI_SUPP_COMMANDS_SET_MWS_TRANS_LAYER_MASK)
+
+#define HCI_SUPP_COMMANDS_SET_MWS_SCAN_FREQ_TABLE_MASK 0x04
+#define HCI_SUPP_COMMANDS_SET_MWS_SCAN_FREQ_TABLE_OFF 30
+#define HCI_SET_MWS_SCAN_FREQUENCY_TABLE_SUPPORTED(x)   \
+  ((x)[HCI_SUPP_COMMANDS_SET_MWS_SCAN_FREQ_TABLE_OFF] & \
+   HCI_SUPP_COMMANDS_SET_MWS_SCAN_FREQ_TABLE_MASK)
+
+#define HCI_SUPP_COMMANDS_GET_TRANS_LAYER_CONF_MASK 0x08
+#define HCI_SUPP_COMMANDS_GET_TRANS_LAYER_CONF_OFF 30
+#define HCI_GET_MWS_TRANS_LAYER_CFG_SUPPORTED(x)     \
+  ((x)[HCI_SUPP_COMMANDS_GET_TRANS_LAYER_CONF_OFF] & \
+   HCI_SUPP_COMMANDS_GET_TRANS_LAYER_CONF_MASK)
+
+#define HCI_SUPP_COMMANDS_SET_MWS_PATTERN_CONF_MASK 0x10
+#define HCI_SUPP_COMMANDS_SET_MWS_PATTERN_CONF_OFF 30
+#define HCI_SET_MWS_PATTERN_CONFIGURATION_SUPPORTED(x) \
+  ((x)[HCI_SUPP_COMMANDS_SET_MWS_PATTERN_CONF_OFF] &   \
+   HCI_SUPP_COMMANDS_SET_MWS_PATTERN_CONF_MASK)
+
+/* Supported Commands (Byte 30 bit 5) */
+#define HCI_SUPP_COMMANDS_SET_TRIG_CLK_CAP_MASK 0x20
+#define HCI_SUPP_COMMANDS_SET_TRIG_CLK_CAP_OFF 30
+#define HCI_SET_TRIG_CLK_CAP_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_SET_TRIG_CLK_CAP_OFF] & \
+   HCI_SUPP_COMMANDS_SET_TRIG_CLK_CAP_MASK)
+
+/* Supported Commands (Byte 30 bit 6-7) */
+#define HCI_SUPP_COMMANDS_TRUNCATED_PAGE 0x06
+#define HCI_SUPP_COMMANDS_TRUNCATED_PAGE_OFF 30
+#define HCI_TRUNCATED_PAGE_SUPPORTED(x) \
+  ((x)[HCI_SUPP_COMMANDS_TRUNCATED_PAGE_OFF] & HCI_SUPP_COMMANDS_TRUNCATED_PAGE)
+
+#define HCI_SUPP_COMMANDS_TRUNCATED_PAGE_CANCEL 0x07
+#define HCI_SUPP_COMMANDS_TRUNCATED_PAGE_CANCEL_OFF 30
+#define HCI_TRUNCATED_PAGE_CANCEL_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_TRUNCATED_PAGE_CANCEL_OFF] & \
+   HCI_SUPP_COMMANDS_TRUNCATED_PAGE_CANCEL)
+
+/* Supported Commands (Byte 31 bit 6-7) */
+#define HCI_SUPP_COMMANDS_SET_CONLESS_SLAVE_BRCST 0x00
+#define HCI_SUPP_COMMANDS_SET_CONLESS_SLAVE_BRCST_OFF 31
+#define HCI_SET_CONLESS_SLAVE_BRCST_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_SET_CONLESS_SLAVE_BRCST_OFF] & \
+   HCI_SUPP_COMMANDS_SET_CONLESS_SLAVE_BRCST)
+
+#define HCI_SUPP_COMMANDS_SET_CONLESS_SLAVE_BRCST_RECEIVE 0x01
+#define HCI_SUPP_COMMANDS_SET_CONLESS_SLAVE_BRCST_RECEIVE_OFF 31
+#define HCI_SET_CONLESS_SLAVE_BRCST_RECEIVE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_SET_CONLESS_SLAVE_BRCST_RECEIVE_OFF] & \
+   HCI_SUPP_COMMANDS_SET_CONLESS_SLAVE_BRCST_RECEIVE)
+
+#define HCI_SUPP_COMMANDS_START_SYNC_TRAIN 0x02
+#define HCI_SUPP_COMMANDS_START_SYNC_TRAIN_OFF 31
+#define HCI_START_SYNC_TRAIN_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_START_SYNC_TRAIN_OFF] & \
+   HCI_SUPP_COMMANDS_START_SYNC_TRAIN)
+
+#define HCI_SUPP_COMMANDS_RECEIVE_SYNC_TRAIN 0x03
+#define HCI_SUPP_COMMANDS_RECEIVE_SYNC_TRAIN_OFF 31
+#define HCI_RECEIVE_SYNC_TRAIN_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_RECEIVE_SYNC_TRAIN_OFF] & \
+   HCI_SUPP_COMMANDS_RECEIVE_SYNC_TRAIN)
+
+#define HCI_SUPP_COMMANDS_SET_RESERVED_LT_ADDR 0x04
+#define HCI_SUPP_COMMANDS_SET_RESERVED_LT_ADDR_OFF 31
+#define HCI_SET_RESERVED_LT_ADDR_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_SET_RESERVED_LT_ADDR_OFF] & \
+   HCI_SUPP_COMMANDS_SET_RESERVED_LT_ADDR)
+
+#define HCI_SUPP_COMMANDS_DELETE_RESERVED_LT_ADDR 0x05
+#define HCI_SUPP_COMMANDS_DELETE_RESERVED_LT_ADDR_OFF 31
+#define HCI_DELETE_RESERVED_LT_ADDR_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_DELETE_RESERVED_LT_ADDR_OFF] & \
+   HCI_SUPP_COMMANDS_DELETE_RESERVED_LT_ADDR)
+
+#define HCI_SUPP_COMMANDS_SET_CONLESS_SLAVE_BRCST_DATA 0x06
+#define HCI_SUPP_COMMANDS_SET_CONLESS_SLAVE_BRCST_DATA_OFF 31
+#define HCI_SET_CONLESS_SLAVE_BRCST_DATA_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_SET_CONLESS_SLAVE_BRCST_DATA_OFF] & \
+   HCI_SUPP_COMMANDS_SET_CONLESS_SLAVE_BRCST_DATA)
+
+#define HCI_SUPP_COMMANDS_READ_SYNC_TRAIN_PARAM 0x07
+#define HCI_SUPP_COMMANDS_READ_SYNC_TRAIN_PARAM_OFF 31
+#define HCI_READ_SYNC_TRAIN_PARAM_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_SYNC_TRAIN_PARAM_OFF] & \
+   HCI_SUPP_COMMANDS_READ_SYNC_TRAIN_PARAM)
+
+/* Supported Commands (Byte 32 bit 0) */
+#define HCI_SUPP_COMMANDS_WRITE_SYNC_TRAIN_PARAM 0x00
+#define HCI_SUPP_COMMANDS_WRITE_SYNC_TRAIN_PARAM_OFF 32
+#define HCI_WRITE_SYNC_TRAIN_PARAM_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_SYNC_TRAIN_PARAM_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_SYNC_TRAIN_PARAM)
+
+#define HCI_SUPP_COMMANDS_REMOTE_OOB_EXTENDED_DATA_REQUEST_REPLY_MASK 0x02
+#define HCI_SUPP_COMMANDS_REMOTE_OOB_EXTENDED_DATA_REQUEST_REPLY_OFF 32
+#define HCI_REMOTE_OOB_EXTENDED_DATA_REQUEST_REPLY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_REMOTE_OOB_EXTENDED_DATA_REQUEST_REPLY_OFF] & \
+   HCI_SUPP_COMMANDS_REMOTE_OOB_EXTENDED_DATA_REQUEST_REPLY_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_SECURE_CONNS_SUPPORT_MASK 0x04
+#define HCI_SUPP_COMMANDS_READ_SECURE_CONNS_SUPPORT_OFF 32
+#define HCI_READ_SECURE_CONNS_SUPPORT_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_SECURE_CONNS_SUPPORT_OFF] & \
+   HCI_SUPP_COMMANDS_READ_SECURE_CONNS_SUPPORT_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_SECURE_CONNS_SUPPORT_MASK 0x08
+#define HCI_SUPP_COMMANDS_WRITE_SECURE_CONNS_SUPPORT_OFF 32
+#define HCI_WRITE_SECURE_CONNS_SUPPORT_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_SECURE_CONNS_SUPPORT_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_SECURE_CONNS_SUPPORT_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_AUTHENT_PAYLOAD_TOUT_MASK 0x10
+#define HCI_SUPP_COMMANDS_READ_AUTHENT_PAYLOAD_TOUT_OFF 32
+#define HCI_READ_AUTHENT_PAYLOAD_TOUT_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_AUTHENT_PAYLOAD_TOUT_OFF] & \
+   HCI_SUPP_COMMANDS_READ_AUTHENT_PAYLOAD_TOUT_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_AUTHENT_PAYLOAD_TOUT_MASK 0x20
+#define HCI_SUPP_COMMANDS_WRITE_AUTHENT_PAYLOAD_TOUT_OFF 32
+#define HCI_WRITE_AUTHENT_PAYLOAD_TOUT_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_AUTHENT_PAYLOAD_TOUT_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_AUTHENT_PAYLOAD_TOUT_MASK)
+
+#define HCI_SUPP_COMMANDS_READ_LOCAL_OOB_EXTENDED_DATA_MASK 0x40
+#define HCI_SUPP_COMMANDS_READ_LOCAL_OOB_EXTENDED_DATA_OFF 32
+#define HCI_READ_LOCAL_OOB_EXTENDED_DATA_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_READ_LOCAL_OOB_EXTENDED_DATA_OFF] & \
+   HCI_SUPP_COMMANDS_READ_LOCAL_OOB_EXTENDED_DATA_MASK)
+
+#define HCI_SUPP_COMMANDS_WRITE_SECURE_CONNECTIONS_TEST_MODE_MASK 0x80
+#define HCI_SUPP_COMMANDS_WRITE_SECURE_CONNECTIONS_TEST_MODE_OFF 32
+#define HCI_WRITE_SECURE_CONNECTIONS_TEST_MODE_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_WRITE_SECURE_CONNECTIONS_TEST_MODE_OFF] & \
+   HCI_SUPP_COMMANDS_WRITE_SECURE_CONNECTIONS_TEST_MODE_MASK)
+
+/* supported LE remote control connection parameter request reply */
+#define HCI_SUPP_COMMANDS_LE_RC_CONN_PARAM_UPD_RPY_MASK 0x10
+#define HCI_SUPP_COMMANDS_LE_RC_CONN_PARAM_UPD_RPY_OFF 33
+#define HCI_LE_RC_CONN_PARAM_UPD_RPY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_LE_RC_CONN_PARAM_UPD_RPY_OFF] & \
+   HCI_SUPP_COMMANDS_LE_RC_CONN_PARAM_UPD_RPY_MASK)
+
+#define HCI_SUPP_COMMANDS_RLE_RC_CONN_PARAM_UPD_NEG_RPY_MASK 0x20
+#define HCI_SUPP_COMMANDS_LE_RC_CONN_PARAM_UPD_NEG_RPY_OFF 33
+#define HCI_LE_RC_CONN_PARAM_UPD_NEG_RPY_SUPPORTED(x)        \
+  ((x)[HCI_SUPP_COMMANDS_LE_RC_CONN_PARAM_UPD_NEG_RPY_OFF] & \
+   HCI_SUPP_COMMANDS_RLE_RC_CONN_PARAM_UPD_NEG_RPY_MASK)
+
+#define HCI_LE_2M_PHY_SUPPORTED(x) (((x)[1] & 0x01))     // BIT 8 SET
+#define HCI_LE_CODED_PHY_SUPPORTED(x) (((x)[1] & 0x08))  // BIT 11 SET
+
+/* LE Advertising Extension related Procedurs */
+#define HCI_LE_EXTENDED_ADVERTISING_SUPPORTED(x) \
+  (((x)[1] & 0x10))  // BIT 12 SET
+#define HCI_LE_PERIODIC_ADVERTISING_SUPPORTED(x) \
+  (((x)[1] & 0x20))  // BIT 13 SET
 
 #endif
diff --git a/system/bt/stack/include/hcimsgs.h b/system/bt/stack/include/hcimsgs.h
index a9097510f..5e6d33af2 100644
--- a/system/bt/stack/include/hcimsgs.h
+++ b/system/bt/stack/include/hcimsgs.h
@@ -21,7 +21,6 @@
 
 #include "bt_target.h"
 #include "bt_types.h"
-#include "device/include/esco_parameters.h"
 #include "hcidefs.h"
 
 #include <base/callback_forward.h>
@@ -227,11 +226,10 @@ extern void btsnd_hcic_rmt_ver_req(
 extern void btsnd_hcic_read_rmt_clk_offset(
     uint16_t handle); /* Remote Clock Offset */
 extern void btsnd_hcic_read_lmp_handle(uint16_t handle); /* Remote LMP Handle */
-extern void btsnd_hcic_setup_esco_conn(uint16_t handle,
-                                       uint32_t transmit_bandwidth,
-                                       uint32_t receive_bandwidth,
-                                       uint16_t max_latency, uint16_t voice,
-                                       uint8_t retrans_effort,
+
+extern void btsnd_hcic_setup_esco_conn(uint16_t handle, uint32_t tx_bw,
+                                       uint32_t rx_bw, uint16_t max_latency,
+                                       uint16_t voice, uint8_t retrans_effort,
                                        uint16_t packet_types);
 #define HCIC_PARAM_SIZE_SETUP_ESCO 17
 
@@ -247,6 +245,11 @@ extern void btsnd_hcic_accept_esco_conn(
     const RawAddress& bd_addr, uint32_t transmit_bandwidth,
     uint32_t receive_bandwidth, uint16_t max_latency, uint16_t content_fmt,
     uint8_t retrans_effort, uint16_t packet_types);
+extern void btsnd_hcic_accept_esco_conn(BD_ADDR bd_addr, uint32_t tx_bw,
+                                        uint32_t rx_bw, uint16_t max_latency,
+                                        uint16_t content_fmt,
+                                        uint8_t retrans_effort,
+                                        uint16_t packet_types);
 #define HCIC_PARAM_SIZE_ACCEPT_ESCO 21
 
 #define HCI_ACCEPT_ESCO_BDADDR_OFF 0
@@ -528,9 +531,6 @@ extern void btsnd_hcic_write_scan_enable(uint8_t flag); /* Write Scan Enable */
 extern void btsnd_hcic_write_pagescan_cfg(
     uint16_t interval, uint16_t window); /* Write Page Scan Activity */
 
-#define HCIC_PARAM_SIZE_ENH_SET_ESCO_CONN 59
-#define HCIC_PARAM_SIZE_ENH_ACC_ESCO_CONN 63
-
 #define HCIC_PARAM_SIZE_WRITE_PAGESCAN_CFG 4
 
 #define HCI_SCAN_CFG_INTERVAL_OFF 0
diff --git a/system/bt/stack/include/sdpdefs.h b/system/bt/stack/include/sdpdefs.h
index 05b3cc1ba..75d23593e 100644
--- a/system/bt/stack/include/sdpdefs.h
+++ b/system/bt/stack/include/sdpdefs.h
@@ -286,8 +286,10 @@
 
 #define UUID_SERVCLASS_TEST_SERVER 0x9000 /* Test Group UUID */
 
+#if (BTM_WBS_INCLUDED == TRUE)
 #define UUID_CODEC_CVSD 0x0001 /* CVSD */
 #define UUID_CODEC_MSBC 0x0002 /* mSBC */
+#endif
 
 #define UUID_HF_IND_ENHANCED_DRIVER_SAFETY 0x0001 /* Enhanced Safety */
 #define UUID_HF_IND_BATTERY_LEVEL_STATUS 0x0002   /* Battery Status */
-- 
2.17.1

